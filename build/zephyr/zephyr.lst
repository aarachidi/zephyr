
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

20400000 <__start>:
SECTION_FUNC(vectors, __start)
#if defined(CONFIG_RISCV_GP)
	/* Initialize global pointer */
	.option push
	.option norelax
	la gp, __global_pointer$
20400000:	5fc02197          	auipc	gp,0x5fc02
20400004:	80818193          	addi	gp,gp,-2040 # 80001808 <__global_pointer$>

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
20400008:	00000297          	auipc	t0,0x0
2040000c:	01c28293          	addi	t0,t0,28 # 20400024 <__irq_wrapper>
	csrw mtvec, t0
20400010:	30529073          	csrw	mtvec,t0

	/* Jump to __reset */
	tail __reset
20400014:	00c0006f          	j	20400020 <__reset>

Disassembly of section reset:

20400020 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
20400020:	1bd010ef          	jal	ra,204019dc <__initialize>

Disassembly of section exceptions:

20400024 <__irq_wrapper>:
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	STORE_CALLER_SAVED()
20400024:	fb010113          	addi	sp,sp,-80
20400028:	00112023          	sw	ra,0(sp)
2040002c:	00412223          	sw	tp,4(sp)
20400030:	00512423          	sw	t0,8(sp)
20400034:	00612623          	sw	t1,12(sp)
20400038:	00712823          	sw	t2,16(sp)
2040003c:	01c12a23          	sw	t3,20(sp)
20400040:	01d12c23          	sw	t4,24(sp)
20400044:	01e12e23          	sw	t5,28(sp)
20400048:	03f12023          	sw	t6,32(sp)
2040004c:	02a12223          	sw	a0,36(sp)
20400050:	02b12423          	sw	a1,40(sp)
20400054:	02c12623          	sw	a2,44(sp)
20400058:	02d12823          	sw	a3,48(sp)
2040005c:	02e12a23          	sw	a4,52(sp)
20400060:	02f12c23          	sw	a5,56(sp)
20400064:	03012e23          	sw	a6,60(sp)
20400068:	05112023          	sw	a7,64(sp)

skip_store_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Save MEPC register */
	csrr t0, mepc
2040006c:	341022f3          	csrr	t0,mepc
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
20400070:	04512223          	sw	t0,68(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, mstatus
20400074:	300022f3          	csrr	t0,mstatus
	RV_OP_STOREREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
20400078:	04512423          	sw	t0,72(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
2040007c:	228000ef          	jal	ra,204002a4 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
20400080:	00000313          	li	t1,0
	bnez a0, is_interrupt
20400084:	02051e63          	bnez	a0,204000c0 <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
20400088:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
2040008c:	800003b7          	lui	t2,0x80000
20400090:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
20400094:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
20400098:	00b00313          	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	beq t0, t1, is_kernel_syscall
2040009c:	00628a63          	beq	t0,t1,204000b0 <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	addi a0, sp, 0
204000a0:	00010513          	mv	a0,sp
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
	RV_OP_LOADREG t0, _thread_offset_to_priv_stack_start(t1)
	RV_OP_STOREREG sp, _thread_offset_to_user_sp(t1) /* Update user SP */
	addi sp, t0, CONFIG_PRIVILEGED_STACK_SIZE
#else
	la ra, no_reschedule
204000a4:	00000097          	auipc	ra,0x0
204000a8:	19408093          	addi	ra,ra,404 # 20400238 <no_reschedule>
#endif /* CONFIG_USERSPACE */

	tail _Fault
204000ac:	0d10106f          	j	2040197c <_Fault>

204000b0 <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
204000b0:	04412283          	lw	t0,68(sp)
	addi t0, t0, 4
204000b4:	00428293          	addi	t0,t0,4
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
204000b8:	04512223          	sw	t0,68(sp)
	j z_riscv_user_mode_enter_syscall
#endif /* CONFIG_USERSPACE */
	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
204000bc:	0800006f          	j	2040013c <reschedule>

204000c0 <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
204000c0:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
204000c4:	5fc00397          	auipc	t2,0x5fc00
204000c8:	07038393          	addi	t2,t2,112 # 80000134 <_kernel>
	RV_OP_LOADREG sp, _kernel_offset_to_irq_stack(t2)
204000cc:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
204000d0:	ff010113          	addi	sp,sp,-16
	RV_OP_STOREREG t0, 0x00(sp)
204000d4:	00512023          	sw	t0,0(sp)

204000d8 <on_irq_stack>:
	la t2, _kernel
#endif /* !CONFIG_USERSPACE && !CONFIG_PMP_STACK_GUARD */

on_irq_stack:
	/* Increment _kernel.cpus[0].nested variable */
	lw t3, _kernel_offset_to_nested(t2)
204000d8:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
204000dc:	001e0e13          	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
204000e0:	01c3a023          	sw	t3,0(t2)
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
204000e4:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
204000e8:	800002b7          	lui	t0,0x80000
204000ec:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
204000f0:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
204000f4:	1a0000ef          	jal	ra,20400294 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
204000f8:	00004297          	auipc	t0,0x4
204000fc:	00428293          	addi	t0,t0,4 # 204040fc <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
20400100:	00351513          	slli	a0,a0,0x3
	add t0, t0, a0
20400104:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	RV_OP_LOADREG a0, 0x00(t0)
20400108:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	RV_OP_LOADREG t1, RV_REGSIZE(t0)
2040010c:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1
20400110:	000300e7          	jalr	t1

20400114 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
20400114:	5fc00317          	auipc	t1,0x5fc00
20400118:	02030313          	addi	t1,t1,32 # 80000134 <_kernel>

	/* Decrement _kernel.cpus[0].nested variable */
	lw t2, _kernel_offset_to_nested(t1)
2040011c:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
20400120:	fff38393          	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
20400124:	00732023          	sw	t2,0(t1)

#if !defined(CONFIG_USERSPACE) && !defined(CONFIG_PMP_STACK_GUARD)
	/* Restore thread stack pointer */
	RV_OP_LOADREG t0, 0x00(sp)
20400128:	00012283          	lw	t0,0(sp)
	addi sp, t0, 0
2040012c:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t2, _kernel_offset_to_current(t1)
20400130:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t1)
20400134:	01832e03          	lw	t3,24(t1)
	beq t3, t2, no_reschedule
20400138:	107e0063          	beq	t3,t2,20400238 <no_reschedule>

2040013c <reschedule>:
	 * Note:
	 *   Sometimes this code is execute back-to-back before the target thread
	 *   has a chance to run. If this happens, the current thread and the
	 *   target thread will be the same.
	 */
	la t0, _kernel
2040013c:	5fc00297          	auipc	t0,0x5fc00
20400140:	ff828293          	addi	t0,t0,-8 # 80000134 <_kernel>
	RV_OP_LOADREG t2, _kernel_offset_to_current(t0)
20400144:	0082a383          	lw	t2,8(t0)
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t0)
20400148:	0182ae03          	lw	t3,24(t0)
	beq t2, t3, no_reschedule
2040014c:	0fc38663          	beq	t2,t3,20400238 <no_reschedule>

#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	call z_thread_mark_switched_out
#endif
	/* Get reference to _kernel */
	la t0, _kernel
20400150:	5fc00297          	auipc	t0,0x5fc00
20400154:	fe428293          	addi	t0,t0,-28 # 80000134 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
20400158:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current kernel thread
	 * prior to handle context-switching
	 */
	STORE_CALLEE_SAVED(t1)
2040015c:	02832a23          	sw	s0,52(t1)
20400160:	02932c23          	sw	s1,56(t1)
20400164:	03232e23          	sw	s2,60(t1)
20400168:	05332023          	sw	s3,64(t1)
2040016c:	05432223          	sw	s4,68(t1)
20400170:	05532423          	sw	s5,72(t1)
20400174:	05632623          	sw	s6,76(t1)
20400178:	05732823          	sw	s7,80(t1)
2040017c:	05832a23          	sw	s8,84(t1)
20400180:	05932c23          	sw	s9,88(t1)
20400184:	05a32e23          	sw	s10,92(t1)
20400188:	07b32023          	sw	s11,96(t1)

2040018c <skip_callee_saved_reg>:

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	RV_OP_STOREREG sp, _thread_offset_to_sp(t1)
2040018c:	02232823          	sw	sp,48(t1)
	la t2, _k_neg_eagain
20400190:	00004397          	auipc	t2,0x4
20400194:	19438393          	addi	t2,t2,404 # 20404324 <_k_neg_eagain>
	lw t3, 0x00(t2)
20400198:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
2040019c:	07c32c23          	sw	t3,120(t1)

	/* Get next thread to schedule. */
	RV_OP_LOADREG t1, _kernel_offset_to_ready_q_cache(t0)
204001a0:	0182a303          	lw	t1,24(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	RV_OP_STOREREG t1, _kernel_offset_to_current(t0)
204001a4:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	RV_OP_LOADREG sp, _thread_offset_to_sp(t1)
204001a8:	03032103          	lw	sp,48(t1)

	/* Restore callee-saved registers of new thread */
	LOAD_CALLEE_SAVED(t1)
204001ac:	03432403          	lw	s0,52(t1)
204001b0:	03832483          	lw	s1,56(t1)
204001b4:	03c32903          	lw	s2,60(t1)
204001b8:	04032983          	lw	s3,64(t1)
204001bc:	04432a03          	lw	s4,68(t1)
204001c0:	04832a83          	lw	s5,72(t1)
204001c4:	04c32b03          	lw	s6,76(t1)
204001c8:	05032b83          	lw	s7,80(t1)
204001cc:	05432c03          	lw	s8,84(t1)
204001d0:	05832c83          	lw	s9,88(t1)
204001d4:	05c32d03          	lw	s10,92(t1)
204001d8:	06032d83          	lw	s11,96(t1)
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
204001dc:	04412283          	lw	t0,68(sp)
	csrw mepc, t0
204001e0:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
204001e4:	04812283          	lw	t0,72(sp)
	csrw mstatus, t0
204001e8:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved_resched:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
204001ec:	00012083          	lw	ra,0(sp)
204001f0:	00412203          	lw	tp,4(sp)
204001f4:	00812283          	lw	t0,8(sp)
204001f8:	00c12303          	lw	t1,12(sp)
204001fc:	01012383          	lw	t2,16(sp)
20400200:	01412e03          	lw	t3,20(sp)
20400204:	01812e83          	lw	t4,24(sp)
20400208:	01c12f03          	lw	t5,28(sp)
2040020c:	02012f83          	lw	t6,32(sp)
20400210:	02412503          	lw	a0,36(sp)
20400214:	02812583          	lw	a1,40(sp)
20400218:	02c12603          	lw	a2,44(sp)
2040021c:	03012683          	lw	a3,48(sp)
20400220:	03412703          	lw	a4,52(sp)
20400224:	03812783          	lw	a5,56(sp)
20400228:	03c12803          	lw	a6,60(sp)
2040022c:	04012883          	lw	a7,64(sp)
20400230:	05010113          	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
20400234:	30200073          	mret

20400238 <no_reschedule>:
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
20400238:	04412283          	lw	t0,68(sp)
	csrw mepc, t0
2040023c:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
20400240:	04812283          	lw	t0,72(sp)
	csrw mstatus, t0
20400244:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
20400248:	00012083          	lw	ra,0(sp)
2040024c:	00412203          	lw	tp,4(sp)
20400250:	00812283          	lw	t0,8(sp)
20400254:	00c12303          	lw	t1,12(sp)
20400258:	01012383          	lw	t2,16(sp)
2040025c:	01412e03          	lw	t3,20(sp)
20400260:	01812e83          	lw	t4,24(sp)
20400264:	01c12f03          	lw	t5,28(sp)
20400268:	02012f83          	lw	t6,32(sp)
2040026c:	02412503          	lw	a0,36(sp)
20400270:	02812583          	lw	a1,40(sp)
20400274:	02c12603          	lw	a2,44(sp)
20400278:	03012683          	lw	a3,48(sp)
2040027c:	03412703          	lw	a4,52(sp)
20400280:	03812783          	lw	a5,56(sp)
20400284:	03c12803          	lw	a6,60(sp)
20400288:	04012883          	lw	a7,64(sp)
2040028c:	05010113          	addi	sp,sp,80

#ifdef CONFIG_PMP_STACK_GUARD
	csrrw sp, mscratch, sp
#endif /* CONFIG_PMP_STACK_GUARD */
	/* Call SOC_ERET to exit ISR */
	SOC_ERET
20400290:	30200073          	mret

20400294 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
20400294:	00100313          	li	t1,1
	sll t0, t1, a0
20400298:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
2040029c:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
204002a0:	00008067          	ret

204002a4 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
204002a4:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
204002a8:	80000337          	lui	t1,0x80000
	and t0, t0, t1
204002ac:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
204002b0:	00000513          	li	a0,0
	beqz t0, not_interrupt
204002b4:	00028463          	beqz	t0,204002bc <not_interrupt>
	addi a0, a0, 1
204002b8:	00150513          	addi	a0,a0,1

204002bc <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
204002bc:	00008067          	ret

204002c0 <arch_swap>:
 * key is stored in a0 register
 */
SECTION_FUNC(exception.other, arch_swap)

	/* Make a system call to perform context switch */
	ecall
204002c0:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * arch_swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called arch_thread_return_value_set(..).
	 */
	la t0, _kernel
204002c4:	5fc00297          	auipc	t0,0x5fc00
204002c8:	e7028293          	addi	t0,t0,-400 # 80000134 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
204002cc:	0082a303          	lw	t1,8(t0)

	/* Load return value of arch_swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
204002d0:	07832383          	lw	t2,120(t1) # 80000078 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000079>

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, MSTATUS_IEN
204002d4:	00857513          	andi	a0,a0,8
	csrrs t0, mstatus, a0
204002d8:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
204002dc:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
204002e0:	00008067          	ret

Disassembly of section text:

204002e4 <__udivdi3>:
204002e4:	00050893          	mv	a7,a0
204002e8:	00058793          	mv	a5,a1
204002ec:	00060813          	mv	a6,a2
204002f0:	00068513          	mv	a0,a3
204002f4:	00088313          	mv	t1,a7
204002f8:	28069463          	bnez	a3,20400580 <__udivdi3+0x29c>
204002fc:	204046b7          	lui	a3,0x20404
20400300:	32868693          	addi	a3,a3,808 # 20404328 <__clz_tab>
20400304:	0ec5f663          	bgeu	a1,a2,204003f0 <__udivdi3+0x10c>
20400308:	00010737          	lui	a4,0x10
2040030c:	0ce67863          	bgeu	a2,a4,204003dc <__udivdi3+0xf8>
20400310:	0ff00713          	li	a4,255
20400314:	00c73733          	sltu	a4,a4,a2
20400318:	00371713          	slli	a4,a4,0x3
2040031c:	00e65533          	srl	a0,a2,a4
20400320:	00a686b3          	add	a3,a3,a0
20400324:	0006c683          	lbu	a3,0(a3)
20400328:	02000513          	li	a0,32
2040032c:	00e68733          	add	a4,a3,a4
20400330:	40e506b3          	sub	a3,a0,a4
20400334:	00e50c63          	beq	a0,a4,2040034c <__udivdi3+0x68>
20400338:	00d795b3          	sll	a1,a5,a3
2040033c:	00e8d733          	srl	a4,a7,a4
20400340:	00d61833          	sll	a6,a2,a3
20400344:	00b765b3          	or	a1,a4,a1
20400348:	00d89333          	sll	t1,a7,a3
2040034c:	01085893          	srli	a7,a6,0x10
20400350:	0315d6b3          	divu	a3,a1,a7
20400354:	01081613          	slli	a2,a6,0x10
20400358:	01065613          	srli	a2,a2,0x10
2040035c:	01035793          	srli	a5,t1,0x10
20400360:	0315f733          	remu	a4,a1,a7
20400364:	00068513          	mv	a0,a3
20400368:	02d605b3          	mul	a1,a2,a3
2040036c:	01071713          	slli	a4,a4,0x10
20400370:	00f767b3          	or	a5,a4,a5
20400374:	00b7fe63          	bgeu	a5,a1,20400390 <__udivdi3+0xac>
20400378:	010787b3          	add	a5,a5,a6
2040037c:	fff68513          	addi	a0,a3,-1
20400380:	0107e863          	bltu	a5,a6,20400390 <__udivdi3+0xac>
20400384:	00b7f663          	bgeu	a5,a1,20400390 <__udivdi3+0xac>
20400388:	ffe68513          	addi	a0,a3,-2
2040038c:	010787b3          	add	a5,a5,a6
20400390:	40b787b3          	sub	a5,a5,a1
20400394:	0317f733          	remu	a4,a5,a7
20400398:	01031313          	slli	t1,t1,0x10
2040039c:	01035313          	srli	t1,t1,0x10
204003a0:	0317d7b3          	divu	a5,a5,a7
204003a4:	01071713          	slli	a4,a4,0x10
204003a8:	00676333          	or	t1,a4,t1
204003ac:	02f606b3          	mul	a3,a2,a5
204003b0:	00078613          	mv	a2,a5
204003b4:	00d37c63          	bgeu	t1,a3,204003cc <__udivdi3+0xe8>
204003b8:	00680333          	add	t1,a6,t1
204003bc:	fff78613          	addi	a2,a5,-1
204003c0:	01036663          	bltu	t1,a6,204003cc <__udivdi3+0xe8>
204003c4:	00d37463          	bgeu	t1,a3,204003cc <__udivdi3+0xe8>
204003c8:	ffe78613          	addi	a2,a5,-2
204003cc:	01051513          	slli	a0,a0,0x10
204003d0:	00c56533          	or	a0,a0,a2
204003d4:	00000593          	li	a1,0
204003d8:	0e40006f          	j	204004bc <__udivdi3+0x1d8>
204003dc:	01000537          	lui	a0,0x1000
204003e0:	01000713          	li	a4,16
204003e4:	f2a66ce3          	bltu	a2,a0,2040031c <__udivdi3+0x38>
204003e8:	01800713          	li	a4,24
204003ec:	f31ff06f          	j	2040031c <__udivdi3+0x38>
204003f0:	00061663          	bnez	a2,204003fc <__udivdi3+0x118>
204003f4:	00100713          	li	a4,1
204003f8:	02c75833          	divu	a6,a4,a2
204003fc:	00010737          	lui	a4,0x10
20400400:	0ce87063          	bgeu	a6,a4,204004c0 <__udivdi3+0x1dc>
20400404:	0ff00713          	li	a4,255
20400408:	01077463          	bgeu	a4,a6,20400410 <__udivdi3+0x12c>
2040040c:	00800513          	li	a0,8
20400410:	00a85733          	srl	a4,a6,a0
20400414:	00e686b3          	add	a3,a3,a4
20400418:	0006c703          	lbu	a4,0(a3)
2040041c:	02000613          	li	a2,32
20400420:	00a70733          	add	a4,a4,a0
20400424:	40e606b3          	sub	a3,a2,a4
20400428:	0ae61663          	bne	a2,a4,204004d4 <__udivdi3+0x1f0>
2040042c:	410787b3          	sub	a5,a5,a6
20400430:	00100593          	li	a1,1
20400434:	01085893          	srli	a7,a6,0x10
20400438:	01081613          	slli	a2,a6,0x10
2040043c:	01065613          	srli	a2,a2,0x10
20400440:	01035713          	srli	a4,t1,0x10
20400444:	0317f6b3          	remu	a3,a5,a7
20400448:	0317d7b3          	divu	a5,a5,a7
2040044c:	01069693          	slli	a3,a3,0x10
20400450:	00e6e733          	or	a4,a3,a4
20400454:	02f60e33          	mul	t3,a2,a5
20400458:	00078513          	mv	a0,a5
2040045c:	01c77e63          	bgeu	a4,t3,20400478 <__udivdi3+0x194>
20400460:	01070733          	add	a4,a4,a6
20400464:	fff78513          	addi	a0,a5,-1
20400468:	01076863          	bltu	a4,a6,20400478 <__udivdi3+0x194>
2040046c:	01c77663          	bgeu	a4,t3,20400478 <__udivdi3+0x194>
20400470:	ffe78513          	addi	a0,a5,-2
20400474:	01070733          	add	a4,a4,a6
20400478:	41c70733          	sub	a4,a4,t3
2040047c:	031777b3          	remu	a5,a4,a7
20400480:	01031313          	slli	t1,t1,0x10
20400484:	01035313          	srli	t1,t1,0x10
20400488:	03175733          	divu	a4,a4,a7
2040048c:	01079793          	slli	a5,a5,0x10
20400490:	0067e333          	or	t1,a5,t1
20400494:	02e606b3          	mul	a3,a2,a4
20400498:	00070613          	mv	a2,a4
2040049c:	00d37c63          	bgeu	t1,a3,204004b4 <__udivdi3+0x1d0>
204004a0:	00680333          	add	t1,a6,t1
204004a4:	fff70613          	addi	a2,a4,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
204004a8:	01036663          	bltu	t1,a6,204004b4 <__udivdi3+0x1d0>
204004ac:	00d37463          	bgeu	t1,a3,204004b4 <__udivdi3+0x1d0>
204004b0:	ffe70613          	addi	a2,a4,-2
204004b4:	01051513          	slli	a0,a0,0x10
204004b8:	00c56533          	or	a0,a0,a2
204004bc:	00008067          	ret
204004c0:	01000737          	lui	a4,0x1000
204004c4:	01000513          	li	a0,16
204004c8:	f4e864e3          	bltu	a6,a4,20400410 <__udivdi3+0x12c>
204004cc:	01800513          	li	a0,24
204004d0:	f41ff06f          	j	20400410 <__udivdi3+0x12c>
204004d4:	00d81833          	sll	a6,a6,a3
204004d8:	00e7d533          	srl	a0,a5,a4
204004dc:	00d89333          	sll	t1,a7,a3
204004e0:	00d797b3          	sll	a5,a5,a3
204004e4:	00e8d733          	srl	a4,a7,a4
204004e8:	01085893          	srli	a7,a6,0x10
204004ec:	00f76633          	or	a2,a4,a5
204004f0:	03157733          	remu	a4,a0,a7
204004f4:	01081793          	slli	a5,a6,0x10
204004f8:	0107d793          	srli	a5,a5,0x10
204004fc:	01065593          	srli	a1,a2,0x10
20400500:	03155533          	divu	a0,a0,a7
20400504:	01071713          	slli	a4,a4,0x10
20400508:	00b76733          	or	a4,a4,a1
2040050c:	02a786b3          	mul	a3,a5,a0
20400510:	00050593          	mv	a1,a0
20400514:	00d77e63          	bgeu	a4,a3,20400530 <__udivdi3+0x24c>
20400518:	01070733          	add	a4,a4,a6
2040051c:	fff50593          	addi	a1,a0,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xff7fff>
20400520:	01076863          	bltu	a4,a6,20400530 <__udivdi3+0x24c>
20400524:	00d77663          	bgeu	a4,a3,20400530 <__udivdi3+0x24c>
20400528:	ffe50593          	addi	a1,a0,-2
2040052c:	01070733          	add	a4,a4,a6
20400530:	40d706b3          	sub	a3,a4,a3
20400534:	0316f733          	remu	a4,a3,a7
20400538:	01061613          	slli	a2,a2,0x10
2040053c:	01065613          	srli	a2,a2,0x10
20400540:	0316d6b3          	divu	a3,a3,a7
20400544:	01071713          	slli	a4,a4,0x10
20400548:	02d78533          	mul	a0,a5,a3
2040054c:	00c767b3          	or	a5,a4,a2
20400550:	00068713          	mv	a4,a3
20400554:	00a7fe63          	bgeu	a5,a0,20400570 <__udivdi3+0x28c>
20400558:	010787b3          	add	a5,a5,a6
2040055c:	fff68713          	addi	a4,a3,-1
20400560:	0107e863          	bltu	a5,a6,20400570 <__udivdi3+0x28c>
20400564:	00a7f663          	bgeu	a5,a0,20400570 <__udivdi3+0x28c>
20400568:	ffe68713          	addi	a4,a3,-2
2040056c:	010787b3          	add	a5,a5,a6
20400570:	01059593          	slli	a1,a1,0x10
20400574:	40a787b3          	sub	a5,a5,a0
20400578:	00e5e5b3          	or	a1,a1,a4
2040057c:	eb9ff06f          	j	20400434 <__udivdi3+0x150>
20400580:	18d5e663          	bltu	a1,a3,2040070c <__udivdi3+0x428>
20400584:	00010737          	lui	a4,0x10
20400588:	04e6f463          	bgeu	a3,a4,204005d0 <__udivdi3+0x2ec>
2040058c:	0ff00713          	li	a4,255
20400590:	00d735b3          	sltu	a1,a4,a3
20400594:	00359593          	slli	a1,a1,0x3
20400598:	20404737          	lui	a4,0x20404
2040059c:	00b6d533          	srl	a0,a3,a1
204005a0:	32870713          	addi	a4,a4,808 # 20404328 <__clz_tab>
204005a4:	00a70733          	add	a4,a4,a0
204005a8:	00074703          	lbu	a4,0(a4)
204005ac:	02000513          	li	a0,32
204005b0:	00b70733          	add	a4,a4,a1
204005b4:	40e505b3          	sub	a1,a0,a4
204005b8:	02e51663          	bne	a0,a4,204005e4 <__udivdi3+0x300>
204005bc:	00100513          	li	a0,1
204005c0:	eef6eee3          	bltu	a3,a5,204004bc <__udivdi3+0x1d8>
204005c4:	00c8b533          	sltu	a0,a7,a2
204005c8:	00154513          	xori	a0,a0,1
204005cc:	ef1ff06f          	j	204004bc <__udivdi3+0x1d8>
204005d0:	01000737          	lui	a4,0x1000
204005d4:	01000593          	li	a1,16
204005d8:	fce6e0e3          	bltu	a3,a4,20400598 <__udivdi3+0x2b4>
204005dc:	01800593          	li	a1,24
204005e0:	fb9ff06f          	j	20400598 <__udivdi3+0x2b4>
204005e4:	00e65833          	srl	a6,a2,a4
204005e8:	00b696b3          	sll	a3,a3,a1
204005ec:	00d86833          	or	a6,a6,a3
204005f0:	00e7de33          	srl	t3,a5,a4
204005f4:	01085e93          	srli	t4,a6,0x10
204005f8:	03de76b3          	remu	a3,t3,t4
204005fc:	00b797b3          	sll	a5,a5,a1
20400600:	00e8d733          	srl	a4,a7,a4
20400604:	00b61333          	sll	t1,a2,a1
20400608:	00f76633          	or	a2,a4,a5
2040060c:	01081793          	slli	a5,a6,0x10
20400610:	0107d793          	srli	a5,a5,0x10
20400614:	01065713          	srli	a4,a2,0x10
20400618:	03de5e33          	divu	t3,t3,t4
2040061c:	01069693          	slli	a3,a3,0x10
20400620:	00e6e733          	or	a4,a3,a4
20400624:	03c78f33          	mul	t5,a5,t3
20400628:	000e0513          	mv	a0,t3
2040062c:	01e77e63          	bgeu	a4,t5,20400648 <__udivdi3+0x364>
20400630:	01070733          	add	a4,a4,a6
20400634:	fffe0513          	addi	a0,t3,-1
20400638:	01076863          	bltu	a4,a6,20400648 <__udivdi3+0x364>
2040063c:	01e77663          	bgeu	a4,t5,20400648 <__udivdi3+0x364>
20400640:	ffee0513          	addi	a0,t3,-2
20400644:	01070733          	add	a4,a4,a6
20400648:	41e70733          	sub	a4,a4,t5
2040064c:	03d776b3          	remu	a3,a4,t4
20400650:	03d75733          	divu	a4,a4,t4
20400654:	01069693          	slli	a3,a3,0x10
20400658:	02e78e33          	mul	t3,a5,a4
2040065c:	01061793          	slli	a5,a2,0x10
20400660:	0107d793          	srli	a5,a5,0x10
20400664:	00f6e7b3          	or	a5,a3,a5
20400668:	00070613          	mv	a2,a4
2040066c:	01c7fe63          	bgeu	a5,t3,20400688 <__udivdi3+0x3a4>
20400670:	010787b3          	add	a5,a5,a6
20400674:	fff70613          	addi	a2,a4,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xff7fff>
20400678:	0107e863          	bltu	a5,a6,20400688 <__udivdi3+0x3a4>
2040067c:	01c7f663          	bgeu	a5,t3,20400688 <__udivdi3+0x3a4>
20400680:	ffe70613          	addi	a2,a4,-2
20400684:	010787b3          	add	a5,a5,a6
20400688:	01051513          	slli	a0,a0,0x10
2040068c:	00010eb7          	lui	t4,0x10
20400690:	00c56533          	or	a0,a0,a2
20400694:	fffe8693          	addi	a3,t4,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
20400698:	00d57833          	and	a6,a0,a3
2040069c:	01055613          	srli	a2,a0,0x10
204006a0:	00d376b3          	and	a3,t1,a3
204006a4:	01035313          	srli	t1,t1,0x10
204006a8:	41c787b3          	sub	a5,a5,t3
204006ac:	02d80e33          	mul	t3,a6,a3
204006b0:	02d606b3          	mul	a3,a2,a3
204006b4:	010e5713          	srli	a4,t3,0x10
204006b8:	02680833          	mul	a6,a6,t1
204006bc:	00d80833          	add	a6,a6,a3
204006c0:	01070733          	add	a4,a4,a6
204006c4:	02660633          	mul	a2,a2,t1
204006c8:	00d77463          	bgeu	a4,a3,204006d0 <__udivdi3+0x3ec>
204006cc:	01d60633          	add	a2,a2,t4
204006d0:	01075693          	srli	a3,a4,0x10
204006d4:	00c68633          	add	a2,a3,a2
204006d8:	02c7e663          	bltu	a5,a2,20400704 <__udivdi3+0x420>
204006dc:	cec79ce3          	bne	a5,a2,204003d4 <__udivdi3+0xf0>
204006e0:	000107b7          	lui	a5,0x10
204006e4:	fff78793          	addi	a5,a5,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
204006e8:	00f77733          	and	a4,a4,a5
204006ec:	01071713          	slli	a4,a4,0x10
204006f0:	00fe7e33          	and	t3,t3,a5
204006f4:	00b898b3          	sll	a7,a7,a1
204006f8:	01c70733          	add	a4,a4,t3
204006fc:	00000593          	li	a1,0
20400700:	dae8fee3          	bgeu	a7,a4,204004bc <__udivdi3+0x1d8>
20400704:	fff50513          	addi	a0,a0,-1
20400708:	ccdff06f          	j	204003d4 <__udivdi3+0xf0>
2040070c:	00000593          	li	a1,0
20400710:	00000513          	li	a0,0
20400714:	da9ff06f          	j	204004bc <__udivdi3+0x1d8>

20400718 <__umoddi3>:
20400718:	00050e93          	mv	t4,a0
2040071c:	00058313          	mv	t1,a1
20400720:	00060813          	mv	a6,a2
20400724:	00068793          	mv	a5,a3
20400728:	22069a63          	bnez	a3,2040095c <__umoddi3+0x244>
2040072c:	20404737          	lui	a4,0x20404
20400730:	32870713          	addi	a4,a4,808 # 20404328 <__clz_tab>
20400734:	0cc5fc63          	bgeu	a1,a2,2040080c <__umoddi3+0xf4>
20400738:	000106b7          	lui	a3,0x10
2040073c:	0ad67e63          	bgeu	a2,a3,204007f8 <__umoddi3+0xe0>
20400740:	0ff00693          	li	a3,255
20400744:	00c6f463          	bgeu	a3,a2,2040074c <__umoddi3+0x34>
20400748:	00800793          	li	a5,8
2040074c:	00f656b3          	srl	a3,a2,a5
20400750:	00d70733          	add	a4,a4,a3
20400754:	00074703          	lbu	a4,0(a4)
20400758:	00f707b3          	add	a5,a4,a5
2040075c:	02000713          	li	a4,32
20400760:	40f708b3          	sub	a7,a4,a5
20400764:	00f70c63          	beq	a4,a5,2040077c <__umoddi3+0x64>
20400768:	011315b3          	sll	a1,t1,a7
2040076c:	00fed7b3          	srl	a5,t4,a5
20400770:	01161833          	sll	a6,a2,a7
20400774:	00b7e5b3          	or	a1,a5,a1
20400778:	011e9533          	sll	a0,t4,a7
2040077c:	01085693          	srli	a3,a6,0x10
20400780:	02d5f7b3          	remu	a5,a1,a3
20400784:	01081613          	slli	a2,a6,0x10
20400788:	01065613          	srli	a2,a2,0x10
2040078c:	01055713          	srli	a4,a0,0x10
20400790:	02d5d5b3          	divu	a1,a1,a3
20400794:	01079793          	slli	a5,a5,0x10
20400798:	00e7e733          	or	a4,a5,a4
2040079c:	02b605b3          	mul	a1,a2,a1
204007a0:	00b77a63          	bgeu	a4,a1,204007b4 <__umoddi3+0x9c>
204007a4:	01070733          	add	a4,a4,a6
204007a8:	01076663          	bltu	a4,a6,204007b4 <__umoddi3+0x9c>
204007ac:	00b77463          	bgeu	a4,a1,204007b4 <__umoddi3+0x9c>
204007b0:	01070733          	add	a4,a4,a6
204007b4:	40b70733          	sub	a4,a4,a1
204007b8:	02d777b3          	remu	a5,a4,a3
204007bc:	01051513          	slli	a0,a0,0x10
204007c0:	01055513          	srli	a0,a0,0x10
204007c4:	02d75733          	divu	a4,a4,a3
204007c8:	01079793          	slli	a5,a5,0x10
204007cc:	00a7e533          	or	a0,a5,a0
204007d0:	02e60733          	mul	a4,a2,a4
204007d4:	00e57a63          	bgeu	a0,a4,204007e8 <__umoddi3+0xd0>
204007d8:	01050533          	add	a0,a0,a6
204007dc:	01056663          	bltu	a0,a6,204007e8 <__umoddi3+0xd0>
204007e0:	00e57463          	bgeu	a0,a4,204007e8 <__umoddi3+0xd0>
204007e4:	01050533          	add	a0,a0,a6
204007e8:	40e50533          	sub	a0,a0,a4
204007ec:	01155533          	srl	a0,a0,a7
204007f0:	00000593          	li	a1,0
204007f4:	00008067          	ret
204007f8:	010006b7          	lui	a3,0x1000
204007fc:	01000793          	li	a5,16
20400800:	f4d666e3          	bltu	a2,a3,2040074c <__umoddi3+0x34>
20400804:	01800793          	li	a5,24
20400808:	f45ff06f          	j	2040074c <__umoddi3+0x34>
2040080c:	00061663          	bnez	a2,20400818 <__umoddi3+0x100>
20400810:	00100693          	li	a3,1
20400814:	02c6d833          	divu	a6,a3,a2
20400818:	000106b7          	lui	a3,0x10
2040081c:	12d87663          	bgeu	a6,a3,20400948 <__umoddi3+0x230>
20400820:	0ff00693          	li	a3,255
20400824:	0106f463          	bgeu	a3,a6,2040082c <__umoddi3+0x114>
20400828:	00800793          	li	a5,8
2040082c:	00f856b3          	srl	a3,a6,a5
20400830:	00d70733          	add	a4,a4,a3
20400834:	00074603          	lbu	a2,0(a4)
20400838:	410305b3          	sub	a1,t1,a6
2040083c:	00f60633          	add	a2,a2,a5
20400840:	02000793          	li	a5,32
20400844:	40c788b3          	sub	a7,a5,a2
20400848:	08c78663          	beq	a5,a2,204008d4 <__umoddi3+0x1bc>
2040084c:	01181833          	sll	a6,a6,a7
20400850:	00c357b3          	srl	a5,t1,a2
20400854:	011315b3          	sll	a1,t1,a7
20400858:	01085313          	srli	t1,a6,0x10
2040085c:	00ced633          	srl	a2,t4,a2
20400860:	00b66633          	or	a2,a2,a1
20400864:	01081593          	slli	a1,a6,0x10
20400868:	0105d593          	srli	a1,a1,0x10
2040086c:	011e9533          	sll	a0,t4,a7
20400870:	0267d6b3          	divu	a3,a5,t1
20400874:	0267f733          	remu	a4,a5,t1
20400878:	01065793          	srli	a5,a2,0x10
2040087c:	02d586b3          	mul	a3,a1,a3
20400880:	01071713          	slli	a4,a4,0x10
20400884:	00f76733          	or	a4,a4,a5
20400888:	00d77a63          	bgeu	a4,a3,2040089c <__umoddi3+0x184>
2040088c:	01070733          	add	a4,a4,a6
20400890:	01076663          	bltu	a4,a6,2040089c <__umoddi3+0x184>
20400894:	00d77463          	bgeu	a4,a3,2040089c <__umoddi3+0x184>
20400898:	01070733          	add	a4,a4,a6
2040089c:	40d706b3          	sub	a3,a4,a3
204008a0:	0266f733          	remu	a4,a3,t1
204008a4:	01061613          	slli	a2,a2,0x10
204008a8:	01065613          	srli	a2,a2,0x10
204008ac:	0266d6b3          	divu	a3,a3,t1
204008b0:	01071713          	slli	a4,a4,0x10
204008b4:	02d586b3          	mul	a3,a1,a3
204008b8:	00c765b3          	or	a1,a4,a2
204008bc:	00d5fa63          	bgeu	a1,a3,204008d0 <__umoddi3+0x1b8>
204008c0:	010585b3          	add	a1,a1,a6
204008c4:	0105e663          	bltu	a1,a6,204008d0 <__umoddi3+0x1b8>
204008c8:	00d5f463          	bgeu	a1,a3,204008d0 <__umoddi3+0x1b8>
204008cc:	010585b3          	add	a1,a1,a6
204008d0:	40d585b3          	sub	a1,a1,a3
204008d4:	01085693          	srli	a3,a6,0x10
204008d8:	02d5f733          	remu	a4,a1,a3
204008dc:	01081793          	slli	a5,a6,0x10
204008e0:	0107d793          	srli	a5,a5,0x10
204008e4:	01055613          	srli	a2,a0,0x10
204008e8:	02d5d5b3          	divu	a1,a1,a3
204008ec:	01071713          	slli	a4,a4,0x10
204008f0:	00c76733          	or	a4,a4,a2
204008f4:	02b785b3          	mul	a1,a5,a1
204008f8:	00b77a63          	bgeu	a4,a1,2040090c <__umoddi3+0x1f4>
204008fc:	01070733          	add	a4,a4,a6
20400900:	01076663          	bltu	a4,a6,2040090c <__umoddi3+0x1f4>
20400904:	00b77463          	bgeu	a4,a1,2040090c <__umoddi3+0x1f4>
20400908:	01070733          	add	a4,a4,a6
2040090c:	40b705b3          	sub	a1,a4,a1
20400910:	02d5f733          	remu	a4,a1,a3
20400914:	01051513          	slli	a0,a0,0x10
20400918:	01055513          	srli	a0,a0,0x10
2040091c:	02d5d5b3          	divu	a1,a1,a3
20400920:	02b785b3          	mul	a1,a5,a1
20400924:	01071793          	slli	a5,a4,0x10
20400928:	00a7e533          	or	a0,a5,a0
2040092c:	00b57a63          	bgeu	a0,a1,20400940 <__umoddi3+0x228>
20400930:	01050533          	add	a0,a0,a6
20400934:	01056663          	bltu	a0,a6,20400940 <__umoddi3+0x228>
20400938:	00b57463          	bgeu	a0,a1,20400940 <__umoddi3+0x228>
2040093c:	01050533          	add	a0,a0,a6
20400940:	40b50533          	sub	a0,a0,a1
20400944:	ea9ff06f          	j	204007ec <__umoddi3+0xd4>
20400948:	010006b7          	lui	a3,0x1000
2040094c:	01000793          	li	a5,16
20400950:	ecd86ee3          	bltu	a6,a3,2040082c <__umoddi3+0x114>
20400954:	01800793          	li	a5,24
20400958:	ed5ff06f          	j	2040082c <__umoddi3+0x114>
2040095c:	e8d5ece3          	bltu	a1,a3,204007f4 <__umoddi3+0xdc>
20400960:	000107b7          	lui	a5,0x10
20400964:	04f6f863          	bgeu	a3,a5,204009b4 <__umoddi3+0x29c>
20400968:	0ff00893          	li	a7,255
2040096c:	00d8b7b3          	sltu	a5,a7,a3
20400970:	00379793          	slli	a5,a5,0x3
20400974:	20404737          	lui	a4,0x20404
20400978:	00f6d833          	srl	a6,a3,a5
2040097c:	32870713          	addi	a4,a4,808 # 20404328 <__clz_tab>
20400980:	01070733          	add	a4,a4,a6
20400984:	00074883          	lbu	a7,0(a4)
20400988:	00f888b3          	add	a7,a7,a5
2040098c:	02000793          	li	a5,32
20400990:	41178833          	sub	a6,a5,a7
20400994:	03179a63          	bne	a5,a7,204009c8 <__umoddi3+0x2b0>
20400998:	0066e463          	bltu	a3,t1,204009a0 <__umoddi3+0x288>
2040099c:	e4ceece3          	bltu	t4,a2,204007f4 <__umoddi3+0xdc>
204009a0:	40ce8533          	sub	a0,t4,a2
204009a4:	40d305b3          	sub	a1,t1,a3
204009a8:	00aebeb3          	sltu	t4,t4,a0
204009ac:	41d585b3          	sub	a1,a1,t4
204009b0:	e45ff06f          	j	204007f4 <__umoddi3+0xdc>
204009b4:	01000737          	lui	a4,0x1000
204009b8:	01000793          	li	a5,16
204009bc:	fae6ece3          	bltu	a3,a4,20400974 <__umoddi3+0x25c>
204009c0:	01800793          	li	a5,24
204009c4:	fb1ff06f          	j	20400974 <__umoddi3+0x25c>
204009c8:	011657b3          	srl	a5,a2,a7
204009cc:	010696b3          	sll	a3,a3,a6
204009d0:	00d7ee33          	or	t3,a5,a3
204009d4:	01135f33          	srl	t5,t1,a7
204009d8:	011ed7b3          	srl	a5,t4,a7
204009dc:	010e9533          	sll	a0,t4,a6
204009e0:	010e5e93          	srli	t4,t3,0x10
204009e4:	010315b3          	sll	a1,t1,a6
204009e8:	03df5333          	divu	t1,t5,t4
204009ec:	00b7e7b3          	or	a5,a5,a1
204009f0:	010e1593          	slli	a1,t3,0x10
204009f4:	0105d593          	srli	a1,a1,0x10
204009f8:	0107d713          	srli	a4,a5,0x10
204009fc:	01061633          	sll	a2,a2,a6
20400a00:	03df76b3          	remu	a3,t5,t4
20400a04:	02658f33          	mul	t5,a1,t1
20400a08:	01069693          	slli	a3,a3,0x10
20400a0c:	00e6e733          	or	a4,a3,a4
20400a10:	00030693          	mv	a3,t1
20400a14:	01e77e63          	bgeu	a4,t5,20400a30 <__umoddi3+0x318>
20400a18:	01c70733          	add	a4,a4,t3
20400a1c:	fff30693          	addi	a3,t1,-1
20400a20:	01c76863          	bltu	a4,t3,20400a30 <__umoddi3+0x318>
20400a24:	01e77663          	bgeu	a4,t5,20400a30 <__umoddi3+0x318>
20400a28:	ffe30693          	addi	a3,t1,-2
20400a2c:	01c70733          	add	a4,a4,t3
20400a30:	41e70733          	sub	a4,a4,t5
20400a34:	03d77333          	remu	t1,a4,t4
20400a38:	01079793          	slli	a5,a5,0x10
20400a3c:	0107d793          	srli	a5,a5,0x10
20400a40:	03d75733          	divu	a4,a4,t4
20400a44:	01031313          	slli	t1,t1,0x10
20400a48:	00f36333          	or	t1,t1,a5
20400a4c:	02e585b3          	mul	a1,a1,a4
20400a50:	00070793          	mv	a5,a4
20400a54:	00b37e63          	bgeu	t1,a1,20400a70 <__umoddi3+0x358>
20400a58:	01c30333          	add	t1,t1,t3
20400a5c:	fff70793          	addi	a5,a4,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xff7fff>
20400a60:	01c36863          	bltu	t1,t3,20400a70 <__umoddi3+0x358>
20400a64:	00b37663          	bgeu	t1,a1,20400a70 <__umoddi3+0x358>
20400a68:	ffe70793          	addi	a5,a4,-2
20400a6c:	01c30333          	add	t1,t1,t3
20400a70:	01069693          	slli	a3,a3,0x10
20400a74:	00010f37          	lui	t5,0x10
20400a78:	00f6e6b3          	or	a3,a3,a5
20400a7c:	40b305b3          	sub	a1,t1,a1
20400a80:	ffff0313          	addi	t1,t5,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
20400a84:	0066feb3          	and	t4,a3,t1
20400a88:	01065713          	srli	a4,a2,0x10
20400a8c:	0106d693          	srli	a3,a3,0x10
20400a90:	00667333          	and	t1,a2,t1
20400a94:	026e87b3          	mul	a5,t4,t1
20400a98:	02668333          	mul	t1,a3,t1
20400a9c:	02ee8eb3          	mul	t4,t4,a4
20400aa0:	02e686b3          	mul	a3,a3,a4
20400aa4:	006e8eb3          	add	t4,t4,t1
20400aa8:	0107d713          	srli	a4,a5,0x10
20400aac:	01d70733          	add	a4,a4,t4
20400ab0:	00677463          	bgeu	a4,t1,20400ab8 <__umoddi3+0x3a0>
20400ab4:	01e686b3          	add	a3,a3,t5
20400ab8:	01075313          	srli	t1,a4,0x10
20400abc:	00d306b3          	add	a3,t1,a3
20400ac0:	00010337          	lui	t1,0x10
20400ac4:	fff30313          	addi	t1,t1,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
20400ac8:	00677733          	and	a4,a4,t1
20400acc:	01071713          	slli	a4,a4,0x10
20400ad0:	0067f7b3          	and	a5,a5,t1
20400ad4:	00f707b3          	add	a5,a4,a5
20400ad8:	00d5e663          	bltu	a1,a3,20400ae4 <__umoddi3+0x3cc>
20400adc:	00d59e63          	bne	a1,a3,20400af8 <__umoddi3+0x3e0>
20400ae0:	00f57c63          	bgeu	a0,a5,20400af8 <__umoddi3+0x3e0>
20400ae4:	40c78633          	sub	a2,a5,a2
20400ae8:	00c7b7b3          	sltu	a5,a5,a2
20400aec:	01c787b3          	add	a5,a5,t3
20400af0:	40f686b3          	sub	a3,a3,a5
20400af4:	00060793          	mv	a5,a2
20400af8:	40f507b3          	sub	a5,a0,a5
20400afc:	00f53533          	sltu	a0,a0,a5
20400b00:	40d585b3          	sub	a1,a1,a3
20400b04:	40a585b3          	sub	a1,a1,a0
20400b08:	011598b3          	sll	a7,a1,a7
20400b0c:	0107d533          	srl	a0,a5,a6
20400b10:	00a8e533          	or	a0,a7,a0
20400b14:	0105d5b3          	srl	a1,a1,a6
20400b18:	cddff06f          	j	204007f4 <__umoddi3+0xdc>

20400b1c <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
20400b1c:	00008067          	ret

20400b20 <main>:
#include <zephyr.h>
#include <sys/printk.h>

void main(void)
{
	printk("Hello World! %s\n", CONFIG_BOARD);
20400b20:	204045b7          	lui	a1,0x20404
20400b24:	20404537          	lui	a0,0x20404
20400b28:	42858593          	addi	a1,a1,1064 # 20404428 <__clz_tab+0x100>
20400b2c:	43050513          	addi	a0,a0,1072 # 20404430 <__clz_tab+0x108>
20400b30:	0600006f          	j	20400b90 <printk>

20400b34 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
20400b34:	00000513          	li	a0,0
20400b38:	00008067          	ret

20400b3c <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
20400b3c:	0005a783          	lw	a5,0(a1)
20400b40:	00178793          	addi	a5,a5,1 # 10001 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x8001>
20400b44:	00f5a023          	sw	a5,0(a1)
	return _char_out(c);
20400b48:	800017b7          	lui	a5,0x80001
20400b4c:	0087a783          	lw	a5,8(a5) # 80001008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001009>
20400b50:	00078067          	jr	a5

20400b54 <__printk_hook_install>:
	_char_out = fn;
20400b54:	800017b7          	lui	a5,0x80001
20400b58:	00a7a423          	sw	a0,8(a5) # 80001008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001009>
}
20400b5c:	00008067          	ret

20400b60 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
20400b60:	fe010113          	addi	sp,sp,-32
20400b64:	00050613          	mv	a2,a0
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
20400b68:	20401537          	lui	a0,0x20401
{
20400b6c:	00058693          	mv	a3,a1
	cbvprintf(char_out, &ctx, fmt, ap);
20400b70:	b3c50513          	addi	a0,a0,-1220 # 20400b3c <char_out>
20400b74:	00c10593          	addi	a1,sp,12
{
20400b78:	00112e23          	sw	ra,28(sp)
	struct out_context ctx = { 0 };
20400b7c:	00012623          	sw	zero,12(sp)
	cbvprintf(char_out, &ctx, fmt, ap);
20400b80:	244000ef          	jal	ra,20400dc4 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
20400b84:	01c12083          	lw	ra,28(sp)
20400b88:	02010113          	addi	sp,sp,32
20400b8c:	00008067          	ret

20400b90 <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
20400b90:	fc010113          	addi	sp,sp,-64
20400b94:	02b12223          	sw	a1,36(sp)
	va_list ap;

	va_start(ap, fmt);
20400b98:	02410593          	addi	a1,sp,36
{
20400b9c:	00112e23          	sw	ra,28(sp)
20400ba0:	02c12423          	sw	a2,40(sp)
20400ba4:	02d12623          	sw	a3,44(sp)
20400ba8:	02e12823          	sw	a4,48(sp)
20400bac:	02f12a23          	sw	a5,52(sp)
20400bb0:	03012c23          	sw	a6,56(sp)
20400bb4:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
20400bb8:	00b12623          	sw	a1,12(sp)

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
20400bbc:	fa5ff0ef          	jal	ra,20400b60 <vprintk>
	}
	va_end(ap);
}
20400bc0:	01c12083          	lw	ra,28(sp)
20400bc4:	04010113          	addi	sp,sp,64
20400bc8:	00008067          	ret

20400bcc <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
20400bcc:	ff010113          	addi	sp,sp,-16
20400bd0:	00050793          	mv	a5,a0
20400bd4:	00058513          	mv	a0,a1
20400bd8:	00060593          	mv	a1,a2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
20400bdc:	00068613          	mv	a2,a3
{
20400be0:	00112623          	sw	ra,12(sp)
	entry(p1, p2, p3);
20400be4:	000780e7          	jalr	a5
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
20400be8:	665020ef          	jal	ra,20403a4c <z_impl_z_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
20400bec:	761020ef          	jal	ra,20403b4c <z_impl_k_thread_abort>

20400bf0 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
20400bf0:	fd010113          	addi	sp,sp,-48
20400bf4:	02812423          	sw	s0,40(sp)
20400bf8:	02912223          	sw	s1,36(sp)
20400bfc:	03212023          	sw	s2,32(sp)
20400c00:	01312e23          	sw	s3,28(sp)
20400c04:	01712623          	sw	s7,12(sp)
20400c08:	01812423          	sw	s8,8(sp)
20400c0c:	01912223          	sw	s9,4(sp)
20400c10:	02112623          	sw	ra,44(sp)
20400c14:	01412c23          	sw	s4,24(sp)
20400c18:	01512a23          	sw	s5,20(sp)
20400c1c:	01612823          	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier);
20400c20:	00364783          	lbu	a5,3(a2)
{
20400c24:	00070413          	mv	s0,a4
	switch (specifier) {
20400c28:	06f00713          	li	a4,111
{
20400c2c:	00050c13          	mv	s8,a0
20400c30:	00058c93          	mv	s9,a1
20400c34:	00060b93          	mv	s7,a2
20400c38:	00068913          	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
20400c3c:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
20400c40:	00800493          	li	s1,8
20400c44:	00e78c63          	beq	a5,a4,20400c5c <encode_uint+0x6c>
20400c48:	0cf76263          	bltu	a4,a5,20400d0c <encode_uint+0x11c>
20400c4c:	05800713          	li	a4,88
		return 10;
20400c50:	00a00493          	li	s1,10
	switch (specifier) {
20400c54:	00e79463          	bne	a5,a4,20400c5c <encode_uint+0x6c>
		return 16;
20400c58:	01000493          	li	s1,16
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
20400c5c:	00000a93          	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
20400c60:	00900a13          	li	s4,9
20400c64:	01900b13          	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
20400c68:	00048613          	mv	a2,s1
20400c6c:	00000693          	li	a3,0
20400c70:	000c0513          	mv	a0,s8
20400c74:	000c8593          	mv	a1,s9
20400c78:	aa1ff0ef          	jal	ra,20400718 <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
20400c7c:	0ff57793          	andi	a5,a0,255
20400c80:	0aaa6263          	bltu	s4,a0,20400d24 <encode_uint+0x134>
20400c84:	03078793          	addi	a5,a5,48
20400c88:	0ff7f793          	andi	a5,a5,255
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
20400c8c:	00048613          	mv	a2,s1
20400c90:	00000693          	li	a3,0
20400c94:	000c0513          	mv	a0,s8
20400c98:	000c8593          	mv	a1,s9
		*--bp = (lsv <= 9) ? ('0' + lsv)
20400c9c:	fef40fa3          	sb	a5,-1(s0)
20400ca0:	fff40413          	addi	s0,s0,-1
		value /= radix;
20400ca4:	e40ff0ef          	jal	ra,204002e4 <__udivdi3>
	} while ((value != 0) && (bps < bp));
20400ca8:	019a9463          	bne	s5,s9,20400cb0 <encode_uint+0xc0>
20400cac:	009c6463          	bltu	s8,s1,20400cb4 <encode_uint+0xc4>
20400cb0:	06896463          	bltu	s2,s0,20400d18 <encode_uint+0x128>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
20400cb4:	000bd783          	lhu	a5,0(s7)
20400cb8:	0207f793          	andi	a5,a5,32
20400cbc:	00078c63          	beqz	a5,20400cd4 <encode_uint+0xe4>
		if (radix == 8) {
20400cc0:	00800793          	li	a5,8
20400cc4:	06f49a63          	bne	s1,a5,20400d38 <encode_uint+0x148>
			conv->altform_0 = true;
20400cc8:	002bc783          	lbu	a5,2(s7)
20400ccc:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
20400cd0:	00fb8123          	sb	a5,2(s7)
			;
		}
	}

	return bp;
}
20400cd4:	02c12083          	lw	ra,44(sp)
20400cd8:	00040513          	mv	a0,s0
20400cdc:	02812403          	lw	s0,40(sp)
20400ce0:	02412483          	lw	s1,36(sp)
20400ce4:	02012903          	lw	s2,32(sp)
20400ce8:	01c12983          	lw	s3,28(sp)
20400cec:	01812a03          	lw	s4,24(sp)
20400cf0:	01412a83          	lw	s5,20(sp)
20400cf4:	01012b03          	lw	s6,16(sp)
20400cf8:	00c12b83          	lw	s7,12(sp)
20400cfc:	00812c03          	lw	s8,8(sp)
20400d00:	00412c83          	lw	s9,4(sp)
20400d04:	03010113          	addi	sp,sp,48
20400d08:	00008067          	ret
	switch (specifier) {
20400d0c:	0f77f793          	andi	a5,a5,247
20400d10:	07000713          	li	a4,112
20400d14:	f3dff06f          	j	20400c50 <encode_uint+0x60>
		value /= radix;
20400d18:	00050c13          	mv	s8,a0
20400d1c:	00058c93          	mv	s9,a1
20400d20:	f49ff06f          	j	20400c68 <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
20400d24:	013b6663          	bltu	s6,s3,20400d30 <encode_uint+0x140>
20400d28:	03778793          	addi	a5,a5,55
20400d2c:	f5dff06f          	j	20400c88 <encode_uint+0x98>
20400d30:	05778793          	addi	a5,a5,87
20400d34:	f55ff06f          	j	20400c88 <encode_uint+0x98>
		} else if (radix == 16) {
20400d38:	01000793          	li	a5,16
20400d3c:	f8f49ce3          	bne	s1,a5,20400cd4 <encode_uint+0xe4>
			conv->altform_0c = true;
20400d40:	002bc783          	lbu	a5,2(s7)
20400d44:	0107e793          	ori	a5,a5,16
20400d48:	f89ff06f          	j	20400cd0 <encode_uint+0xe0>

20400d4c <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
20400d4c:	fe010113          	addi	sp,sp,-32
20400d50:	00812c23          	sw	s0,24(sp)
20400d54:	00912a23          	sw	s1,20(sp)
20400d58:	01212823          	sw	s2,16(sp)
20400d5c:	01312623          	sw	s3,12(sp)
20400d60:	01412423          	sw	s4,8(sp)
20400d64:	00112e23          	sw	ra,28(sp)
20400d68:	00050993          	mv	s3,a0
20400d6c:	00058a13          	mv	s4,a1
20400d70:	00060493          	mv	s1,a2
20400d74:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
20400d78:	00060413          	mv	s0,a2
20400d7c:	40940533          	sub	a0,s0,s1
20400d80:	01246863          	bltu	s0,s2,20400d90 <outs+0x44>
20400d84:	02091063          	bnez	s2,20400da4 <outs+0x58>
20400d88:	00044783          	lbu	a5,0(s0)
20400d8c:	00078c63          	beqz	a5,20400da4 <outs+0x58>
		int rc = out((int)*sp++, ctx);
20400d90:	00044503          	lbu	a0,0(s0)
20400d94:	000a0593          	mv	a1,s4
20400d98:	00140413          	addi	s0,s0,1
20400d9c:	000980e7          	jalr	s3

		if (rc < 0) {
20400da0:	fc055ee3          	bgez	a0,20400d7c <outs+0x30>
		}
		++count;
	}

	return (int)count;
}
20400da4:	01c12083          	lw	ra,28(sp)
20400da8:	01812403          	lw	s0,24(sp)
20400dac:	01412483          	lw	s1,20(sp)
20400db0:	01012903          	lw	s2,16(sp)
20400db4:	00c12983          	lw	s3,12(sp)
20400db8:	00812a03          	lw	s4,8(sp)
20400dbc:	02010113          	addi	sp,sp,32
20400dc0:	00008067          	ret

20400dc4 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
20400dc4:	f7010113          	addi	sp,sp,-144
20400dc8:	07512a23          	sw	s5,116(sp)
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
20400dcc:	20404ab7          	lui	s5,0x20404
20400dd0:	4d0a8793          	addi	a5,s5,1232 # 204044d0 <__clz_tab+0x1a8>
{
20400dd4:	07612823          	sw	s6,112(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
20400dd8:	20404b37          	lui	s6,0x20404
{
20400ddc:	07712623          	sw	s7,108(sp)
20400de0:	07812423          	sw	s8,104(sp)
		switch (conv->specifier) {
20400de4:	00f12223          	sw	a5,4(sp)
				conv->specifier = 'x';

				goto prec_int_pad0;
			}

			bps = "(nil)";
20400de8:	20404bb7          	lui	s7,0x20404
	switch ((enum length_mod_enum)conv->length_mod) {
20400dec:	528b0793          	addi	a5,s6,1320 # 20404528 <__clz_tab+0x200>
			bpe = bps + 5;
20400df0:	20404c37          	lui	s8,0x20404
{
20400df4:	09212023          	sw	s2,128(sp)
20400df8:	07312e23          	sw	s3,124(sp)
20400dfc:	07912223          	sw	s9,100(sp)
20400e00:	07a12023          	sw	s10,96(sp)
20400e04:	05b12e23          	sw	s11,92(sp)
20400e08:	08112623          	sw	ra,140(sp)
20400e0c:	08812423          	sw	s0,136(sp)
20400e10:	08912223          	sw	s1,132(sp)
20400e14:	07412c23          	sw	s4,120(sp)
20400e18:	00050913          	mv	s2,a0
20400e1c:	00058993          	mv	s3,a1
20400e20:	00060d13          	mv	s10,a2
20400e24:	00068c93          	mv	s9,a3
	size_t count = 0;
20400e28:	00000d93          	li	s11,0
	switch ((enum length_mod_enum)conv->length_mod) {
20400e2c:	00f12423          	sw	a5,8(sp)
			bps = "(nil)";
20400e30:	444b8b93          	addi	s7,s7,1092 # 20404444 <__clz_tab+0x11c>
			bpe = bps + 5;
20400e34:	449c0c13          	addi	s8,s8,1097 # 20404449 <__clz_tab+0x121>
	while (*fp != 0) {
20400e38:	000d4403          	lbu	s0,0(s10)
20400e3c:	00041663          	bnez	s0,20400e48 <cbvprintf+0x84>
			OUTC(' ');
			--width;
		}
	}

	return count;
20400e40:	000d8513          	mv	a0,s11
20400e44:	2290006f          	j	2040186c <cbvprintf+0xaa8>
		if (*fp != '%') {
20400e48:	02500793          	li	a5,37
			OUTC(*fp++);
20400e4c:	001d0a13          	addi	s4,s10,1
		if (*fp != '%') {
20400e50:	02f40463          	beq	s0,a5,20400e78 <cbvprintf+0xb4>
			OUTC(*fp++);
20400e54:	00098593          	mv	a1,s3
20400e58:	00040513          	mv	a0,s0
20400e5c:	000900e7          	jalr	s2
20400e60:	200546e3          	bltz	a0,2040186c <cbvprintf+0xaa8>
20400e64:	001d8d93          	addi	s11,s11,1
			continue;
20400e68:	000c8413          	mv	s0,s9
20400e6c:	00040c93          	mv	s9,s0
20400e70:	000a0d13          	mv	s10,s4
20400e74:	fc5ff06f          	j	20400e38 <cbvprintf+0x74>
		} state = {
20400e78:	02000613          	li	a2,32
20400e7c:	00000593          	li	a1,0
20400e80:	03010513          	addi	a0,sp,48
20400e84:	429000ef          	jal	ra,20401aac <memset>
	if (*sp == '%') {
20400e88:	001d4783          	lbu	a5,1(s10)
20400e8c:	0e879263          	bne	a5,s0,20400f70 <cbvprintf+0x1ac>
		conv->specifier = *sp++;
20400e90:	002d0a13          	addi	s4,s10,2
20400e94:	04f101a3          	sb	a5,67(sp)
		if (conv->width_star) {
20400e98:	04015783          	lhu	a5,64(sp)
20400e9c:	1007f713          	andi	a4,a5,256
20400ea0:	52070e63          	beqz	a4,204013dc <cbvprintf+0x618>
			width = va_arg(ap, int);
20400ea4:	000ca483          	lw	s1,0(s9)
20400ea8:	004c8413          	addi	s0,s9,4
			if (width < 0) {
20400eac:	0004d863          	bgez	s1,20400ebc <cbvprintf+0xf8>
				conv->flag_dash = true;
20400eb0:	0047e793          	ori	a5,a5,4
20400eb4:	04f11023          	sh	a5,64(sp)
				width = -width;
20400eb8:	409004b3          	neg	s1,s1
		if (conv->prec_star) {
20400ebc:	04015703          	lhu	a4,64(sp)
20400ec0:	40077793          	andi	a5,a4,1024
20400ec4:	52078c63          	beqz	a5,204013fc <cbvprintf+0x638>
			int arg = va_arg(ap, int);
20400ec8:	00042a83          	lw	s5,0(s0)
20400ecc:	00440413          	addi	s0,s0,4
			if (arg < 0) {
20400ed0:	000ad863          	bgez	s5,20400ee0 <cbvprintf+0x11c>
				conv->prec_present = false;
20400ed4:	dff77713          	andi	a4,a4,-513
20400ed8:	04e11023          	sh	a4,64(sp)
		int precision = -1;
20400edc:	fff00a93          	li	s5,-1
			= (enum specifier_cat_enum)conv->specifier_cat;
20400ee0:	04012583          	lw	a1,64(sp)
		conv->pad0_value = 0;
20400ee4:	04012223          	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
20400ee8:	04012423          	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
20400eec:	0105d693          	srli	a3,a1,0x10
			= (enum length_mod_enum)conv->length_mod;
20400ef0:	00b5d713          	srli	a4,a1,0xb
		enum specifier_cat_enum specifier_cat
20400ef4:	0076f693          	andi	a3,a3,7
		if (specifier_cat == SPECIFIER_SINT) {
20400ef8:	00100613          	li	a2,1
			= (enum length_mod_enum)conv->length_mod;
20400efc:	00f77713          	andi	a4,a4,15
		if (specifier_cat == SPECIFIER_SINT) {
20400f00:	56c69263          	bne	a3,a2,20401464 <cbvprintf+0x6a0>
			switch (length_mod) {
20400f04:	00500613          	li	a2,5
20400f08:	50c70e63          	beq	a4,a2,20401424 <cbvprintf+0x660>
20400f0c:	00e66a63          	bltu	a2,a4,20400f20 <cbvprintf+0x15c>
20400f10:	00300693          	li	a3,3
20400f14:	4ed70e63          	beq	a4,a3,20401410 <cbvprintf+0x64c>
20400f18:	00400693          	li	a3,4
20400f1c:	50d70463          	beq	a4,a3,20401424 <cbvprintf+0x660>
					(sint_value_type)va_arg(ap, ptrdiff_t);
20400f20:	00042683          	lw	a3,0(s0)
20400f24:	00440413          	addi	s0,s0,4
20400f28:	02d12823          	sw	a3,48(sp)
20400f2c:	41f6d693          	srai	a3,a3,0x1f
20400f30:	02d12a23          	sw	a3,52(sp)
			if (length_mod == LENGTH_HH) {
20400f34:	00100693          	li	a3,1
20400f38:	50d71863          	bne	a4,a3,20401448 <cbvprintf+0x684>
				value->uint = (unsigned char)value->uint;
20400f3c:	03014683          	lbu	a3,48(sp)
				value->uint = (unsigned short)value->uint;
20400f40:	02d12823          	sw	a3,48(sp)
20400f44:	02012a23          	sw	zero,52(sp)
		if (conv->invalid || conv->unsupported) {
20400f48:	0035f593          	andi	a1,a1,3
20400f4c:	5e058863          	beqz	a1,2040153c <cbvprintf+0x778>
			OUTS(sp, fp);
20400f50:	000a0693          	mv	a3,s4
20400f54:	000d0613          	mv	a2,s10
20400f58:	00098593          	mv	a1,s3
20400f5c:	00090513          	mv	a0,s2
20400f60:	dedff0ef          	jal	ra,20400d4c <outs>
20400f64:	100544e3          	bltz	a0,2040186c <cbvprintf+0xaa8>
20400f68:	00ad8db3          	add	s11,s11,a0
			continue;
20400f6c:	f01ff06f          	j	20400e6c <cbvprintf+0xa8>
20400f70:	00000513          	li	a0,0
20400f74:	00000693          	li	a3,0
20400f78:	00000593          	li	a1,0
20400f7c:	00000613          	li	a2,0
20400f80:	00000713          	li	a4,0
		switch (*sp) {
20400f84:	02b00813          	li	a6,43
20400f88:	02d00893          	li	a7,45
20400f8c:	03000313          	li	t1,48
20400f90:	02000e13          	li	t3,32
20400f94:	02300e93          	li	t4,35
20400f98:	000a4783          	lbu	a5,0(s4)
20400f9c:	13078863          	beq	a5,a6,204010cc <cbvprintf+0x308>
20400fa0:	10f86e63          	bltu	a6,a5,204010bc <cbvprintf+0x2f8>
20400fa4:	13c78a63          	beq	a5,t3,204010d8 <cbvprintf+0x314>
20400fa8:	13d78c63          	beq	a5,t4,204010e0 <cbvprintf+0x31c>
20400fac:	00070863          	beqz	a4,20400fbc <cbvprintf+0x1f8>
20400fb0:	04015703          	lhu	a4,64(sp)
20400fb4:	00476713          	ori	a4,a4,4
20400fb8:	04e11023          	sh	a4,64(sp)
20400fbc:	00060863          	beqz	a2,20400fcc <cbvprintf+0x208>
20400fc0:	04015703          	lhu	a4,64(sp)
20400fc4:	00876713          	ori	a4,a4,8
20400fc8:	04e11023          	sh	a4,64(sp)
20400fcc:	00058863          	beqz	a1,20400fdc <cbvprintf+0x218>
20400fd0:	04015703          	lhu	a4,64(sp)
20400fd4:	01076713          	ori	a4,a4,16
20400fd8:	04e11023          	sh	a4,64(sp)
20400fdc:	00068863          	beqz	a3,20400fec <cbvprintf+0x228>
20400fe0:	04015703          	lhu	a4,64(sp)
20400fe4:	02076713          	ori	a4,a4,32
20400fe8:	04e11023          	sh	a4,64(sp)
20400fec:	00050863          	beqz	a0,20400ffc <cbvprintf+0x238>
20400ff0:	04015703          	lhu	a4,64(sp)
20400ff4:	04076713          	ori	a4,a4,64
20400ff8:	04e11023          	sh	a4,64(sp)
	if (conv->flag_zero && conv->flag_dash) {
20400ffc:	04012703          	lw	a4,64(sp)
20401000:	04400693          	li	a3,68
20401004:	04477713          	andi	a4,a4,68
20401008:	00d71863          	bne	a4,a3,20401018 <cbvprintf+0x254>
		conv->flag_zero = false;
2040100c:	04015703          	lhu	a4,64(sp)
20401010:	fbf77713          	andi	a4,a4,-65
20401014:	04e11023          	sh	a4,64(sp)
	conv->width_present = true;
20401018:	04015703          	lhu	a4,64(sp)
2040101c:	08076693          	ori	a3,a4,128
20401020:	04d11023          	sh	a3,64(sp)
	if (*sp == '*') {
20401024:	02a00693          	li	a3,42
20401028:	10d79463          	bne	a5,a3,20401130 <cbvprintf+0x36c>
			++sp;
2040102c:	001a0793          	addi	a5,s4,1
		conv->width_star = true;
20401030:	18076713          	ori	a4,a4,384
		conv->unsupported |= ((conv->width_value < 0)
20401034:	04e11023          	sh	a4,64(sp)
	conv->prec_present = (*sp == '.');
20401038:	0007c603          	lbu	a2,0(a5)
2040103c:	fd260713          	addi	a4,a2,-46
20401040:	00173713          	seqz	a4,a4
20401044:	00971693          	slli	a3,a4,0x9
20401048:	04015703          	lhu	a4,64(sp)
2040104c:	dff77713          	andi	a4,a4,-513
20401050:	00d76733          	or	a4,a4,a3
20401054:	04e11023          	sh	a4,64(sp)
	if (!conv->prec_present) {
20401058:	02e00693          	li	a3,46
2040105c:	0ed61a63          	bne	a2,a3,20401150 <cbvprintf+0x38c>
	if (*sp == '*') {
20401060:	0017c603          	lbu	a2,1(a5)
20401064:	02a00693          	li	a3,42
20401068:	0cd60e63          	beq	a2,a3,20401144 <cbvprintf+0x380>
	++sp;
2040106c:	00178793          	addi	a5,a5,1
	size_t val = 0;
20401070:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
20401074:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
20401078:	00a00813          	li	a6,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
2040107c:	0007c683          	lbu	a3,0(a5)
20401080:	00178513          	addi	a0,a5,1
20401084:	fd068593          	addi	a1,a3,-48 # ffffd0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xff7fd0>
	while (isdigit((int)(unsigned char)*sp)) {
20401088:	16b67463          	bgeu	a2,a1,204011f0 <cbvprintf+0x42c>
	conv->unsupported |= ((conv->prec_value < 0)
2040108c:	04012683          	lw	a3,64(sp)
	conv->prec_value = prec;
20401090:	04e12423          	sw	a4,72(sp)
			      || (prec != (size_t)conv->prec_value));
20401094:	01f75713          	srli	a4,a4,0x1f
	conv->unsupported |= ((conv->prec_value < 0)
20401098:	0016d693          	srli	a3,a3,0x1
2040109c:	0016f693          	andi	a3,a3,1
204010a0:	00e6e733          	or	a4,a3,a4
204010a4:	04015683          	lhu	a3,64(sp)
204010a8:	00171713          	slli	a4,a4,0x1
204010ac:	ffd6f693          	andi	a3,a3,-3
204010b0:	00e6e733          	or	a4,a3,a4
204010b4:	04e11023          	sh	a4,64(sp)
	return sp;
204010b8:	0980006f          	j	20401150 <cbvprintf+0x38c>
		switch (*sp) {
204010bc:	03178663          	beq	a5,a7,204010e8 <cbvprintf+0x324>
204010c0:	ee6796e3          	bne	a5,t1,20400fac <cbvprintf+0x1e8>
			conv->flag_zero = true;
204010c4:	00100513          	li	a0,1
204010c8:	0080006f          	j	204010d0 <cbvprintf+0x30c>
			conv->flag_plus = true;
204010cc:	00100613          	li	a2,1
			++sp;
204010d0:	001a0a13          	addi	s4,s4,1
	} while (loop);
204010d4:	ec5ff06f          	j	20400f98 <cbvprintf+0x1d4>
			conv->flag_space = true;
204010d8:	00100593          	li	a1,1
204010dc:	ff5ff06f          	j	204010d0 <cbvprintf+0x30c>
			conv->flag_hash = true;
204010e0:	00100693          	li	a3,1
204010e4:	fedff06f          	j	204010d0 <cbvprintf+0x30c>
		switch (*sp) {
204010e8:	00100713          	li	a4,1
204010ec:	fe5ff06f          	j	204010d0 <cbvprintf+0x30c>
		val = 10U * val + *sp++ - '0';
204010f0:	03070733          	mul	a4,a4,a6
204010f4:	00050793          	mv	a5,a0
204010f8:	fd070713          	addi	a4,a4,-48
204010fc:	00d70733          	add	a4,a4,a3
20401100:	0007c683          	lbu	a3,0(a5)
20401104:	00178513          	addi	a0,a5,1
20401108:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
2040110c:	feb672e3          	bgeu	a2,a1,204010f0 <cbvprintf+0x32c>
	if (sp != wp) {
20401110:	f2fa04e3          	beq	s4,a5,20401038 <cbvprintf+0x274>
		conv->unsupported |= ((conv->width_value < 0)
20401114:	04015683          	lhu	a3,64(sp)
		conv->width_value = width;
20401118:	04e12223          	sw	a4,68(sp)
		conv->unsupported |= ((conv->width_value < 0)
2040111c:	01f75713          	srli	a4,a4,0x1f
20401120:	00171713          	slli	a4,a4,0x1
20401124:	ffd6f693          	andi	a3,a3,-3
20401128:	00e6e733          	or	a4,a3,a4
2040112c:	f09ff06f          	j	20401034 <cbvprintf+0x270>
20401130:	000a0793          	mv	a5,s4
	size_t val = 0;
20401134:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
20401138:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
2040113c:	00a00813          	li	a6,10
20401140:	fc1ff06f          	j	20401100 <cbvprintf+0x33c>
		conv->prec_star = true;
20401144:	40076713          	ori	a4,a4,1024
20401148:	04e11023          	sh	a4,64(sp)
		return ++sp;
2040114c:	00278793          	addi	a5,a5,2
	switch (*sp) {
20401150:	0007c603          	lbu	a2,0(a5)
20401154:	06c00713          	li	a4,108
		if (*++sp == 'h') {
20401158:	00178593          	addi	a1,a5,1
	switch (*sp) {
2040115c:	10e60c63          	beq	a2,a4,20401274 <cbvprintf+0x4b0>
20401160:	0ac76263          	bltu	a4,a2,20401204 <cbvprintf+0x440>
20401164:	06800713          	li	a4,104
20401168:	0ce60663          	beq	a2,a4,20401234 <cbvprintf+0x470>
2040116c:	06a00713          	li	a4,106
20401170:	12e60863          	beq	a2,a4,204012a0 <cbvprintf+0x4dc>
20401174:	04c00713          	li	a4,76
20401178:	14e60e63          	beq	a2,a4,204012d4 <cbvprintf+0x510>
2040117c:	00078593          	mv	a1,a5
	conv->specifier = *sp++;
20401180:	0005c703          	lbu	a4,0(a1)
	switch (conv->specifier) {
20401184:	07800793          	li	a5,120
	conv->specifier = *sp++;
20401188:	00158a13          	addi	s4,a1,1
2040118c:	04e101a3          	sb	a4,67(sp)
	switch (conv->specifier) {
20401190:	22e7ec63          	bltu	a5,a4,204013c8 <cbvprintf+0x604>
20401194:	05700793          	li	a5,87
20401198:	14e7ec63          	bltu	a5,a4,204012f0 <cbvprintf+0x52c>
2040119c:	04100793          	li	a5,65
204011a0:	00f70a63          	beq	a4,a5,204011b4 <cbvprintf+0x3f0>
204011a4:	fbb70713          	addi	a4,a4,-69
204011a8:	0ff77713          	andi	a4,a4,255
204011ac:	00200793          	li	a5,2
204011b0:	20e7ec63          	bltu	a5,a4,204013c8 <cbvprintf+0x604>
		conv->specifier_cat = SPECIFIER_FP;
204011b4:	04214783          	lbu	a5,66(sp)
204011b8:	ff87f793          	andi	a5,a5,-8
204011bc:	0047e793          	ori	a5,a5,4
204011c0:	04f10123          	sb	a5,66(sp)
			unsupported = true;
204011c4:	00100793          	li	a5,1
	conv->unsupported |= unsupported;
204011c8:	04012703          	lw	a4,64(sp)
204011cc:	00175713          	srli	a4,a4,0x1
204011d0:	00177713          	andi	a4,a4,1
204011d4:	00e7e7b3          	or	a5,a5,a4
204011d8:	04015703          	lhu	a4,64(sp)
204011dc:	00179793          	slli	a5,a5,0x1
204011e0:	ffd77713          	andi	a4,a4,-3
204011e4:	00f767b3          	or	a5,a4,a5
204011e8:	04f11023          	sh	a5,64(sp)
	return sp;
204011ec:	cadff06f          	j	20400e98 <cbvprintf+0xd4>
		val = 10U * val + *sp++ - '0';
204011f0:	03070733          	mul	a4,a4,a6
204011f4:	00050793          	mv	a5,a0
204011f8:	fd070713          	addi	a4,a4,-48
204011fc:	00e68733          	add	a4,a3,a4
20401200:	e7dff06f          	j	2040107c <cbvprintf+0x2b8>
	switch (*sp) {
20401204:	07400713          	li	a4,116
20401208:	0ae60a63          	beq	a2,a4,204012bc <cbvprintf+0x4f8>
2040120c:	07a00713          	li	a4,122
20401210:	f6e616e3          	bne	a2,a4,2040117c <cbvprintf+0x3b8>
		conv->length_mod = LENGTH_Z;
20401214:	04015783          	lhu	a5,64(sp)
20401218:	ffff8737          	lui	a4,0xffff8
2040121c:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
20401220:	00e7f7b3          	and	a5,a5,a4
20401224:	00003737          	lui	a4,0x3
		conv->unsupported = true;
20401228:	00e7e7b3          	or	a5,a5,a4
2040122c:	04f11023          	sh	a5,64(sp)
		break;
20401230:	f51ff06f          	j	20401180 <cbvprintf+0x3bc>
		if (*++sp == 'h') {
20401234:	04015503          	lhu	a0,64(sp)
20401238:	0017c803          	lbu	a6,1(a5)
2040123c:	ffff86b7          	lui	a3,0xffff8
20401240:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
20401244:	00a77733          	and	a4,a4,a0
		if (*++sp == 'h') {
20401248:	00c81e63          	bne	a6,a2,20401264 <cbvprintf+0x4a0>
			conv->length_mod = LENGTH_HH;
2040124c:	000016b7          	lui	a3,0x1
20401250:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
20401254:	00d76733          	or	a4,a4,a3
20401258:	04e11023          	sh	a4,64(sp)
			++sp;
2040125c:	00278593          	addi	a1,a5,2
20401260:	f21ff06f          	j	20401180 <cbvprintf+0x3bc>
			conv->length_mod = LENGTH_H;
20401264:	000017b7          	lui	a5,0x1
			conv->length_mod = LENGTH_L;
20401268:	00f76733          	or	a4,a4,a5
2040126c:	04e11023          	sh	a4,64(sp)
20401270:	f11ff06f          	j	20401180 <cbvprintf+0x3bc>
		if (*++sp == 'l') {
20401274:	04015503          	lhu	a0,64(sp)
20401278:	0017c803          	lbu	a6,1(a5) # 1001 <CONFIG_ISR_STACK_SIZE+0x801>
2040127c:	ffff86b7          	lui	a3,0xffff8
20401280:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
20401284:	00a77733          	and	a4,a4,a0
		if (*++sp == 'l') {
20401288:	00c81663          	bne	a6,a2,20401294 <cbvprintf+0x4d0>
			conv->length_mod = LENGTH_LL;
2040128c:	000026b7          	lui	a3,0x2
20401290:	fc5ff06f          	j	20401254 <cbvprintf+0x490>
			conv->length_mod = LENGTH_L;
20401294:	000027b7          	lui	a5,0x2
20401298:	80078793          	addi	a5,a5,-2048 # 1800 <__kernel_ram_size+0x7c0>
2040129c:	fcdff06f          	j	20401268 <cbvprintf+0x4a4>
		conv->length_mod = LENGTH_J;
204012a0:	04015783          	lhu	a5,64(sp)
204012a4:	ffff8737          	lui	a4,0xffff8
204012a8:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
204012ac:	00e7f7b3          	and	a5,a5,a4
204012b0:	00003737          	lui	a4,0x3
		conv->length_mod = LENGTH_T;
204012b4:	80070713          	addi	a4,a4,-2048 # 2800 <__kernel_ram_size+0x17c0>
204012b8:	f71ff06f          	j	20401228 <cbvprintf+0x464>
204012bc:	04015783          	lhu	a5,64(sp)
204012c0:	ffff8737          	lui	a4,0xffff8
204012c4:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
204012c8:	00e7f7b3          	and	a5,a5,a4
204012cc:	00004737          	lui	a4,0x4
204012d0:	fe5ff06f          	j	204012b4 <cbvprintf+0x4f0>
		conv->unsupported = true;
204012d4:	04015783          	lhu	a5,64(sp)
204012d8:	ffff8737          	lui	a4,0xffff8
204012dc:	7fd70713          	addi	a4,a4,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
204012e0:	00e7f7b3          	and	a5,a5,a4
204012e4:	00004737          	lui	a4,0x4
204012e8:	00270713          	addi	a4,a4,2 # 4002 <__kernel_ram_size+0x2fc2>
204012ec:	f3dff06f          	j	20401228 <cbvprintf+0x464>
	switch (conv->specifier) {
204012f0:	fa870793          	addi	a5,a4,-88
204012f4:	0ff7f793          	andi	a5,a5,255
204012f8:	02000693          	li	a3,32
204012fc:	0cf6e663          	bltu	a3,a5,204013c8 <cbvprintf+0x604>
20401300:	204046b7          	lui	a3,0x20404
20401304:	00279793          	slli	a5,a5,0x2
20401308:	44c68693          	addi	a3,a3,1100 # 2040444c <__clz_tab+0x124>
2040130c:	00d787b3          	add	a5,a5,a3
20401310:	0007a783          	lw	a5,0(a5)
20401314:	00078067          	jr	a5
		conv->specifier_cat = SPECIFIER_SINT;
20401318:	04214783          	lbu	a5,66(sp)
2040131c:	ff87f793          	andi	a5,a5,-8
20401320:	0017e793          	ori	a5,a5,1
		if (conv->length_mod == LENGTH_UPPER_L) {
20401324:	04015683          	lhu	a3,64(sp)
		conv->specifier_cat = SPECIFIER_UINT;
20401328:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
2040132c:	000087b7          	lui	a5,0x8
20401330:	80078793          	addi	a5,a5,-2048 # 7800 <__rom_region_size+0x3108>
20401334:	00f6f7b3          	and	a5,a3,a5
20401338:	01079793          	slli	a5,a5,0x10
2040133c:	0107d793          	srli	a5,a5,0x10
20401340:	00004637          	lui	a2,0x4
20401344:	00c79663          	bne	a5,a2,20401350 <cbvprintf+0x58c>
			conv->invalid = true;
20401348:	0016e693          	ori	a3,a3,1
2040134c:	04d11023          	sh	a3,64(sp)
		if (conv->specifier == 'c') {
20401350:	06300693          	li	a3,99
	bool unsupported = false;
20401354:	00000793          	li	a5,0
		if (conv->specifier == 'c') {
20401358:	e6d718e3          	bne	a4,a3,204011c8 <cbvprintf+0x404>
		if (conv->length_mod != LENGTH_NONE) {
2040135c:	04015703          	lhu	a4,64(sp)
20401360:	000087b7          	lui	a5,0x8
20401364:	80078793          	addi	a5,a5,-2048 # 7800 <__rom_region_size+0x3108>
20401368:	00e7f7b3          	and	a5,a5,a4
2040136c:	00f037b3          	snez	a5,a5
20401370:	e59ff06f          	j	204011c8 <cbvprintf+0x404>
		conv->specifier_cat = SPECIFIER_UINT;
20401374:	04214783          	lbu	a5,66(sp)
20401378:	ff87f793          	andi	a5,a5,-8
2040137c:	0027e793          	ori	a5,a5,2
20401380:	fa5ff06f          	j	20401324 <cbvprintf+0x560>
		conv->specifier_cat = SPECIFIER_PTR;
20401384:	04214783          	lbu	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
20401388:	04015703          	lhu	a4,64(sp)
		conv->specifier_cat = SPECIFIER_PTR;
2040138c:	ff87f793          	andi	a5,a5,-8
20401390:	0037e793          	ori	a5,a5,3
20401394:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
20401398:	000087b7          	lui	a5,0x8
2040139c:	80078793          	addi	a5,a5,-2048 # 7800 <__rom_region_size+0x3108>
204013a0:	00e7f7b3          	and	a5,a5,a4
204013a4:	ffffc737          	lui	a4,0xffffc
204013a8:	00e787b3          	add	a5,a5,a4
204013ac:	0017b793          	seqz	a5,a5
204013b0:	e19ff06f          	j	204011c8 <cbvprintf+0x404>
		conv->specifier_cat = SPECIFIER_PTR;
204013b4:	04214783          	lbu	a5,66(sp)
204013b8:	ff87f793          	andi	a5,a5,-8
204013bc:	0037e793          	ori	a5,a5,3
204013c0:	04f10123          	sb	a5,66(sp)
204013c4:	f99ff06f          	j	2040135c <cbvprintf+0x598>
		conv->invalid = true;
204013c8:	04015783          	lhu	a5,64(sp)
204013cc:	0017e793          	ori	a5,a5,1
204013d0:	04f11023          	sh	a5,64(sp)
	bool unsupported = false;
204013d4:	00000793          	li	a5,0
		break;
204013d8:	df1ff06f          	j	204011c8 <cbvprintf+0x404>
		} else if (conv->width_present) {
204013dc:	0807f793          	andi	a5,a5,128
204013e0:	00078863          	beqz	a5,204013f0 <cbvprintf+0x62c>
			width = conv->width_value;
204013e4:	04412483          	lw	s1,68(sp)
204013e8:	000c8413          	mv	s0,s9
204013ec:	ad1ff06f          	j	20400ebc <cbvprintf+0xf8>
204013f0:	000c8413          	mv	s0,s9
		int width = -1;
204013f4:	fff00493          	li	s1,-1
204013f8:	ac5ff06f          	j	20400ebc <cbvprintf+0xf8>
		} else if (conv->prec_present) {
204013fc:	20077713          	andi	a4,a4,512
		int precision = -1;
20401400:	fff00a93          	li	s5,-1
		} else if (conv->prec_present) {
20401404:	ac070ee3          	beqz	a4,20400ee0 <cbvprintf+0x11c>
			precision = conv->prec_value;
20401408:	04812a83          	lw	s5,72(sp)
2040140c:	ad5ff06f          	j	20400ee0 <cbvprintf+0x11c>
					value->sint = va_arg(ap, long);
20401410:	00440513          	addi	a0,s0,4
					value->uint = (wchar_t)va_arg(ap,
20401414:	00042683          	lw	a3,0(s0)
20401418:	02d12823          	sw	a3,48(sp)
2040141c:	41f6d693          	srai	a3,a3,0x1f
20401420:	01c0006f          	j	2040143c <cbvprintf+0x678>
					(sint_value_type)va_arg(ap, long long);
20401424:	00740413          	addi	s0,s0,7
20401428:	ff847413          	andi	s0,s0,-8
				value->sint =
2040142c:	00042603          	lw	a2,0(s0)
20401430:	00442683          	lw	a3,4(s0)
					(sint_value_type)va_arg(ap, long long);
20401434:	00840513          	addi	a0,s0,8
				value->sint =
20401438:	02c12823          	sw	a2,48(sp)
2040143c:	02d12a23          	sw	a3,52(sp)
					(uint_value_type)va_arg(ap, size_t);
20401440:	00050413          	mv	s0,a0
20401444:	b05ff06f          	j	20400f48 <cbvprintf+0x184>
			} else if (length_mod == LENGTH_H) {
20401448:	00200693          	li	a3,2
2040144c:	aed71ee3          	bne	a4,a3,20400f48 <cbvprintf+0x184>
				value->sint = (short)value->sint;
20401450:	03011683          	lh	a3,48(sp)
20401454:	02d12823          	sw	a3,48(sp)
20401458:	41f6d693          	srai	a3,a3,0x1f
				value->dbl = va_arg(ap, double);
2040145c:	02d12a23          	sw	a3,52(sp)
20401460:	ae9ff06f          	j	20400f48 <cbvprintf+0x184>
		} else if (specifier_cat == SPECIFIER_UINT) {
20401464:	00200513          	li	a0,2
20401468:	06a69463          	bne	a3,a0,204014d0 <cbvprintf+0x70c>
			switch (length_mod) {
2040146c:	00500693          	li	a3,5
20401470:	fad70ae3          	beq	a4,a3,20401424 <cbvprintf+0x660>
20401474:	00e6ea63          	bltu	a3,a4,20401488 <cbvprintf+0x6c4>
20401478:	00300693          	li	a3,3
2040147c:	02d70a63          	beq	a4,a3,204014b0 <cbvprintf+0x6ec>
20401480:	00400693          	li	a3,4
20401484:	fad700e3          	beq	a4,a3,20401424 <cbvprintf+0x660>
					(uint_value_type)va_arg(ap, size_t);
20401488:	00042683          	lw	a3,0(s0)
2040148c:	02012a23          	sw	zero,52(sp)
20401490:	00440413          	addi	s0,s0,4
20401494:	02d12823          	sw	a3,48(sp)
			if (length_mod == LENGTH_HH) {
20401498:	00100693          	li	a3,1
2040149c:	aad700e3          	beq	a4,a3,20400f3c <cbvprintf+0x178>
			} else if (length_mod == LENGTH_H) {
204014a0:	00200693          	li	a3,2
204014a4:	aad712e3          	bne	a4,a3,20400f48 <cbvprintf+0x184>
				value->uint = (unsigned short)value->uint;
204014a8:	03015683          	lhu	a3,48(sp)
204014ac:	a95ff06f          	j	20400f40 <cbvprintf+0x17c>
				if ((!WCHAR_IS_SIGNED)
204014b0:	04314603          	lbu	a2,67(sp)
204014b4:	06300693          	li	a3,99
				value->sint = va_arg(ap, int);
204014b8:	00440513          	addi	a0,s0,4
				if ((!WCHAR_IS_SIGNED)
204014bc:	f4d60ce3          	beq	a2,a3,20401414 <cbvprintf+0x650>
					value->uint = va_arg(ap, unsigned long);
204014c0:	00042683          	lw	a3,0(s0)
204014c4:	02012a23          	sw	zero,52(sp)
204014c8:	02d12823          	sw	a3,48(sp)
204014cc:	f75ff06f          	j	20401440 <cbvprintf+0x67c>
		} else if (specifier_cat == SPECIFIER_FP) {
204014d0:	00400613          	li	a2,4
204014d4:	04c69a63          	bne	a3,a2,20401528 <cbvprintf+0x764>
			if (length_mod == LENGTH_UPPER_L) {
204014d8:	00800693          	li	a3,8
204014dc:	02d71863          	bne	a4,a3,2040150c <cbvprintf+0x748>
				value->ldbl = va_arg(ap, long double);
204014e0:	00042683          	lw	a3,0(s0)
204014e4:	0006a803          	lw	a6,0(a3)
204014e8:	0046a503          	lw	a0,4(a3)
204014ec:	0086a603          	lw	a2,8(a3)
204014f0:	00c6a683          	lw	a3,12(a3)
204014f4:	03012823          	sw	a6,48(sp)
204014f8:	02a12a23          	sw	a0,52(sp)
204014fc:	02c12c23          	sw	a2,56(sp)
20401500:	02d12e23          	sw	a3,60(sp)
			value->ptr = va_arg(ap, void *);
20401504:	00440413          	addi	s0,s0,4
20401508:	a41ff06f          	j	20400f48 <cbvprintf+0x184>
				value->dbl = va_arg(ap, double);
2040150c:	00740693          	addi	a3,s0,7
20401510:	ff86f693          	andi	a3,a3,-8
20401514:	0006a603          	lw	a2,0(a3)
20401518:	00868413          	addi	s0,a3,8
2040151c:	0046a683          	lw	a3,4(a3)
20401520:	02c12823          	sw	a2,48(sp)
20401524:	f39ff06f          	j	2040145c <cbvprintf+0x698>
		} else if (specifier_cat == SPECIFIER_PTR) {
20401528:	00300613          	li	a2,3
2040152c:	a0c69ee3          	bne	a3,a2,20400f48 <cbvprintf+0x184>
			value->ptr = va_arg(ap, void *);
20401530:	00042683          	lw	a3,0(s0)
20401534:	02d12823          	sw	a3,48(sp)
20401538:	fcdff06f          	j	20401504 <cbvprintf+0x740>
		switch (conv->specifier) {
2040153c:	04314683          	lbu	a3,67(sp)
20401540:	07800613          	li	a2,120
20401544:	92d664e3          	bltu	a2,a3,20400e6c <cbvprintf+0xa8>
20401548:	06200613          	li	a2,98
2040154c:	00d66e63          	bltu	a2,a3,20401568 <cbvprintf+0x7a4>
20401550:	02500713          	li	a4,37
20401554:	02e68c63          	beq	a3,a4,2040158c <cbvprintf+0x7c8>
20401558:	05800713          	li	a4,88
2040155c:	90e698e3          	bne	a3,a4,20400e6c <cbvprintf+0xa8>
20401560:	00000b13          	li	s6,0
20401564:	2080006f          	j	2040176c <cbvprintf+0x9a8>
20401568:	f9d68693          	addi	a3,a3,-99
2040156c:	0ff6f693          	andi	a3,a3,255
20401570:	01500613          	li	a2,21
20401574:	8ed66ce3          	bltu	a2,a3,20400e6c <cbvprintf+0xa8>
20401578:	00412783          	lw	a5,4(sp)
2040157c:	00269693          	slli	a3,a3,0x2
20401580:	00f686b3          	add	a3,a3,a5
20401584:	0006a683          	lw	a3,0(a3)
20401588:	00068067          	jr	a3
			OUTC('%');
2040158c:	00098593          	mv	a1,s3
20401590:	02500513          	li	a0,37
20401594:	000900e7          	jalr	s2
20401598:	2c054a63          	bltz	a0,2040186c <cbvprintf+0xaa8>
2040159c:	001d8d93          	addi	s11,s11,1
			break;
204015a0:	8cdff06f          	j	20400e6c <cbvprintf+0xa8>
			bps = (const char *)value->ptr;
204015a4:	03012c83          	lw	s9,48(sp)
			if (precision >= 0) {
204015a8:	160ac063          	bltz	s5,20401708 <cbvprintf+0x944>
				len = strnlen(bps, precision);
204015ac:	000a8593          	mv	a1,s5
204015b0:	000c8513          	mv	a0,s9
204015b4:	4b0000ef          	jal	ra,20401a64 <strnlen>
			bpe = bps + len;
204015b8:	00ac8d33          	add	s10,s9,a0
		char sign = 0;
204015bc:	00000b13          	li	s6,0
		if (bps == NULL) {
204015c0:	8a0c86e3          	beqz	s9,20400e6c <cbvprintf+0xa8>
		size_t nj_len = (bpe - bps);
204015c4:	419d07b3          	sub	a5,s10,s9
		if (sign != 0) {
204015c8:	000b0463          	beqz	s6,204015d0 <cbvprintf+0x80c>
			nj_len += 1U;
204015cc:	00178793          	addi	a5,a5,1
		if (conv->altform_0c) {
204015d0:	04214703          	lbu	a4,66(sp)
204015d4:	01077693          	andi	a3,a4,16
204015d8:	26068663          	beqz	a3,20401844 <cbvprintf+0xa80>
			nj_len += 2U;
204015dc:	00278793          	addi	a5,a5,2
		nj_len += conv->pad0_value;
204015e0:	04412683          	lw	a3,68(sp)
		if (conv->pad_fp) {
204015e4:	04077713          	andi	a4,a4,64
		nj_len += conv->pad0_value;
204015e8:	00d787b3          	add	a5,a5,a3
		if (conv->pad_fp) {
204015ec:	00070663          	beqz	a4,204015f8 <cbvprintf+0x834>
			nj_len += conv->pad0_pre_exp;
204015f0:	04812703          	lw	a4,72(sp)
204015f4:	00e787b3          	add	a5,a5,a4
		if (width > 0) {
204015f8:	04905c63          	blez	s1,20401650 <cbvprintf+0x88c>
			width -= (int)nj_len;
204015fc:	40f484b3          	sub	s1,s1,a5
			if (!conv->flag_dash) {
20401600:	04012783          	lw	a5,64(sp)
20401604:	0027d793          	srli	a5,a5,0x2
20401608:	0017f793          	andi	a5,a5,1
2040160c:	04079263          	bnez	a5,20401650 <cbvprintf+0x88c>
				if (conv->flag_zero) {
20401610:	04015783          	lhu	a5,64(sp)
20401614:	0407f793          	andi	a5,a5,64
20401618:	28078863          	beqz	a5,204018a8 <cbvprintf+0xae4>
					if (sign != 0) {
2040161c:	280b0a63          	beqz	s6,204018b0 <cbvprintf+0xaec>
						OUTC(sign);
20401620:	00098593          	mv	a1,s3
20401624:	000b0513          	mv	a0,s6
20401628:	000900e7          	jalr	s2
2040162c:	24054063          	bltz	a0,2040186c <cbvprintf+0xaa8>
20401630:	001d8d93          	addi	s11,s11,1
					pad = '0';
20401634:	03000793          	li	a5,48
						sign = 0;
20401638:	00000b13          	li	s6,0
2040163c:	01b48ab3          	add	s5,s1,s11
20401640:	00048713          	mv	a4,s1
20401644:	409a8db3          	sub	s11,s5,s1
				while (width-- > 0) {
20401648:	fff48493          	addi	s1,s1,-1
2040164c:	20e04463          	bgtz	a4,20401854 <cbvprintf+0xa90>
		if (sign != 0) {
20401650:	000b0c63          	beqz	s6,20401668 <cbvprintf+0x8a4>
			OUTC(sign);
20401654:	00098593          	mv	a1,s3
20401658:	000b0513          	mv	a0,s6
2040165c:	000900e7          	jalr	s2
20401660:	20054663          	bltz	a0,2040186c <cbvprintf+0xaa8>
20401664:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c | conv->altform_0) {
20401668:	04012783          	lw	a5,64(sp)
2040166c:	0147d713          	srli	a4,a5,0x14
20401670:	00177713          	andi	a4,a4,1
20401674:	00071863          	bnez	a4,20401684 <cbvprintf+0x8c0>
20401678:	0137d793          	srli	a5,a5,0x13
2040167c:	0017f793          	andi	a5,a5,1
20401680:	00078c63          	beqz	a5,20401698 <cbvprintf+0x8d4>
				OUTC('0');
20401684:	00098593          	mv	a1,s3
20401688:	03000513          	li	a0,48
2040168c:	000900e7          	jalr	s2
20401690:	1c054e63          	bltz	a0,2040186c <cbvprintf+0xaa8>
20401694:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c) {
20401698:	04214783          	lbu	a5,66(sp)
2040169c:	0107f793          	andi	a5,a5,16
204016a0:	00078c63          	beqz	a5,204016b8 <cbvprintf+0x8f4>
				OUTC(conv->specifier);
204016a4:	04314503          	lbu	a0,67(sp)
204016a8:	00098593          	mv	a1,s3
204016ac:	000900e7          	jalr	s2
204016b0:	1a054e63          	bltz	a0,2040186c <cbvprintf+0xaa8>
204016b4:	001d8d93          	addi	s11,s11,1
			while (pad_len-- > 0) {
204016b8:	04412783          	lw	a5,68(sp)
204016bc:	01b78ab3          	add	s5,a5,s11
204016c0:	41ba8733          	sub	a4,s5,s11
204016c4:	1ee04a63          	bgtz	a4,204018b8 <cbvprintf+0xaf4>
			OUTS(bps, bpe);
204016c8:	000d0693          	mv	a3,s10
204016cc:	000c8613          	mv	a2,s9
204016d0:	00098593          	mv	a1,s3
204016d4:	00090513          	mv	a0,s2
204016d8:	e74ff0ef          	jal	ra,20400d4c <outs>
204016dc:	18054863          	bltz	a0,2040186c <cbvprintf+0xaa8>
204016e0:	01b50db3          	add	s11,a0,s11
		while (width > 0) {
204016e4:	01b484b3          	add	s1,s1,s11
204016e8:	41b487b3          	sub	a5,s1,s11
204016ec:	f8f05063          	blez	a5,20400e6c <cbvprintf+0xa8>
			OUTC(' ');
204016f0:	00098593          	mv	a1,s3
204016f4:	02000513          	li	a0,32
204016f8:	000900e7          	jalr	s2
204016fc:	16054863          	bltz	a0,2040186c <cbvprintf+0xaa8>
20401700:	001d8d93          	addi	s11,s11,1
			--width;
20401704:	fe5ff06f          	j	204016e8 <cbvprintf+0x924>
				len = strlen(bps);
20401708:	000c8513          	mv	a0,s9
2040170c:	338000ef          	jal	ra,20401a44 <strlen>
20401710:	ea9ff06f          	j	204015b8 <cbvprintf+0x7f4>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
20401714:	03012783          	lw	a5,48(sp)
			bps = buf;
20401718:	01810c93          	addi	s9,sp,24
			bpe = buf + 1;
2040171c:	01910d13          	addi	s10,sp,25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
20401720:	00f10c23          	sb	a5,24(sp)
			break;
20401724:	00000b13          	li	s6,0
20401728:	e9dff06f          	j	204015c4 <cbvprintf+0x800>
			if (conv->flag_plus) {
2040172c:	04015703          	lhu	a4,64(sp)
				sign = '+';
20401730:	02b00b13          	li	s6,43
			if (conv->flag_plus) {
20401734:	00877693          	andi	a3,a4,8
20401738:	00069663          	bnez	a3,20401744 <cbvprintf+0x980>
				sign = ' ';
2040173c:	00171b13          	slli	s6,a4,0x1
20401740:	020b7b13          	andi	s6,s6,32
			sint = value->sint;
20401744:	03412703          	lw	a4,52(sp)
20401748:	03012683          	lw	a3,48(sp)
			if (sint < 0) {
2040174c:	02075063          	bgez	a4,2040176c <cbvprintf+0x9a8>
				value->uint = (uint_value_type)-sint;
20401750:	40d00633          	neg	a2,a3
20401754:	40e00733          	neg	a4,a4
20401758:	00d036b3          	snez	a3,a3
2040175c:	40d70733          	sub	a4,a4,a3
20401760:	02c12823          	sw	a2,48(sp)
20401764:	02e12a23          	sw	a4,52(sp)
				sign = '-';
20401768:	02d00b13          	li	s6,45
			bps = encode_uint(value->uint, conv, buf, bpe);
2040176c:	03012503          	lw	a0,48(sp)
20401770:	03412583          	lw	a1,52(sp)
20401774:	02e10713          	addi	a4,sp,46
20401778:	01810693          	addi	a3,sp,24
2040177c:	04010613          	addi	a2,sp,64
20401780:	c70ff0ef          	jal	ra,20400bf0 <encode_uint>
20401784:	00050c93          	mv	s9,a0
			if (precision >= 0) {
20401788:	02e10d13          	addi	s10,sp,46
2040178c:	e20acae3          	bltz	s5,204015c0 <cbvprintf+0x7fc>
				conv->flag_zero = false;
20401790:	04015683          	lhu	a3,64(sp)
				size_t len = bpe - bps;
20401794:	419d0733          	sub	a4,s10,s9
				conv->flag_zero = false;
20401798:	fbf6f693          	andi	a3,a3,-65
2040179c:	04d11023          	sh	a3,64(sp)
				if (len < (size_t)precision) {
204017a0:	e35770e3          	bgeu	a4,s5,204015c0 <cbvprintf+0x7fc>
					conv->pad0_value = precision - (int)len;
204017a4:	40ea87b3          	sub	a5,s5,a4
204017a8:	04f12223          	sw	a5,68(sp)
204017ac:	e15ff06f          	j	204015c0 <cbvprintf+0x7fc>
			if (value->ptr != NULL) {
204017b0:	03012503          	lw	a0,48(sp)
204017b4:	08050263          	beqz	a0,20401838 <cbvprintf+0xa74>
				bps = encode_uint((uintptr_t)value->ptr, conv,
204017b8:	02e10713          	addi	a4,sp,46
204017bc:	01810693          	addi	a3,sp,24
204017c0:	04010613          	addi	a2,sp,64
204017c4:	00000593          	li	a1,0
204017c8:	c28ff0ef          	jal	ra,20400bf0 <encode_uint>
				conv->altform_0c = true;
204017cc:	04215703          	lhu	a4,66(sp)
204017d0:	000086b7          	lui	a3,0x8
204017d4:	81068693          	addi	a3,a3,-2032 # 7810 <__rom_region_size+0x3118>
204017d8:	0ef77713          	andi	a4,a4,239
204017dc:	00d76733          	or	a4,a4,a3
				bps = encode_uint((uintptr_t)value->ptr, conv,
204017e0:	00050c93          	mv	s9,a0
				conv->altform_0c = true;
204017e4:	04e11123          	sh	a4,66(sp)
		char sign = 0;
204017e8:	00000b13          	li	s6,0
				goto prec_int_pad0;
204017ec:	f9dff06f          	j	20401788 <cbvprintf+0x9c4>
	switch ((enum length_mod_enum)conv->length_mod) {
204017f0:	00700693          	li	a3,7
				store_count(conv, value->ptr, count);
204017f4:	03012783          	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
204017f8:	e6e6ea63          	bltu	a3,a4,20400e6c <cbvprintf+0xa8>
204017fc:	00812683          	lw	a3,8(sp)
20401800:	00271713          	slli	a4,a4,0x2
20401804:	00d70733          	add	a4,a4,a3
20401808:	00072703          	lw	a4,0(a4) # ffffc000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffffc001>
2040180c:	00070067          	jr	a4
		*(signed char *)dp = (signed char)count;
20401810:	01b78023          	sb	s11,0(a5)
		break;
20401814:	e58ff06f          	j	20400e6c <cbvprintf+0xa8>
		*(short *)dp = (short)count;
20401818:	01b79023          	sh	s11,0(a5)
		break;
2040181c:	e50ff06f          	j	20400e6c <cbvprintf+0xa8>
		*(intmax_t *)dp = (intmax_t)count;
20401820:	41fdd713          	srai	a4,s11,0x1f
20401824:	01b7a023          	sw	s11,0(a5)
20401828:	00e7a223          	sw	a4,4(a5)
		break;
2040182c:	e40ff06f          	j	20400e6c <cbvprintf+0xa8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
20401830:	01b7a023          	sw	s11,0(a5)
		break;
20401834:	e38ff06f          	j	20400e6c <cbvprintf+0xa8>
			bps = "(nil)";
20401838:	000b8c93          	mv	s9,s7
			bpe = bps + 5;
2040183c:	000c0d13          	mv	s10,s8
20401840:	ee5ff06f          	j	20401724 <cbvprintf+0x960>
		} else if (conv->altform_0) {
20401844:	00877693          	andi	a3,a4,8
20401848:	d8068ce3          	beqz	a3,204015e0 <cbvprintf+0x81c>
			nj_len += 1U;
2040184c:	00178793          	addi	a5,a5,1
20401850:	d91ff06f          	j	204015e0 <cbvprintf+0x81c>
					OUTC(pad);
20401854:	00078513          	mv	a0,a5
20401858:	00098593          	mv	a1,s3
2040185c:	00f12623          	sw	a5,12(sp)
20401860:	000900e7          	jalr	s2
20401864:	00c12783          	lw	a5,12(sp)
20401868:	dc055ce3          	bgez	a0,20401640 <cbvprintf+0x87c>
#undef OUTS
#undef OUTC
}
2040186c:	08c12083          	lw	ra,140(sp)
20401870:	08812403          	lw	s0,136(sp)
20401874:	08412483          	lw	s1,132(sp)
20401878:	08012903          	lw	s2,128(sp)
2040187c:	07c12983          	lw	s3,124(sp)
20401880:	07812a03          	lw	s4,120(sp)
20401884:	07412a83          	lw	s5,116(sp)
20401888:	07012b03          	lw	s6,112(sp)
2040188c:	06c12b83          	lw	s7,108(sp)
20401890:	06812c03          	lw	s8,104(sp)
20401894:	06412c83          	lw	s9,100(sp)
20401898:	06012d03          	lw	s10,96(sp)
2040189c:	05c12d83          	lw	s11,92(sp)
204018a0:	09010113          	addi	sp,sp,144
204018a4:	00008067          	ret
				char pad = ' ';
204018a8:	02000793          	li	a5,32
204018ac:	d91ff06f          	j	2040163c <cbvprintf+0x878>
					pad = '0';
204018b0:	03000793          	li	a5,48
204018b4:	d89ff06f          	j	2040163c <cbvprintf+0x878>
				OUTC('0');
204018b8:	00098593          	mv	a1,s3
204018bc:	03000513          	li	a0,48
204018c0:	000900e7          	jalr	s2
204018c4:	fa0544e3          	bltz	a0,2040186c <cbvprintf+0xaa8>
204018c8:	001d8d93          	addi	s11,s11,1
204018cc:	df5ff06f          	j	204016c0 <cbvprintf+0x8fc>

204018d0 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
204018d0:	00008067          	ret

204018d4 <arch_cpu_idle>:
 * '_pm_save_flag' variable is non-zero.
 *
 * @return N/A
 */
void arch_cpu_idle(void)
{
204018d4:	ff010113          	addi	sp,sp,-16
204018d8:	00112623          	sw	ra,12(sp)
	sys_trace_idle();
204018dc:	090000ef          	jal	ra,2040196c <sys_trace_idle>
 */
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	ulong_t mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
204018e0:	00800793          	li	a5,8
204018e4:	3007a7f3          	csrrs	a5,mstatus,a5
	__asm__ volatile("wfi");
204018e8:	10500073          	wfi
	riscv_idle(MSTATUS_IEN);
}
204018ec:	00c12083          	lw	ra,12(sp)
204018f0:	01010113          	addi	sp,sp,16
204018f4:	00008067          	ret

204018f8 <arch_irq_enable>:
{
#if defined(CONFIG_3RD_LEVEL_INTERRUPTS)
	return ((irq >> 16) & 0xFF) != 0 ? 3 :
		(((irq >> 8) & 0xFF) == 0 ? 1 : 2);
#elif defined(CONFIG_2ND_LEVEL_INTERRUPTS)
	return ((irq >> 8) & 0xFF) == 0 ? 1 : 2;
204018f8:	00855793          	srli	a5,a0,0x8
204018fc:	0ff7f713          	andi	a4,a5,255
20401900:	00071a63          	bnez	a4,20401914 <arch_irq_enable+0x1c>
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
20401904:	00100793          	li	a5,1
20401908:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
2040190c:	30452573          	csrrs	a0,mie,a0
}
20401910:	00008067          	ret
		riscv_plic_irq_enable(irq);
20401914:	fff78513          	addi	a0,a5,-1
20401918:	2900006f          	j	20401ba8 <riscv_plic_irq_enable>

2040191c <arch_irq_disable>:
2040191c:	00855793          	srli	a5,a0,0x8
20401920:	0ff7f713          	andi	a4,a5,255
20401924:	00071a63          	bnez	a4,20401938 <arch_irq_disable+0x1c>
	 * Use atomic instruction csrrc to disable device interrupt in mie CSR.
	 * (atomic read and clear bits in CSR register)
	 */
	__asm__ volatile ("csrrc %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
20401928:	00100793          	li	a5,1
2040192c:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrc %0, mie, %1\n"
20401930:	30453573          	csrrc	a0,mie,a0
};
20401934:	00008067          	ret
		riscv_plic_irq_disable(irq);
20401938:	fff78513          	addi	a0,a5,-1
2040193c:	2a40006f          	j	20401be0 <riscv_plic_irq_disable>

20401940 <arch_irq_priority_set>:
20401940:	00855513          	srli	a0,a0,0x8
20401944:	0ff57793          	andi	a5,a0,255
20401948:	00078663          	beqz	a5,20401954 <arch_irq_priority_set+0x14>
#if defined(CONFIG_RISCV_HAS_PLIC)
	unsigned int level = irq_get_level(irq);

	if (level == 2) {
		irq = irq_from_level_2(irq);
		riscv_plic_set_priority(irq, prio);
2040194c:	fff50513          	addi	a0,a0,-1
20401950:	2cc0006f          	j	20401c1c <riscv_plic_set_priority>
#if defined(CONFIG_NUCLEI_ECLIC)
	nuclei_eclic_set_priority(irq, prio);
#endif

	return ;
}
20401954:	00008067          	ret

20401958 <soc_interrupt_init>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20401958:	00800793          	li	a5,8
2040195c:	3007b7f3          	csrrc	a5,mstatus,a5
__weak void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
20401960:	30405073          	csrwi	mie,0
20401964:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
20401968:	00008067          	ret

2040196c <sys_trace_idle>:
2040196c:	00008067          	ret

20401970 <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
20401970:	ff010113          	addi	sp,sp,-16
20401974:	00112623          	sw	ra,12(sp)
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
		LOG_ERR("");
	}

	z_fatal_error(reason, esf);
20401978:	47c010ef          	jal	ra,20402df4 <z_fatal_error>

2040197c <_Fault>:
		return "unknown";
	}
}

void _Fault(z_arch_esf_t *esf)
{
2040197c:	ff010113          	addi	sp,sp,-16
20401980:	00112623          	sw	ra,12(sp)
20401984:	00050593          	mv	a1,a0
		}
	}
#endif /* CONFIG_USERSPACE */
	ulong_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
20401988:	342027f3          	csrr	a5,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	ulong_t mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
2040198c:	343027f3          	csrr	a5,mtval
#endif

	unsigned int reason = K_ERR_CPU_EXCEPTION;

#if !defined(CONFIG_USERSPACE)
	if (esf->t5 == ARCH_EXCEPT_MARKER) {
20401990:	01c52703          	lw	a4,28(a0)
20401994:	00deb7b7          	lui	a5,0xdeb
20401998:	d0078793          	addi	a5,a5,-768 # dead00 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xde2d00>
2040199c:	00000513          	li	a0,0
204019a0:	00f71463          	bne	a4,a5,204019a8 <_Fault+0x2c>
		reason = esf->t6;
204019a4:	0205a503          	lw	a0,32(a1)
	z_fatal_error(reason, esf);
204019a8:	44c010ef          	jal	ra,20402df4 <z_fatal_error>

204019ac <z_irq_spurious>:
#include <kernel_internal.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
204019ac:	ff010113          	addi	sp,sp,-16
204019b0:	00112623          	sw	ra,12(sp)
	ulong_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
204019b4:	342027f3          	csrr	a5,mcause
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
204019b8:	00000593          	li	a1,0
204019bc:	00100513          	li	a0,1
204019c0:	fb1ff0ef          	jal	ra,20401970 <z_riscv_fatal_error>

204019c4 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
204019c4:	ff010113          	addi	sp,sp,-16
204019c8:	00112623          	sw	ra,12(sp)
	z_bss_zero();
204019cc:	55c010ef          	jal	ra,20402f28 <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
204019d0:	180020ef          	jal	ra,20403b50 <z_data_copy>
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
204019d4:	f85ff0ef          	jal	ra,20401958 <soc_interrupt_init>
#endif
#ifdef CONFIG_PMP_STACK_GUARD
	z_riscv_configure_interrupt_stack_guard();
#endif
	z_cstart();
204019d8:	570010ef          	jal	ra,20402f48 <z_cstart>

204019dc <__initialize>:
SECTION_FUNC(TEXT, __initialize)
	/*
	 * This will boot master core, just halt other cores.
	 * Note: need to be updated for complete SMP support
	 */
	csrr a0, mhartid
204019dc:	f1402573          	csrr	a0,mhartid
	beqz a0, boot_master_core
204019e0:	00050663          	beqz	a0,204019ec <boot_master_core>

204019e4 <loop_slave_core>:

loop_slave_core:
	wfi
204019e4:	10500073          	wfi
	j loop_slave_core
204019e8:	ffdff06f          	j	204019e4 <loop_slave_core>

204019ec <boot_master_core>:

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + CONFIG_ISR_STACK_SIZE
	 */
	la sp, z_interrupt_stacks
204019ec:	5fbff117          	auipc	sp,0x5fbff
204019f0:	d7410113          	addi	sp,sp,-652 # 80000760 <z_interrupt_stacks>
	li t0, CONFIG_ISR_STACK_SIZE
204019f4:	000012b7          	lui	t0,0x1
204019f8:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
204019fc:	00510133          	add	sp,sp,t0

	csrw mscratch, sp
20401a00:	34011073          	csrw	mscratch,sp

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
20401a04:	fc1ff0ef          	jal	ra,204019c4 <_PrepC>

20401a08 <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
20401a08:	9c4ff06f          	j	20400bcc <z_thread_entry>

20401a0c <arch_new_thread>:
#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	const struct soc_esf soc_esf_init = {SOC_ESF_INIT};
#endif

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)Z_STACK_PTR_ALIGN(
20401a0c:	fb460613          	addi	a2,a2,-76 # 3fb4 <__kernel_ram_size+0x2f74>
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
20401a10:	ff067613          	andi	a2,a2,-16
				);

	/* Setup the initial stack frame */
	stack_init->a0 = (ulong_t)entry;
	stack_init->a1 = (ulong_t)p1;
	stack_init->a2 = (ulong_t)p2;
20401a14:	02f62623          	sw	a5,44(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
20401a18:	000027b7          	lui	a5,0x2
20401a1c:	88078793          	addi	a5,a5,-1920 # 1880 <__kernel_ram_size+0x840>
20401a20:	04f62423          	sw	a5,72(a2)
#elif defined(CONFIG_FPU)
	/* Unshared FP mode: enable FPU of each thread. */
	stack_init->mstatus |= MSTATUS_FS_INIT;
#endif

	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
20401a24:	204027b7          	lui	a5,0x20402
20401a28:	a0878793          	addi	a5,a5,-1528 # 20401a08 <z_thread_entry_wrapper>
	stack_init->a0 = (ulong_t)entry;
20401a2c:	02d62223          	sw	a3,36(a2)
	stack_init->a1 = (ulong_t)p1;
20401a30:	02e62423          	sw	a4,40(a2)
	stack_init->a3 = (ulong_t)p3;
20401a34:	03062823          	sw	a6,48(a2)
	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
20401a38:	04f62223          	sw	a5,68(a2)

#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	stack_init->soc_context = soc_esf_init;
#endif

	thread->callee_saved.sp = (ulong_t)stack_init;
20401a3c:	02c52823          	sw	a2,48(a0)
}
20401a40:	00008067          	ret

20401a44 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
20401a44:	00050793          	mv	a5,a0
	size_t n = 0;
20401a48:	00000513          	li	a0,0

	while (*s != '\0') {
20401a4c:	00a78733          	add	a4,a5,a0
20401a50:	00074703          	lbu	a4,0(a4)
20401a54:	00071463          	bnez	a4,20401a5c <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
20401a58:	00008067          	ret
		n++;
20401a5c:	00150513          	addi	a0,a0,1
20401a60:	fedff06f          	j	20401a4c <strlen+0x8>

20401a64 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
20401a64:	00050793          	mv	a5,a0
	size_t n = 0;
20401a68:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
20401a6c:	00a78733          	add	a4,a5,a0
20401a70:	00074703          	lbu	a4,0(a4)
20401a74:	00070463          	beqz	a4,20401a7c <strnlen+0x18>
20401a78:	00b51463          	bne	a0,a1,20401a80 <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
20401a7c:	00008067          	ret
		n++;
20401a80:	00150513          	addi	a0,a0,1
20401a84:	fe9ff06f          	j	20401a6c <strnlen+0x8>

20401a88 <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
20401a88:	00000793          	li	a5,0
20401a8c:	00f61463          	bne	a2,a5,20401a94 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
20401a90:	00008067          	ret
		*(d_byte++) = *(s_byte++);
20401a94:	00f586b3          	add	a3,a1,a5
20401a98:	0006c683          	lbu	a3,0(a3)
20401a9c:	00f50733          	add	a4,a0,a5
20401aa0:	00178793          	addi	a5,a5,1
20401aa4:	00d70023          	sb	a3,0(a4)
		n--;
20401aa8:	fe5ff06f          	j	20401a8c <memcpy+0x4>

20401aac <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
20401aac:	0ff5f593          	andi	a1,a1,255
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
20401ab0:	00c50633          	add	a2,a0,a2
	unsigned char *d_byte = (unsigned char *)buf;
20401ab4:	00050793          	mv	a5,a0
	while (n > 0) {
20401ab8:	00c79463          	bne	a5,a2,20401ac0 <memset+0x14>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
20401abc:	00008067          	ret
		*(d_byte++) = c_byte;
20401ac0:	00178793          	addi	a5,a5,1
20401ac4:	feb78fa3          	sb	a1,-1(a5)
		n--;
20401ac8:	ff1ff06f          	j	20401ab8 <memset+0xc>

20401acc <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
20401acc:	fff00513          	li	a0,-1
20401ad0:	00008067          	ret

20401ad4 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
20401ad4:	80a1a223          	sw	a0,-2044(gp) # 8000100c <_stdout_hook>
}
20401ad8:	00008067          	ret

20401adc <plic_init>:
 *
 * @brief Initialize the Platform Level Interrupt Controller
 * @return N/A
 */
static int plic_init(const struct device *dev)
{
20401adc:	ff010113          	addi	sp,sp,-16
	    (volatile struct plic_regs_t *)PLIC_REG;
	int i;

	/* Ensure that all interrupts are disabled initially */
	for (i = 0; i < PLIC_EN_SIZE; i++) {
		*en = 0U;
20401ae0:	0c0027b7          	lui	a5,0xc002
{
20401ae4:	00112623          	sw	ra,12(sp)
		*en = 0U;
20401ae8:	0007a023          	sw	zero,0(a5) # c002000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xbffa000>
20401aec:	0007a223          	sw	zero,4(a5)
	volatile uint32_t *prio = (volatile uint32_t *)PLIC_PRIO;
20401af0:	0c0007b7          	lui	a5,0xc000
		en++;
	}

	/* Set priority of each interrupt line to 0 initially */
	for (i = 0; i < PLIC_IRQS; i++) {
20401af4:	0d078713          	addi	a4,a5,208 # c0000d0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xbff80d0>
		*prio = 0U;
20401af8:	0007a023          	sw	zero,0(a5)
		prio++;
20401afc:	00478793          	addi	a5,a5,4
	for (i = 0; i < PLIC_IRQS; i++) {
20401b00:	fee79ce3          	bne	a5,a4,20401af8 <plic_init+0x1c>
	}

	/* Set threshold priority to 0 */
	regs->threshold_prio = 0U;
20401b04:	0c2007b7          	lui	a5,0xc200
20401b08:	0007a023          	sw	zero,0(a5) # c200000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc1f8000>

	/* Setup IRQ handler for PLIC driver */
	IRQ_CONNECT(RISCV_MACHINE_EXT_IRQ,
20401b0c:	00000593          	li	a1,0
20401b10:	00b00513          	li	a0,11
20401b14:	e2dff0ef          	jal	ra,20401940 <arch_irq_priority_set>
		    plic_irq_handler,
		    NULL,
		    0);

	/* Enable IRQ for PLIC driver */
	irq_enable(RISCV_MACHINE_EXT_IRQ);
20401b18:	00b00513          	li	a0,11
20401b1c:	dddff0ef          	jal	ra,204018f8 <arch_irq_enable>

	return 0;
}
20401b20:	00c12083          	lw	ra,12(sp)
20401b24:	00000513          	li	a0,0
20401b28:	01010113          	addi	sp,sp,16
20401b2c:	00008067          	ret

20401b30 <plic_irq_handler>:
{
20401b30:	ff010113          	addi	sp,sp,-16
	irq = regs->claim_complete;
20401b34:	0c2007b7          	lui	a5,0xc200
{
20401b38:	00812423          	sw	s0,8(sp)
	irq = regs->claim_complete;
20401b3c:	0047a403          	lw	s0,4(a5) # c200004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc1f8004>
	save_irq = irq;
20401b40:	800007b7          	lui	a5,0x80000
{
20401b44:	00912223          	sw	s1,4(sp)
20401b48:	00112623          	sw	ra,12(sp)
	save_irq = irq;
20401b4c:	0087a823          	sw	s0,16(a5) # 80000010 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000011>
	if (irq == 0U || irq >= PLIC_IRQS)
20401b50:	fff40693          	addi	a3,s0,-1
20401b54:	03200713          	li	a4,50
20401b58:	01078493          	addi	s1,a5,16
20401b5c:	00d77663          	bgeu	a4,a3,20401b68 <plic_irq_handler+0x38>
		z_irq_spurious(NULL);
20401b60:	00000513          	li	a0,0
20401b64:	e49ff0ef          	jal	ra,204019ac <z_irq_spurious>
	irq += CONFIG_2ND_LVL_ISR_TBL_OFFSET;
20401b68:	00c40413          	addi	s0,s0,12
	ite->isr(ite->arg);
20401b6c:	204047b7          	lui	a5,0x20404
20401b70:	0fc78793          	addi	a5,a5,252 # 204040fc <_sw_isr_table>
20401b74:	00341413          	slli	s0,s0,0x3
20401b78:	00878433          	add	s0,a5,s0
20401b7c:	00442783          	lw	a5,4(s0)
20401b80:	00042503          	lw	a0,0(s0)
20401b84:	000780e7          	jalr	a5
	regs->claim_complete = save_irq;
20401b88:	0004a703          	lw	a4,0(s1)
}
20401b8c:	00c12083          	lw	ra,12(sp)
20401b90:	00812403          	lw	s0,8(sp)
	regs->claim_complete = save_irq;
20401b94:	0c2007b7          	lui	a5,0xc200
20401b98:	00e7a223          	sw	a4,4(a5) # c200004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc1f8004>
}
20401b9c:	00412483          	lw	s1,4(sp)
20401ba0:	01010113          	addi	sp,sp,16
20401ba4:	00008067          	ret

20401ba8 <riscv_plic_irq_enable>:
20401ba8:	00800793          	li	a5,8
20401bac:	3007b7f3          	csrrc	a5,mstatus,a5
	en += (irq >> 5);
20401bb0:	00555693          	srli	a3,a0,0x5
20401bb4:	00269713          	slli	a4,a3,0x2
20401bb8:	0c0026b7          	lui	a3,0xc002
20401bbc:	00e686b3          	add	a3,a3,a4
	*en |= (1 << (irq & 31));
20401bc0:	0006a603          	lw	a2,0(a3) # c002000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xbffa000>
20401bc4:	00100713          	li	a4,1
20401bc8:	00a71533          	sll	a0,a4,a0
20401bcc:	00c56533          	or	a0,a0,a2
20401bd0:	00a6a023          	sw	a0,0(a3)
	key = (mstatus & MSTATUS_IEN);
20401bd4:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20401bd8:	3007a7f3          	csrrs	a5,mstatus,a5
}
20401bdc:	00008067          	ret

20401be0 <riscv_plic_irq_disable>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20401be0:	00800713          	li	a4,8
20401be4:	30073773          	csrrc	a4,mstatus,a4
	en += (irq >> 5);
20401be8:	00555693          	srli	a3,a0,0x5
20401bec:	00269793          	slli	a5,a3,0x2
20401bf0:	0c0026b7          	lui	a3,0xc002
20401bf4:	00f686b3          	add	a3,a3,a5
	*en &= ~(1 << (irq & 31));
20401bf8:	0006a603          	lw	a2,0(a3) # c002000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xbffa000>
20401bfc:	00100793          	li	a5,1
20401c00:	00a797b3          	sll	a5,a5,a0
20401c04:	fff7c793          	not	a5,a5
20401c08:	00c7f7b3          	and	a5,a5,a2
20401c0c:	00f6a023          	sw	a5,0(a3)
	key = (mstatus & MSTATUS_IEN);
20401c10:	00877793          	andi	a5,a4,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20401c14:	3007a7f3          	csrrs	a5,mstatus,a5
}
20401c18:	00008067          	ret

20401c1c <riscv_plic_set_priority>:
	if (priority > PLIC_MAX_PRIO)
20401c1c:	00700793          	li	a5,7
20401c20:	00b7f463          	bgeu	a5,a1,20401c28 <riscv_plic_set_priority+0xc>
20401c24:	00700593          	li	a1,7
	prio += irq;
20401c28:	00251513          	slli	a0,a0,0x2
20401c2c:	0c0007b7          	lui	a5,0xc000
20401c30:	00a78533          	add	a0,a5,a0
	*prio = priority;
20401c34:	00b52023          	sw	a1,0(a0)
}
20401c38:	00008067          	ret

20401c3c <riscv_plic_get_irq>:
}
20401c3c:	800007b7          	lui	a5,0x80000
20401c40:	0107a503          	lw	a0,16(a5) # 80000010 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000011>
20401c44:	00008067          	ret

20401c48 <uart_console_init>:
{

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
20401c48:	20404537          	lui	a0,0x20404
{
20401c4c:	ff010113          	addi	sp,sp,-16
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
20401c50:	0b450713          	addi	a4,a0,180 # 204040b4 <__device_dts_ord_26>
20401c54:	800007b7          	lui	a5,0x80000
{
20401c58:	00112623          	sw	ra,12(sp)
20401c5c:	00812423          	sw	s0,8(sp)
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
20401c60:	00e7aa23          	sw	a4,20(a5) # 80000014 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000015>
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
20401c64:	0b450513          	addi	a0,a0,180
20401c68:	150010ef          	jal	ra,20402db8 <z_device_ready>
20401c6c:	fed00793          	li	a5,-19
20401c70:	00050e63          	beqz	a0,20401c8c <uart_console_init+0x44>
	__stdout_hook_install(console_out);
20401c74:	20402437          	lui	s0,0x20402
20401c78:	ca040513          	addi	a0,s0,-864 # 20401ca0 <console_out>
20401c7c:	e59ff0ef          	jal	ra,20401ad4 <__stdout_hook_install>
	__printk_hook_install(console_out);
20401c80:	ca040513          	addi	a0,s0,-864
20401c84:	ed1fe0ef          	jal	ra,20400b54 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
20401c88:	00000793          	li	a5,0
}
20401c8c:	00c12083          	lw	ra,12(sp)
20401c90:	00812403          	lw	s0,8(sp)
20401c94:	00078513          	mv	a0,a5
20401c98:	01010113          	addi	sp,sp,16
20401c9c:	00008067          	ret

20401ca0 <console_out>:
{
20401ca0:	ff010113          	addi	sp,sp,-16
20401ca4:	00812423          	sw	s0,8(sp)
20401ca8:	00912223          	sw	s1,4(sp)
20401cac:	00112623          	sw	ra,12(sp)
20401cb0:	800004b7          	lui	s1,0x80000
	if ('\n' == c) {
20401cb4:	00a00793          	li	a5,10
{
20401cb8:	00050413          	mv	s0,a0
20401cbc:	01448493          	addi	s1,s1,20 # 80000014 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000015>
	if ('\n' == c) {
20401cc0:	00f51c63          	bne	a0,a5,20401cd8 <console_out+0x38>
		uart_poll_out(uart_console_dev, '\r');
20401cc4:	0004a503          	lw	a0,0(s1)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
20401cc8:	00852783          	lw	a5,8(a0)
20401ccc:	00d00593          	li	a1,13
20401cd0:	0047a783          	lw	a5,4(a5)
20401cd4:	000780e7          	jalr	a5
	uart_poll_out(uart_console_dev, c);
20401cd8:	0004a503          	lw	a0,0(s1)
20401cdc:	00852783          	lw	a5,8(a0)
20401ce0:	0ff47593          	andi	a1,s0,255
20401ce4:	0047a783          	lw	a5,4(a5)
20401ce8:	000780e7          	jalr	a5
}
20401cec:	00c12083          	lw	ra,12(sp)
20401cf0:	00040513          	mv	a0,s0
20401cf4:	00812403          	lw	s0,8(sp)
20401cf8:	00412483          	lw	s1,4(sp)
20401cfc:	01010113          	addi	sp,sp,16
20401d00:	00008067          	ret

20401d04 <gpio_sifive_config>:
 */
static int gpio_sifive_config(const struct device *dev,
			      gpio_pin_t pin,
			      gpio_flags_t flags)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401d04:	00452783          	lw	a5,4(a0)
20401d08:	0047a703          	lw	a4,4(a5)

	if (pin >= SIFIVE_PINMUX_PINS) {
20401d0c:	01f00793          	li	a5,31
20401d10:	0ab7ec63          	bltu	a5,a1,20401dc8 <gpio_sifive_config+0xc4>
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
		return -ENOTSUP;
	}

	/* We only support pull-ups, not pull-downs */
	if ((flags & GPIO_PULL_DOWN) != 0) {
20401d14:	02267793          	andi	a5,a2,34
		return -ENOTSUP;
20401d18:	f7a00513          	li	a0,-134
	if ((flags & GPIO_PULL_DOWN) != 0) {
20401d1c:	0a079863          	bnez	a5,20401dcc <gpio_sifive_config+0xc8>
	}

	/* Set pull-up if requested */
	WRITE_BIT(gpio->pue, pin, flags & GPIO_PULL_UP);
20401d20:	00100793          	li	a5,1
20401d24:	00b795b3          	sll	a1,a5,a1
20401d28:	01067793          	andi	a5,a2,16
20401d2c:	06078863          	beqz	a5,20401d9c <gpio_sifive_config+0x98>
20401d30:	01072783          	lw	a5,16(a4)
20401d34:	00b7e7b3          	or	a5,a5,a1
20401d38:	00f72823          	sw	a5,16(a4)

	/* Set the initial output value before enabling output to avoid
	 * glitches
	 */
	if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
20401d3c:	00b65793          	srli	a5,a2,0xb
20401d40:	0017f793          	andi	a5,a5,1
20401d44:	00078863          	beqz	a5,20401d54 <gpio_sifive_config+0x50>
		gpio->out_val |= BIT(pin);
20401d48:	00c72783          	lw	a5,12(a4)
20401d4c:	00b7e7b3          	or	a5,a5,a1
20401d50:	00f72623          	sw	a5,12(a4)
	}
	if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
20401d54:	40067793          	andi	a5,a2,1024
20401d58:	00078a63          	beqz	a5,20401d6c <gpio_sifive_config+0x68>
		gpio->out_val &= ~BIT(pin);
20401d5c:	00c72683          	lw	a3,12(a4)
20401d60:	fff5c793          	not	a5,a1
20401d64:	00d7f7b3          	and	a5,a5,a3
20401d68:	00f72623          	sw	a5,12(a4)
	}

	/* Enable input/output */
	WRITE_BIT(gpio->out_en, pin, flags & GPIO_OUTPUT);
20401d6c:	20067793          	andi	a5,a2,512
20401d70:	02078e63          	beqz	a5,20401dac <gpio_sifive_config+0xa8>
20401d74:	00872783          	lw	a5,8(a4)
20401d78:	00b7e7b3          	or	a5,a5,a1
20401d7c:	00f72423          	sw	a5,8(a4)
	WRITE_BIT(gpio->in_en, pin, flags & GPIO_INPUT);
20401d80:	00472783          	lw	a5,4(a4)
20401d84:	10067613          	andi	a2,a2,256
20401d88:	02060a63          	beqz	a2,20401dbc <gpio_sifive_config+0xb8>
20401d8c:	00b7e5b3          	or	a1,a5,a1
20401d90:	00b72223          	sw	a1,4(a4)

	return 0;
20401d94:	00000513          	li	a0,0
20401d98:	00008067          	ret
	WRITE_BIT(gpio->pue, pin, flags & GPIO_PULL_UP);
20401d9c:	01072683          	lw	a3,16(a4)
20401da0:	fff5c793          	not	a5,a1
20401da4:	00d7f7b3          	and	a5,a5,a3
20401da8:	f91ff06f          	j	20401d38 <gpio_sifive_config+0x34>
	WRITE_BIT(gpio->out_en, pin, flags & GPIO_OUTPUT);
20401dac:	00872683          	lw	a3,8(a4)
20401db0:	fff5c793          	not	a5,a1
20401db4:	00d7f7b3          	and	a5,a5,a3
20401db8:	fc5ff06f          	j	20401d7c <gpio_sifive_config+0x78>
	WRITE_BIT(gpio->in_en, pin, flags & GPIO_INPUT);
20401dbc:	fff5c593          	not	a1,a1
20401dc0:	00f5f5b3          	and	a1,a1,a5
20401dc4:	fcdff06f          	j	20401d90 <gpio_sifive_config+0x8c>
		return -EINVAL;
20401dc8:	fea00513          	li	a0,-22
}
20401dcc:	00008067          	ret

20401dd0 <gpio_sifive_port_get_raw>:

static int gpio_sifive_port_get_raw(const struct device *dev,
				    gpio_port_value_t *value)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401dd0:	00452783          	lw	a5,4(a0)

	*value = gpio->in_val;

	return 0;
}
20401dd4:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401dd8:	0047a783          	lw	a5,4(a5)
	*value = gpio->in_val;
20401ddc:	0007a783          	lw	a5,0(a5)
20401de0:	00f5a023          	sw	a5,0(a1)
}
20401de4:	00008067          	ret

20401de8 <gpio_sifive_port_set_masked_raw>:

static int gpio_sifive_port_set_masked_raw(const struct device *dev,
					   gpio_port_pins_t mask,
					   gpio_port_value_t value)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401de8:	00452783          	lw	a5,4(a0)

	gpio->out_val = (gpio->out_val & ~mask) | (value & mask);

	return 0;
}
20401dec:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401df0:	0047a783          	lw	a5,4(a5)
	gpio->out_val = (gpio->out_val & ~mask) | (value & mask);
20401df4:	00c7a703          	lw	a4,12(a5)
20401df8:	00c74633          	xor	a2,a4,a2
20401dfc:	00b67633          	and	a2,a2,a1
20401e00:	00e64633          	xor	a2,a2,a4
20401e04:	00c7a623          	sw	a2,12(a5)
}
20401e08:	00008067          	ret

20401e0c <gpio_sifive_port_set_bits_raw>:

static int gpio_sifive_port_set_bits_raw(const struct device *dev,
					 gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401e0c:	00452783          	lw	a5,4(a0)

	gpio->out_val |= mask;

	return 0;
}
20401e10:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401e14:	0047a703          	lw	a4,4(a5)
	gpio->out_val |= mask;
20401e18:	00c72783          	lw	a5,12(a4)
20401e1c:	00b7e7b3          	or	a5,a5,a1
20401e20:	00f72623          	sw	a5,12(a4)
}
20401e24:	00008067          	ret

20401e28 <gpio_sifive_port_clear_bits_raw>:

static int gpio_sifive_port_clear_bits_raw(const struct device *dev,
					   gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401e28:	00452783          	lw	a5,4(a0)

	gpio->out_val &= ~mask;
20401e2c:	fff5c593          	not	a1,a1

	return 0;
}
20401e30:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401e34:	0047a783          	lw	a5,4(a5)
	gpio->out_val &= ~mask;
20401e38:	00c7a703          	lw	a4,12(a5)
20401e3c:	00e5f5b3          	and	a1,a1,a4
20401e40:	00b7a623          	sw	a1,12(a5)
}
20401e44:	00008067          	ret

20401e48 <gpio_sifive_port_toggle_bits>:

static int gpio_sifive_port_toggle_bits(const struct device *dev,
					gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401e48:	00452783          	lw	a5,4(a0)

	gpio->out_val ^= mask;

	return 0;
}
20401e4c:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401e50:	0047a703          	lw	a4,4(a5)
	gpio->out_val ^= mask;
20401e54:	00c72783          	lw	a5,12(a4)
20401e58:	00b7c7b3          	xor	a5,a5,a1
20401e5c:	00f72623          	sw	a5,12(a4)
}
20401e60:	00008067          	ret

20401e64 <gpio_sifive_manage_callback>:

static int gpio_sifive_manage_callback(const struct device *dev,
				       struct gpio_callback *callback,
				       bool set)
{
	struct gpio_sifive_data *data = DEV_GPIO_DATA(dev);
20401e64:	01052783          	lw	a5,16(a0)
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
20401e68:	00000693          	li	a3,0
	return list->head;
20401e6c:	0047a703          	lw	a4,4(a5)
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
20401e70:	00071a63          	bnez	a4,20401e84 <gpio_sifive_manage_callback+0x20>
				return -EINVAL;
			}
		}
	}

	if (set) {
20401e74:	04061c63          	bnez	a2,20401ecc <gpio_sifive_manage_callback+0x68>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
20401e78:	00000513          	li	a0,0

	return gpio_manage_callback(&data->cb, callback, set);
}
20401e7c:	00008067          	ret
20401e80:	00050713          	mv	a4,a0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
20401e84:	02e59a63          	bne	a1,a4,20401eb8 <gpio_sifive_manage_callback+0x54>
	return node->next;
20401e88:	0005a703          	lw	a4,0(a1)
	return list->tail;
20401e8c:	0087a503          	lw	a0,8(a5)
Z_GENLIST_REMOVE(slist, snode)
20401e90:	00069c63          	bnez	a3,20401ea8 <gpio_sifive_manage_callback+0x44>
	list->head = node;
20401e94:	00e7a223          	sw	a4,4(a5)
Z_GENLIST_REMOVE(slist, snode)
20401e98:	00b51463          	bne	a0,a1,20401ea0 <gpio_sifive_manage_callback+0x3c>
	list->tail = node;
20401e9c:	00e7a423          	sw	a4,8(a5)
	parent->next = child;
20401ea0:	0005a023          	sw	zero,0(a1)
20401ea4:	fd1ff06f          	j	20401e74 <gpio_sifive_manage_callback+0x10>
20401ea8:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
20401eac:	feb51ae3          	bne	a0,a1,20401ea0 <gpio_sifive_manage_callback+0x3c>
	list->tail = node;
20401eb0:	00d7a423          	sw	a3,8(a5)
}
20401eb4:	fedff06f          	j	20401ea0 <gpio_sifive_manage_callback+0x3c>
	return node->next;
20401eb8:	00072503          	lw	a0,0(a4)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
20401ebc:	00070693          	mv	a3,a4
20401ec0:	fc0510e3          	bnez	a0,20401e80 <gpio_sifive_manage_callback+0x1c>
				return -EINVAL;
20401ec4:	fea00513          	li	a0,-22
			if (!set) {
20401ec8:	fa060ae3          	beqz	a2,20401e7c <gpio_sifive_manage_callback+0x18>
	parent->next = child;
20401ecc:	0047a703          	lw	a4,4(a5)
20401ed0:	00e5a023          	sw	a4,0(a1)
Z_GENLIST_PREPEND(slist, snode)
20401ed4:	0087a703          	lw	a4,8(a5)
	list->head = node;
20401ed8:	00b7a223          	sw	a1,4(a5)
Z_GENLIST_PREPEND(slist, snode)
20401edc:	f8071ee3          	bnez	a4,20401e78 <gpio_sifive_manage_callback+0x14>
	list->tail = node;
20401ee0:	00b7a423          	sw	a1,8(a5)
20401ee4:	f95ff06f          	j	20401e78 <gpio_sifive_manage_callback+0x14>

20401ee8 <gpio_sifive_init>:
 *
 * @return 0
 */
static int gpio_sifive_init(const struct device *dev)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401ee8:	00452703          	lw	a4,4(a0)
{
20401eec:	ff010113          	addi	sp,sp,-16
20401ef0:	00112623          	sw	ra,12(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20401ef4:	00472783          	lw	a5,4(a4)
	const struct gpio_sifive_config *cfg = DEV_GPIO_CFG(dev);

	/* Ensure that all gpio registers are reset to 0 initially */
	gpio->in_en   = 0U;
20401ef8:	0007a223          	sw	zero,4(a5)
	gpio->out_en  = 0U;
20401efc:	0007a423          	sw	zero,8(a5)
	gpio->pue     = 0U;
20401f00:	0007a823          	sw	zero,16(a5)
	gpio->rise_ie = 0U;
20401f04:	0007ac23          	sw	zero,24(a5)
	gpio->fall_ie = 0U;
20401f08:	0207a023          	sw	zero,32(a5)
	gpio->high_ie = 0U;
20401f0c:	0207a423          	sw	zero,40(a5)
	gpio->low_ie  = 0U;
20401f10:	0207a823          	sw	zero,48(a5)
	gpio->invert  = 0U;
20401f14:	0407a023          	sw	zero,64(a5)

	/* Setup IRQ handler for each gpio pin */
	cfg->gpio_cfg_func();
20401f18:	00c72783          	lw	a5,12(a4)
20401f1c:	000780e7          	jalr	a5

	return 0;
}
20401f20:	00c12083          	lw	ra,12(sp)
20401f24:	00000513          	li	a0,0
20401f28:	01010113          	addi	sp,sp,16
20401f2c:	00008067          	ret

20401f30 <gpio_sifive_cfg_0>:
		gpio_sifive_irq_handler,			\
		DEVICE_DT_INST_GET(0),				\
		0);

static void gpio_sifive_cfg_0(void)
{
20401f30:	ff010113          	addi	sp,sp,-16
20401f34:	00812423          	sw	s0,8(sp)
#if DT_INST_IRQ_HAS_IDX(0, 0)
	IRQ_INIT(0);
20401f38:	00001437          	lui	s0,0x1
20401f3c:	90b40513          	addi	a0,s0,-1781 # 90b <CONFIG_ISR_STACK_SIZE+0x10b>
20401f40:	00100593          	li	a1,1
{
20401f44:	00112623          	sw	ra,12(sp)
	IRQ_INIT(0);
20401f48:	9f9ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 1)
	IRQ_INIT(1);
20401f4c:	a0b40513          	addi	a0,s0,-1525
20401f50:	00100593          	li	a1,1
20401f54:	9edff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 2)
	IRQ_INIT(2);
20401f58:	b0b40513          	addi	a0,s0,-1269
20401f5c:	00100593          	li	a1,1
20401f60:	9e1ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 3)
	IRQ_INIT(3);
20401f64:	c0b40513          	addi	a0,s0,-1013
20401f68:	00100593          	li	a1,1
20401f6c:	9d5ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 4)
	IRQ_INIT(4);
20401f70:	d0b40513          	addi	a0,s0,-757
20401f74:	00100593          	li	a1,1
20401f78:	9c9ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 5)
	IRQ_INIT(5);
20401f7c:	e0b40513          	addi	a0,s0,-501
20401f80:	00100593          	li	a1,1
20401f84:	9bdff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 6)
	IRQ_INIT(6);
20401f88:	f0b40513          	addi	a0,s0,-245
20401f8c:	00100593          	li	a1,1
20401f90:	9b1ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 7)
	IRQ_INIT(7);
20401f94:	00b40513          	addi	a0,s0,11
20401f98:	00100593          	li	a1,1
20401f9c:	9a5ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 8)
	IRQ_INIT(8);
20401fa0:	10b40513          	addi	a0,s0,267
20401fa4:	00100593          	li	a1,1
20401fa8:	999ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 9)
	IRQ_INIT(9);
20401fac:	20b40513          	addi	a0,s0,523
20401fb0:	00100593          	li	a1,1
20401fb4:	98dff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 10)
	IRQ_INIT(10);
20401fb8:	30b40513          	addi	a0,s0,779
20401fbc:	00100593          	li	a1,1
20401fc0:	981ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 11)
	IRQ_INIT(11);
20401fc4:	40b40513          	addi	a0,s0,1035
20401fc8:	00100593          	li	a1,1
20401fcc:	975ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 12)
	IRQ_INIT(12);
20401fd0:	50b40513          	addi	a0,s0,1291
20401fd4:	00100593          	li	a1,1
20401fd8:	969ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 13)
	IRQ_INIT(13);
20401fdc:	60b40513          	addi	a0,s0,1547
20401fe0:	00100593          	li	a1,1
20401fe4:	95dff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 14)
	IRQ_INIT(14);
20401fe8:	70b40513          	addi	a0,s0,1803
20401fec:	00100593          	li	a1,1
#endif
#if DT_INST_IRQ_HAS_IDX(0, 15)
	IRQ_INIT(15);
20401ff0:	00002437          	lui	s0,0x2
	IRQ_INIT(14);
20401ff4:	94dff0ef          	jal	ra,20401940 <arch_irq_priority_set>
	IRQ_INIT(15);
20401ff8:	80b40513          	addi	a0,s0,-2037 # 180b <__kernel_ram_size+0x7cb>
20401ffc:	00100593          	li	a1,1
20402000:	941ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 16)
	IRQ_INIT(16);
20402004:	90b40513          	addi	a0,s0,-1781
20402008:	00100593          	li	a1,1
2040200c:	935ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 17)
	IRQ_INIT(17);
20402010:	a0b40513          	addi	a0,s0,-1525
20402014:	00100593          	li	a1,1
20402018:	929ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 18)
	IRQ_INIT(18);
2040201c:	b0b40513          	addi	a0,s0,-1269
20402020:	00100593          	li	a1,1
20402024:	91dff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 19)
	IRQ_INIT(19);
20402028:	c0b40513          	addi	a0,s0,-1013
2040202c:	00100593          	li	a1,1
20402030:	911ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 20)
	IRQ_INIT(20);
20402034:	d0b40513          	addi	a0,s0,-757
20402038:	00100593          	li	a1,1
2040203c:	905ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 21)
	IRQ_INIT(21);
20402040:	e0b40513          	addi	a0,s0,-501
20402044:	00100593          	li	a1,1
20402048:	8f9ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 22)
	IRQ_INIT(22);
2040204c:	f0b40513          	addi	a0,s0,-245
20402050:	00100593          	li	a1,1
20402054:	8edff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 23)
	IRQ_INIT(23);
20402058:	00b40513          	addi	a0,s0,11
2040205c:	00100593          	li	a1,1
20402060:	8e1ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 24)
	IRQ_INIT(24);
20402064:	10b40513          	addi	a0,s0,267
20402068:	00100593          	li	a1,1
2040206c:	8d5ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 25)
	IRQ_INIT(25);
20402070:	20b40513          	addi	a0,s0,523
20402074:	00100593          	li	a1,1
20402078:	8c9ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 26)
	IRQ_INIT(26);
2040207c:	30b40513          	addi	a0,s0,779
20402080:	00100593          	li	a1,1
20402084:	8bdff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 27)
	IRQ_INIT(27);
20402088:	40b40513          	addi	a0,s0,1035
2040208c:	00100593          	li	a1,1
20402090:	8b1ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 28)
	IRQ_INIT(28);
20402094:	50b40513          	addi	a0,s0,1291
20402098:	00100593          	li	a1,1
2040209c:	8a5ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 29)
	IRQ_INIT(29);
204020a0:	60b40513          	addi	a0,s0,1547
204020a4:	00100593          	li	a1,1
204020a8:	899ff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 30)
	IRQ_INIT(30);
204020ac:	70b40513          	addi	a0,s0,1803
204020b0:	00100593          	li	a1,1
204020b4:	88dff0ef          	jal	ra,20401940 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 31)
	IRQ_INIT(31);
#endif
}
204020b8:	00812403          	lw	s0,8(sp)
204020bc:	00c12083          	lw	ra,12(sp)
	IRQ_INIT(31);
204020c0:	00003537          	lui	a0,0x3
204020c4:	00100593          	li	a1,1
204020c8:	80b50513          	addi	a0,a0,-2037 # 280b <__kernel_ram_size+0x17cb>
}
204020cc:	01010113          	addi	sp,sp,16
	IRQ_INIT(31);
204020d0:	871ff06f          	j	20401940 <arch_irq_priority_set>

204020d4 <gpio_sifive_irq_handler>:
{
204020d4:	fe010113          	addi	sp,sp,-32
204020d8:	00812c23          	sw	s0,24(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
204020dc:	00452403          	lw	s0,4(a0)
{
204020e0:	00912a23          	sw	s1,20(sp)
204020e4:	01212823          	sw	s2,16(sp)
204020e8:	01312623          	sw	s3,12(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
204020ec:	00442903          	lw	s2,4(s0)
	struct gpio_sifive_data *data = DEV_GPIO_DATA(dev);
204020f0:	01052983          	lw	s3,16(a0)
{
204020f4:	00112e23          	sw	ra,28(sp)
204020f8:	00050493          	mv	s1,a0
	uint8_t pin = 1 + (riscv_plic_get_irq() - (uint8_t)(cfg->gpio_irq_base >> 8));
204020fc:	b41ff0ef          	jal	ra,20401c3c <riscv_plic_get_irq>
20402100:	00842403          	lw	s0,8(s0)
20402104:	0049a583          	lw	a1,4(s3)
20402108:	00845413          	srli	s0,s0,0x8
2040210c:	40850533          	sub	a0,a0,s0
20402110:	00150513          	addi	a0,a0,1
	gpio->rise_ip = BIT(pin);
20402114:	00100413          	li	s0,1
20402118:	00a41433          	sll	s0,s0,a0
2040211c:	00892e23          	sw	s0,28(s2)
	gpio->fall_ip = BIT(pin);
20402120:	02892223          	sw	s0,36(s2)
	gpio->high_ip = BIT(pin);
20402124:	02892623          	sw	s0,44(s2)
	gpio->low_ip = BIT(pin);
20402128:	02892a23          	sw	s0,52(s2)
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
2040212c:	02058863          	beqz	a1,2040215c <gpio_sifive_irq_handler+0x88>
	return node->next;
20402130:	0005a903          	lw	s2,0(a1)
		if (cb->pin_mask & pins) {
20402134:	0085a603          	lw	a2,8(a1)
20402138:	00c47633          	and	a2,s0,a2
2040213c:	00060863          	beqz	a2,2040214c <gpio_sifive_irq_handler+0x78>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
20402140:	0045a783          	lw	a5,4(a1)
20402144:	00048513          	mv	a0,s1
20402148:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
2040214c:	00090863          	beqz	s2,2040215c <gpio_sifive_irq_handler+0x88>
20402150:	00090593          	mv	a1,s2
20402154:	00092903          	lw	s2,0(s2)
20402158:	fddff06f          	j	20402134 <gpio_sifive_irq_handler+0x60>
}
2040215c:	01c12083          	lw	ra,28(sp)
20402160:	01812403          	lw	s0,24(sp)
20402164:	01412483          	lw	s1,20(sp)
20402168:	01012903          	lw	s2,16(sp)
2040216c:	00c12983          	lw	s3,12(sp)
20402170:	02010113          	addi	sp,sp,32
20402174:	00008067          	ret

20402178 <gpio_sifive_pin_interrupt_configure>:
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402178:	00452803          	lw	a6,4(a0)
	gpio->rise_ie &= ~BIT(pin);
2040217c:	00100713          	li	a4,1
20402180:	00b71733          	sll	a4,a4,a1
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402184:	00482783          	lw	a5,4(a6)
	gpio->rise_ie &= ~BIT(pin);
20402188:	fff74513          	not	a0,a4
{
2040218c:	ff010113          	addi	sp,sp,-16
	gpio->rise_ie &= ~BIT(pin);
20402190:	0187a883          	lw	a7,24(a5)
{
20402194:	00112623          	sw	ra,12(sp)
	gpio->rise_ie &= ~BIT(pin);
20402198:	00a8f8b3          	and	a7,a7,a0
2040219c:	0117ac23          	sw	a7,24(a5)
	gpio->fall_ie &= ~BIT(pin);
204021a0:	0207a883          	lw	a7,32(a5)
204021a4:	011578b3          	and	a7,a0,a7
204021a8:	0317a023          	sw	a7,32(a5)
	gpio->high_ie &= ~BIT(pin);
204021ac:	0287a883          	lw	a7,40(a5)
204021b0:	011578b3          	and	a7,a0,a7
204021b4:	0317a423          	sw	a7,40(a5)
	gpio->low_ie  &= ~BIT(pin);
204021b8:	0307a883          	lw	a7,48(a5)
204021bc:	01157533          	and	a0,a0,a7
204021c0:	02a7a823          	sw	a0,48(a5)
	switch (mode) {
204021c4:	00004537          	lui	a0,0x4
204021c8:	04a60263          	beq	a2,a0,2040220c <gpio_sifive_pin_interrupt_configure+0x94>
204021cc:	00014537          	lui	a0,0x14
204021d0:	08a60463          	beq	a2,a0,20402258 <gpio_sifive_pin_interrupt_configure+0xe0>
204021d4:	000027b7          	lui	a5,0x2
204021d8:	f7a00513          	li	a0,-134
204021dc:	00f61e63          	bne	a2,a5,204021f8 <gpio_sifive_pin_interrupt_configure+0x80>
		irq_disable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
204021e0:	00882783          	lw	a5,8(a6)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
204021e4:	0087d713          	srli	a4,a5,0x8
204021e8:	00071e63          	bnez	a4,20402204 <gpio_sifive_pin_interrupt_configure+0x8c>
		pin_irq = base_irq + (pin << 8);
204021ec:	00f58533          	add	a0,a1,a5
		irq_disable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
204021f0:	f2cff0ef          	jal	ra,2040191c <arch_irq_disable>
	return 0;
204021f4:	00000513          	li	a0,0
}
204021f8:	00c12083          	lw	ra,12(sp)
204021fc:	01010113          	addi	sp,sp,16
20402200:	00008067          	ret
		pin_irq = base_irq + (pin << 8);
20402204:	00859593          	slli	a1,a1,0x8
20402208:	fe5ff06f          	j	204021ec <gpio_sifive_pin_interrupt_configure+0x74>
		if (trig == GPIO_INT_TRIG_HIGH) {
2040220c:	00040637          	lui	a2,0x40
20402210:	02c69663          	bne	a3,a2,2040223c <gpio_sifive_pin_interrupt_configure+0xc4>
			gpio->high_ip = BIT(pin);
20402214:	02e7a623          	sw	a4,44(a5) # 202c <__kernel_ram_size+0xfec>
			gpio->high_ie |= BIT(pin);
20402218:	0287a683          	lw	a3,40(a5)
2040221c:	00d76733          	or	a4,a4,a3
20402220:	02e7a423          	sw	a4,40(a5)
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
20402224:	00882783          	lw	a5,8(a6)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
20402228:	0087d713          	srli	a4,a5,0x8
2040222c:	02071263          	bnez	a4,20402250 <gpio_sifive_pin_interrupt_configure+0xd8>
		pin_irq = base_irq + (pin << 8);
20402230:	00f58533          	add	a0,a1,a5
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
20402234:	ec4ff0ef          	jal	ra,204018f8 <arch_irq_enable>
20402238:	fbdff06f          	j	204021f4 <gpio_sifive_pin_interrupt_configure+0x7c>
			gpio->low_ip = BIT(pin);
2040223c:	02e7aa23          	sw	a4,52(a5)
			gpio->low_ie  |= BIT(pin);
20402240:	0307a683          	lw	a3,48(a5)
20402244:	00d76733          	or	a4,a4,a3
20402248:	02e7a823          	sw	a4,48(a5)
2040224c:	fd9ff06f          	j	20402224 <gpio_sifive_pin_interrupt_configure+0xac>
		pin_irq = base_irq + (pin << 8);
20402250:	00859593          	slli	a1,a1,0x8
20402254:	fddff06f          	j	20402230 <gpio_sifive_pin_interrupt_configure+0xb8>
		if ((trig & GPIO_INT_HIGH_1) != 0) {
20402258:	00040637          	lui	a2,0x40
2040225c:	00c6f633          	and	a2,a3,a2
20402260:	00060a63          	beqz	a2,20402274 <gpio_sifive_pin_interrupt_configure+0xfc>
			gpio->rise_ip = BIT(pin);
20402264:	00e7ae23          	sw	a4,28(a5)
			gpio->rise_ie |= BIT(pin);
20402268:	0187a603          	lw	a2,24(a5)
2040226c:	00c76633          	or	a2,a4,a2
20402270:	00c7ac23          	sw	a2,24(a5)
		if ((trig & GPIO_INT_LOW_0) != 0) {
20402274:	00020637          	lui	a2,0x20
20402278:	00c6f6b3          	and	a3,a3,a2
2040227c:	00068a63          	beqz	a3,20402290 <gpio_sifive_pin_interrupt_configure+0x118>
			gpio->fall_ip = BIT(pin);
20402280:	02e7a223          	sw	a4,36(a5)
			gpio->fall_ie |= BIT(pin);
20402284:	0207a683          	lw	a3,32(a5)
20402288:	00d76733          	or	a4,a4,a3
2040228c:	02e7a023          	sw	a4,32(a5)
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
20402290:	00882503          	lw	a0,8(a6)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
20402294:	00855793          	srli	a5,a0,0x8
20402298:	00079663          	bnez	a5,204022a4 <gpio_sifive_pin_interrupt_configure+0x12c>
		pin_irq = base_irq + (pin << 8);
2040229c:	00a58533          	add	a0,a1,a0
204022a0:	f95ff06f          	j	20402234 <gpio_sifive_pin_interrupt_configure+0xbc>
204022a4:	00859593          	slli	a1,a1,0x8
204022a8:	ff5ff06f          	j	2040229c <gpio_sifive_pin_interrupt_configure+0x124>

204022ac <spi_context_get_next_buf.constprop.0>:
					     size_t *count,
					     size_t *buf_len,
					     uint8_t dfs)
{
	/* This loop skips zero-length buffers in the set, if any. */
	while (*count) {
204022ac:	0005a703          	lw	a4,0(a1)
204022b0:	00071863          	bnez	a4,204022c0 <spi_context_get_next_buf.constprop.0+0x14>
		}
		++(*current);
		--(*count);
	}

	*buf_len = 0;
204022b4:	00062023          	sw	zero,0(a2) # 20000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x18000>
	return NULL;
204022b8:	00000513          	li	a0,0
}
204022bc:	00008067          	ret
		if (((*current)->len / dfs) != 0) {
204022c0:	00052783          	lw	a5,0(a0) # 14000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc000>
204022c4:	0047a683          	lw	a3,4(a5)
204022c8:	00068863          	beqz	a3,204022d8 <spi_context_get_next_buf.constprop.0+0x2c>
			return (*current)->buf;
204022cc:	0007a503          	lw	a0,0(a5)
			*buf_len = (*current)->len / dfs;
204022d0:	00d62023          	sw	a3,0(a2)
			return (*current)->buf;
204022d4:	00008067          	ret
		++(*current);
204022d8:	00878793          	addi	a5,a5,8
204022dc:	00f52023          	sw	a5,0(a0)
		--(*count);
204022e0:	fff70713          	addi	a4,a4,-1
204022e4:	00e5a023          	sw	a4,0(a1)
204022e8:	fc5ff06f          	j	204022ac <spi_context_get_next_buf.constprop.0>

204022ec <gpio_pin_set_dt.isra.0>:
 *
 * @param spec GPIO specification from devicetree
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
204022ec:	00050793          	mv	a5,a0
204022f0:	00058713          	mv	a4,a1
{
	return gpio_pin_set(spec->port, spec->pin, value);
204022f4:	00052503          	lw	a0,0(a0)
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
204022f8:	0047c583          	lbu	a1,4(a5)
204022fc:	00100793          	li	a5,1
20402300:	00b795b3          	sll	a1,a5,a1
20402304:	01052783          	lw	a5,16(a0)
20402308:	0007a783          	lw	a5,0(a5)
2040230c:	00f5f7b3          	and	a5,a1,a5
20402310:	00078463          	beqz	a5,20402318 <gpio_pin_set_dt.isra.0+0x2c>
		value = (value != 0) ? 0 : 1;
20402314:	00174713          	xori	a4,a4,1
	if (value != 0)	{
20402318:	00070863          	beqz	a4,20402328 <gpio_pin_set_dt.isra.0+0x3c>
	return api->port_set_bits_raw(port, pins);
2040231c:	00852783          	lw	a5,8(a0)
20402320:	00c7a783          	lw	a5,12(a5)
	return api->port_clear_bits_raw(port, pins);
20402324:	00078067          	jr	a5
20402328:	00852783          	lw	a5,8(a0)
2040232c:	0107a783          	lw	a5,16(a5)
20402330:	ff5ff06f          	j	20402324 <gpio_pin_set_dt.isra.0+0x38>

20402334 <_spi_context_cs_control>:
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
20402334:	00052783          	lw	a5,0(a0)
20402338:	08078a63          	beqz	a5,204023cc <_spi_context_cs_control+0x98>
{
2040233c:	ff010113          	addi	sp,sp,-16
20402340:	00812423          	sw	s0,8(sp)
20402344:	00050413          	mv	s0,a0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
20402348:	0087a503          	lw	a0,8(a5)
{
2040234c:	00112623          	sw	ra,12(sp)
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
20402350:	06050663          	beqz	a0,204023bc <_spi_context_cs_control+0x88>
20402354:	00052703          	lw	a4,0(a0)
20402358:	06070263          	beqz	a4,204023bc <_spi_context_cs_control+0x88>
		if (on) {
2040235c:	02058463          	beqz	a1,20402384 <_spi_context_cs_control+0x50>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 1);
20402360:	00100593          	li	a1,1
20402364:	f89ff0ef          	jal	ra,204022ec <gpio_pin_set_dt.isra.0>
			k_busy_wait(ctx->config->cs->delay);
20402368:	00042783          	lw	a5,0(s0)
2040236c:	0087a783          	lw	a5,8(a5)
20402370:	0087a503          	lw	a0,8(a5)
}
20402374:	00812403          	lw	s0,8(sp)
20402378:	00c12083          	lw	ra,12(sp)
2040237c:	01010113          	addi	sp,sp,16
	z_impl_k_busy_wait(usec_to_wait);
20402380:	4690106f          	j	20403fe8 <z_impl_k_busy_wait>
			if (!force_off &&
20402384:	00061a63          	bnez	a2,20402398 <_spi_context_cs_control+0x64>
20402388:	0047d783          	lhu	a5,4(a5)
2040238c:	00001737          	lui	a4,0x1
20402390:	00e7f7b3          	and	a5,a5,a4
20402394:	02079463          	bnez	a5,204023bc <_spi_context_cs_control+0x88>
			k_busy_wait(ctx->config->cs->delay);
20402398:	00852503          	lw	a0,8(a0)
2040239c:	44d010ef          	jal	ra,20403fe8 <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
204023a0:	00042783          	lw	a5,0(s0)
}
204023a4:	00812403          	lw	s0,8(sp)
204023a8:	00c12083          	lw	ra,12(sp)
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
204023ac:	0087a503          	lw	a0,8(a5)
204023b0:	00000593          	li	a1,0
}
204023b4:	01010113          	addi	sp,sp,16
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
204023b8:	f35ff06f          	j	204022ec <gpio_pin_set_dt.isra.0>
}
204023bc:	00c12083          	lw	ra,12(sp)
204023c0:	00812403          	lw	s0,8(sp)
204023c4:	01010113          	addi	sp,sp,16
204023c8:	00008067          	ret
204023cc:	00008067          	ret

204023d0 <spi_context_unlock_unconditionally>:
{
204023d0:	ff010113          	addi	sp,sp,-16
	_spi_context_cs_control(ctx, false, true);
204023d4:	00100613          	li	a2,1
204023d8:	00000593          	li	a1,0
{
204023dc:	00812423          	sw	s0,8(sp)
204023e0:	00112623          	sw	ra,12(sp)
204023e4:	00050413          	mv	s0,a0
	_spi_context_cs_control(ctx, false, true);
204023e8:	f4dff0ef          	jal	ra,20402334 <_spi_context_cs_control>
	if (!k_sem_count_get(&ctx->lock)) {
204023ec:	01842783          	lw	a5,24(s0)
204023f0:	00079e63          	bnez	a5,2040240c <spi_context_unlock_unconditionally+0x3c>
		ctx->owner = NULL;
204023f4:	00042223          	sw	zero,4(s0)
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
204023f8:	01040513          	addi	a0,s0,16
}
204023fc:	00812403          	lw	s0,8(sp)
20402400:	00c12083          	lw	ra,12(sp)
20402404:	01010113          	addi	sp,sp,16
20402408:	5d90006f          	j	204031e0 <z_impl_k_sem_give>
2040240c:	00c12083          	lw	ra,12(sp)
20402410:	00812403          	lw	s0,8(sp)
20402414:	01010113          	addi	sp,sp,16
20402418:	00008067          	ret

2040241c <spi_sifive_release>:
}

int spi_sifive_release(const struct device *dev,
		       const struct spi_config *config)
{
	spi_context_unlock_unconditionally(&SPI_DATA(dev)->ctx);
2040241c:	01052503          	lw	a0,16(a0)
{
20402420:	ff010113          	addi	sp,sp,-16
20402424:	00112623          	sw	ra,12(sp)
	spi_context_unlock_unconditionally(&SPI_DATA(dev)->ctx);
20402428:	fa9ff0ef          	jal	ra,204023d0 <spi_context_unlock_unconditionally>
	return 0;
}
2040242c:	00c12083          	lw	ra,12(sp)
20402430:	00000513          	li	a0,0
20402434:	01010113          	addi	sp,sp,16
20402438:	00008067          	ret

2040243c <spi_sifive_init>:
	sys_clear_bit(SPI_REG(dev, REG_FCTRL), SF_FCTRL_EN);
2040243c:	00452783          	lw	a5,4(a0)
{
20402440:	fe010113          	addi	sp,sp,-32
20402444:	01612023          	sw	s6,0(sp)
	sys_clear_bit(SPI_REG(dev, REG_FCTRL), SF_FCTRL_EN);
20402448:	0007a703          	lw	a4,0(a5)
	err = spi_context_cs_configure_all(&SPI_DATA(dev)->ctx);
2040244c:	01052b03          	lw	s6,16(a0)
{
20402450:	00812c23          	sw	s0,24(sp)
	*(volatile uint32_t *)addr = temp | (1 << bit);
}

static ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
20402454:	06072783          	lw	a5,96(a4) # 1060 <__kernel_ram_size+0x20>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
20402458:	008b2403          	lw	s0,8(s6)
2040245c:	00912a23          	sw	s1,20(sp)
20402460:	01212823          	sw	s2,16(sp)
20402464:	01312623          	sw	s3,12(sp)
20402468:	01412423          	sw	s4,8(sp)
2040246c:	01512223          	sw	s5,4(sp)
20402470:	00112e23          	sw	ra,28(sp)

	*(volatile uint32_t *)addr = temp & ~(1 << bit);
20402474:	ffe7f793          	andi	a5,a5,-2
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
20402478:	00002937          	lui	s2,0x2
	return gpio_pin_configure(spec->port,
2040247c:	000019b7          	lui	s3,0x1
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
20402480:	fffffa37          	lui	s4,0xfffff
20402484:	00050493          	mv	s1,a0
20402488:	06f72023          	sw	a5,96(a4)
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
2040248c:	a0090913          	addi	s2,s2,-1536 # 1a00 <__kernel_ram_size+0x9c0>
	return gpio_pin_configure(spec->port,
20402490:	60098993          	addi	s3,s3,1536 # 1600 <__kernel_ram_size+0x5c0>
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
20402494:	fffa0a13          	addi	s4,s4,-1 # ffffefff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffff000>
		data->invert |= (gpio_port_pins_t)BIT(pin);
20402498:	00100a93          	li	s5,1
2040249c:	00cb2783          	lw	a5,12(s6)
204024a0:	00379713          	slli	a4,a5,0x3
204024a4:	008b2783          	lw	a5,8(s6)
204024a8:	00e787b3          	add	a5,a5,a4
204024ac:	00f46a63          	bltu	s0,a5,204024c0 <spi_sifive_init+0x84>
	spi_context_unlock_unconditionally(&SPI_DATA(dev)->ctx);
204024b0:	0104a503          	lw	a0,16(s1)
204024b4:	f1dff0ef          	jal	ra,204023d0 <spi_context_unlock_unconditionally>
	return 0;
204024b8:	00000513          	li	a0,0
204024bc:	0740006f          	j	20402530 <spi_sifive_init+0xf4>
		if (!device_is_ready(cs_gpio->port)) {
204024c0:	00042503          	lw	a0,0(s0)
204024c4:	0f5000ef          	jal	ra,20402db8 <z_device_ready>
204024c8:	06050263          	beqz	a0,2040252c <spi_sifive_init+0xf0>
	return gpio_pin_configure(spec->port,
204024cc:	00042503          	lw	a0,0(s0)
204024d0:	00444583          	lbu	a1,4(s0)
				  spec->dt_flags | extra_flags);
204024d4:	00544783          	lbu	a5,5(s0)
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
204024d8:	0017f693          	andi	a3,a5,1
	const struct gpio_driver_api *api =
204024dc:	00852883          	lw	a7,8(a0)
	struct gpio_driver_data *data =
204024e0:	01052803          	lw	a6,16(a0)
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
204024e4:	0127c733          	xor	a4,a5,s2
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
204024e8:	00069463          	bnez	a3,204024f0 <spi_sifive_init+0xb4>
	return gpio_pin_configure(spec->port,
204024ec:	0137e733          	or	a4,a5,s3
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
204024f0:	01477633          	and	a2,a4,s4
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
204024f4:	00177713          	andi	a4,a4,1
		data->invert |= (gpio_port_pins_t)BIT(pin);
204024f8:	00082783          	lw	a5,0(a6)
204024fc:	00ba96b3          	sll	a3,s5,a1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
20402500:	02070063          	beqz	a4,20402520 <spi_sifive_init+0xe4>
		data->invert |= (gpio_port_pins_t)BIT(pin);
20402504:	00f6e7b3          	or	a5,a3,a5
20402508:	00f82023          	sw	a5,0(a6)
	return api->pin_configure(port, pin, flags);
2040250c:	0008a783          	lw	a5,0(a7)
20402510:	000780e7          	jalr	a5
		if (ret < 0) {
20402514:	00054e63          	bltz	a0,20402530 <spi_sifive_init+0xf4>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
20402518:	00840413          	addi	s0,s0,8
2040251c:	f81ff06f          	j	2040249c <spi_sifive_init+0x60>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
20402520:	fff6c693          	not	a3,a3
20402524:	00f6f7b3          	and	a5,a3,a5
20402528:	fe1ff06f          	j	20402508 <spi_sifive_init+0xcc>
			return -ENODEV;
2040252c:	fed00513          	li	a0,-19
}
20402530:	01c12083          	lw	ra,28(sp)
20402534:	01812403          	lw	s0,24(sp)
20402538:	01412483          	lw	s1,20(sp)
2040253c:	01012903          	lw	s2,16(sp)
20402540:	00c12983          	lw	s3,12(sp)
20402544:	00812a03          	lw	s4,8(sp)
20402548:	00412a83          	lw	s5,4(sp)
2040254c:	00012b03          	lw	s6,0(sp)
20402550:	02010113          	addi	sp,sp,32
20402554:	00008067          	ret

20402558 <spi_config>:
	if (operation & SPI_MODE_LOOP) {
20402558:	000016b7          	lui	a3,0x1
2040255c:	80968793          	addi	a5,a3,-2039 # 809 <CONFIG_ISR_STACK_SIZE+0x9>
20402560:	00f677b3          	and	a5,a2,a5
20402564:	0c079863          	bnez	a5,20402634 <spi_config+0xdc>
	div = (SPI_CFG(dev)->f_sys / (frequency * 2U)) - 1;
20402568:	00452783          	lw	a5,4(a0)
2040256c:	00159593          	slli	a1,a1,0x1
	sys_write32((SF_SCKDIV_DIV_MASK & div), SPI_REG(dev, REG_SCKDIV));
20402570:	fff68693          	addi	a3,a3,-1
	div = (SPI_CFG(dev)->f_sys / (frequency * 2U)) - 1;
20402574:	0047a703          	lw	a4,4(a5)
20402578:	02b75733          	divu	a4,a4,a1
2040257c:	fff70713          	addi	a4,a4,-1
	sys_write32((SF_SCKDIV_DIV_MASK & div), SPI_REG(dev, REG_SCKDIV));
20402580:	00d77733          	and	a4,a4,a3
	return *(volatile uint32_t *)addr;
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
20402584:	0007a683          	lw	a3,0(a5)
20402588:	00e6a023          	sw	a4,0(a3)
	if (operation & SPI_MODE_CPOL) {
2040258c:	00267693          	andi	a3,a2,2
20402590:	0007a703          	lw	a4,0(a5)
20402594:	08068063          	beqz	a3,20402614 <spi_config+0xbc>
	uint32_t temp = *(volatile uint32_t *)addr;
20402598:	00472683          	lw	a3,4(a4)
	*(volatile uint32_t *)addr = temp | (1 << bit);
2040259c:	0026e693          	ori	a3,a3,2
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
204025a0:	00d72223          	sw	a3,4(a4)
	if (operation & SPI_MODE_CPHA) {
204025a4:	00467693          	andi	a3,a2,4
		sys_set_bit(SPI_REG(dev, REG_SCKMODE), SF_SCKMODE_PHA);
204025a8:	0007a703          	lw	a4,0(a5)
	if (operation & SPI_MODE_CPHA) {
204025ac:	06068a63          	beqz	a3,20402620 <spi_config+0xc8>
	uint32_t temp = *(volatile uint32_t *)addr;
204025b0:	00472683          	lw	a3,4(a4)
	*(volatile uint32_t *)addr = temp | (1 << bit);
204025b4:	0016e693          	ori	a3,a3,1
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
204025b8:	00d72223          	sw	a3,4(a4)
	sys_set_mask(SPI_REG(dev, REG_FMT), SF_FMT_LEN_MASK, fmt_len);
204025bc:	0007a583          	lw	a1,0(a5)
	temp &= ~(mask);
204025c0:	fff106b7          	lui	a3,0xfff10
204025c4:	fff68693          	addi	a3,a3,-1 # fff0ffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfff10000>
	return *(volatile uint32_t *)addr;
204025c8:	0405a703          	lw	a4,64(a1)
	fmt_len &= SF_FMT_LEN_MASK;
204025cc:	000f0537          	lui	a0,0xf0
	temp &= ~(mask);
204025d0:	00d776b3          	and	a3,a4,a3
	fmt_len &= SF_FMT_LEN_MASK;
204025d4:	00b61713          	slli	a4,a2,0xb
204025d8:	00a77733          	and	a4,a4,a0
	temp |= value;
204025dc:	00d76733          	or	a4,a4,a3
	*(volatile uint32_t *)addr = data;
204025e0:	04e5a023          	sw	a4,64(a1)
	sys_set_mask(SPI_REG(dev, REG_FMT),
204025e4:	0007a683          	lw	a3,0(a5)
	if (operation & SPI_TRANSFER_LSB) {
204025e8:	01067613          	andi	a2,a2,16
	return *(volatile uint32_t *)addr;
204025ec:	0406a703          	lw	a4,64(a3)
	temp &= ~(mask);
204025f0:	ffc77713          	andi	a4,a4,-4
	*(volatile uint32_t *)addr = data;
204025f4:	04e6a023          	sw	a4,64(a3)
	if (operation & SPI_TRANSFER_LSB) {
204025f8:	0007a783          	lw	a5,0(a5)
	uint32_t temp = *(volatile uint32_t *)addr;
204025fc:	0407a703          	lw	a4,64(a5)
20402600:	02060663          	beqz	a2,2040262c <spi_config+0xd4>
	*(volatile uint32_t *)addr = temp | (1 << bit);
20402604:	00476713          	ori	a4,a4,4
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
20402608:	04e7a023          	sw	a4,64(a5)
	return 0;
2040260c:	00000513          	li	a0,0
}
20402610:	00008067          	ret
	uint32_t temp = *(volatile uint32_t *)addr;
20402614:	00472683          	lw	a3,4(a4)
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
20402618:	ffd6f693          	andi	a3,a3,-3
2040261c:	f85ff06f          	j	204025a0 <spi_config+0x48>
	uint32_t temp = *(volatile uint32_t *)addr;
20402620:	00472683          	lw	a3,4(a4)
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
20402624:	ffe6f693          	andi	a3,a3,-2
20402628:	f91ff06f          	j	204025b8 <spi_config+0x60>
2040262c:	ffb77713          	andi	a4,a4,-5
20402630:	fd9ff06f          	j	20402608 <spi_config+0xb0>
		return -ENOTSUP;
20402634:	f7a00513          	li	a0,-134
}
20402638:	00008067          	ret

2040263c <spi_sifive_send>:
	while (sys_read32(SPI_REG(dev, REG_TXDATA)) & SF_TXDATA_FULL) {
2040263c:	00452783          	lw	a5,4(a0) # f0004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xe8004>
20402640:	0007a783          	lw	a5,0(a5)
20402644:	04878693          	addi	a3,a5,72
	return *(volatile uint32_t *)addr;
20402648:	0006a703          	lw	a4,0(a3)
2040264c:	fe074ee3          	bltz	a4,20402648 <spi_sifive_send+0xc>
	*(volatile uint32_t *)addr = data;
20402650:	04b7a423          	sw	a1,72(a5)
}
20402654:	00008067          	ret

20402658 <spi_sifive_recv>:
	while ((val = sys_read32(SPI_REG(dev, REG_RXDATA))) & SF_RXDATA_EMPTY) {
20402658:	00452783          	lw	a5,4(a0)
2040265c:	0007a783          	lw	a5,0(a5)
20402660:	04c78793          	addi	a5,a5,76
	return *(volatile uint32_t *)addr;
20402664:	0007a503          	lw	a0,0(a5)
20402668:	fe054ee3          	bltz	a0,20402664 <spi_sifive_recv+0xc>
}
2040266c:	01051513          	slli	a0,a0,0x10
20402670:	01055513          	srli	a0,a0,0x10
20402674:	00008067          	ret

20402678 <spi_sifive_xfer>:
{
20402678:	fd010113          	addi	sp,sp,-48
2040267c:	02812423          	sw	s0,40(sp)
	struct spi_context *ctx = &SPI_DATA(dev)->ctx;
20402680:	01052403          	lw	s0,16(a0)
{
20402684:	02912223          	sw	s1,36(sp)
20402688:	03212023          	sw	s2,32(sp)
2040268c:	01312e23          	sw	s3,28(sp)
20402690:	01412c23          	sw	s4,24(sp)
20402694:	01512a23          	sw	s5,20(sp)
20402698:	01612823          	sw	s6,16(sp)
2040269c:	01712623          	sw	s7,12(sp)
204026a0:	01812423          	sw	s8,8(sp)
204026a4:	02112623          	sw	ra,44(sp)
204026a8:	00050493          	mv	s1,a0
204026ac:	00058913          	mv	s2,a1
	if (!ctx->tx_len) {
		/* Current buffer is done. Get the next one to be processed. */
		++ctx->current_tx;
		--ctx->tx_count;
		ctx->tx_buf = (const uint8_t *)
			spi_context_get_next_buf(&ctx->current_tx,
204026b0:	04840993          	addi	s3,s0,72
204026b4:	03840a13          	addi	s4,s0,56
204026b8:	03440a93          	addi	s5,s0,52
	if (!ctx->rx_len) {
		/* Current buffer is done. Get the next one to be processed. */
		++ctx->current_rx;
		--ctx->rx_count;
		ctx->rx_buf = (uint8_t *)
			spi_context_get_next_buf(&ctx->current_rx,
204026bc:	05040b13          	addi	s6,s0,80
204026c0:	04040b93          	addi	s7,s0,64
204026c4:	03c40c13          	addi	s8,s0,60
	return !!(ctx->tx_buf && ctx->tx_len);
204026c8:	04442783          	lw	a5,68(s0)
			txd = 0U;
204026cc:	00000593          	li	a1,0
204026d0:	00078863          	beqz	a5,204026e0 <spi_sifive_xfer+0x68>
204026d4:	04842703          	lw	a4,72(s0)
204026d8:	00070463          	beqz	a4,204026e0 <spi_sifive_xfer+0x68>
			txd = *ctx->tx_buf;
204026dc:	0007c583          	lbu	a1,0(a5)
		spi_sifive_send(dev, txd);
204026e0:	00048513          	mv	a0,s1
204026e4:	f59ff0ef          	jal	ra,2040263c <spi_sifive_send>
	if (!ctx->tx_len) {
204026e8:	04842783          	lw	a5,72(s0)
204026ec:	02078e63          	beqz	a5,20402728 <spi_sifive_xfer+0xb0>
	ctx->tx_len -= len;
204026f0:	fff78793          	addi	a5,a5,-1
204026f4:	04f42423          	sw	a5,72(s0)
	if (!ctx->tx_len) {
204026f8:	0e079463          	bnez	a5,204027e0 <spi_sifive_xfer+0x168>
		++ctx->current_tx;
204026fc:	03442783          	lw	a5,52(s0)
			spi_context_get_next_buf(&ctx->current_tx,
20402700:	00098613          	mv	a2,s3
20402704:	000a0593          	mv	a1,s4
		++ctx->current_tx;
20402708:	00878793          	addi	a5,a5,8
2040270c:	02f42a23          	sw	a5,52(s0)
		--ctx->tx_count;
20402710:	03842783          	lw	a5,56(s0)
			spi_context_get_next_buf(&ctx->current_tx,
20402714:	000a8513          	mv	a0,s5
		--ctx->tx_count;
20402718:	fff78793          	addi	a5,a5,-1
2040271c:	02f42c23          	sw	a5,56(s0)
			spi_context_get_next_buf(&ctx->current_tx,
20402720:	b8dff0ef          	jal	ra,204022ac <spi_context_get_next_buf.constprop.0>
		ctx->tx_buf = (const uint8_t *)
20402724:	04a42223          	sw	a0,68(s0)
		rxd = spi_sifive_recv(dev);
20402728:	00048513          	mv	a0,s1
2040272c:	f2dff0ef          	jal	ra,20402658 <spi_sifive_recv>
}

static ALWAYS_INLINE
bool spi_context_rx_buf_on(struct spi_context *ctx)
{
	return !!(ctx->rx_buf && ctx->rx_len);
20402730:	04c42783          	lw	a5,76(s0)
20402734:	00078863          	beqz	a5,20402744 <spi_sifive_xfer+0xcc>
20402738:	05042703          	lw	a4,80(s0)
2040273c:	00070463          	beqz	a4,20402744 <spi_sifive_xfer+0xcc>
			*ctx->rx_buf = rxd;
20402740:	00a78023          	sb	a0,0(a5)
	if (!ctx->rx_len) {
20402744:	05042783          	lw	a5,80(s0)
20402748:	02078e63          	beqz	a5,20402784 <spi_sifive_xfer+0x10c>
	ctx->rx_len -= len;
2040274c:	fff78793          	addi	a5,a5,-1
20402750:	04f42823          	sw	a5,80(s0)
	if (!ctx->rx_len) {
20402754:	0a079063          	bnez	a5,204027f4 <spi_sifive_xfer+0x17c>
		++ctx->current_rx;
20402758:	03c42783          	lw	a5,60(s0)
			spi_context_get_next_buf(&ctx->current_rx,
2040275c:	000b0613          	mv	a2,s6
20402760:	000b8593          	mv	a1,s7
		++ctx->current_rx;
20402764:	00878793          	addi	a5,a5,8
20402768:	02f42e23          	sw	a5,60(s0)
		--ctx->rx_count;
2040276c:	04042783          	lw	a5,64(s0)
			spi_context_get_next_buf(&ctx->current_rx,
20402770:	000c0513          	mv	a0,s8
		--ctx->rx_count;
20402774:	fff78793          	addi	a5,a5,-1
20402778:	04f42023          	sw	a5,64(s0)
			spi_context_get_next_buf(&ctx->current_rx,
2040277c:	b31ff0ef          	jal	ra,204022ac <spi_context_get_next_buf.constprop.0>
		ctx->rx_buf = (uint8_t *)
20402780:	04a42623          	sw	a0,76(s0)
	} while (spi_context_tx_on(ctx) || spi_context_rx_on(ctx));
20402784:	04842783          	lw	a5,72(s0)
20402788:	f40790e3          	bnez	a5,204026c8 <spi_sifive_xfer+0x50>
2040278c:	05042783          	lw	a5,80(s0)
20402790:	f2079ce3          	bnez	a5,204026c8 <spi_sifive_xfer+0x50>
	if (!hw_cs_control) {
20402794:	06091a63          	bnez	s2,20402808 <spi_sifive_xfer+0x190>
	_spi_context_cs_control(ctx, on, false);
20402798:	0104a503          	lw	a0,16(s1)
2040279c:	00000613          	li	a2,0
204027a0:	00000593          	li	a1,0
204027a4:	b91ff0ef          	jal	ra,20402334 <_spi_context_cs_control>
	ctx->sync_status = status;
204027a8:	02042823          	sw	zero,48(s0)
204027ac:	02040513          	addi	a0,s0,32
}
204027b0:	02812403          	lw	s0,40(sp)
204027b4:	02c12083          	lw	ra,44(sp)
204027b8:	02412483          	lw	s1,36(sp)
204027bc:	02012903          	lw	s2,32(sp)
204027c0:	01c12983          	lw	s3,28(sp)
204027c4:	01812a03          	lw	s4,24(sp)
204027c8:	01412a83          	lw	s5,20(sp)
204027cc:	01012b03          	lw	s6,16(sp)
204027d0:	00c12b83          	lw	s7,12(sp)
204027d4:	00812c03          	lw	s8,8(sp)
204027d8:	03010113          	addi	sp,sp,48
204027dc:	2050006f          	j	204031e0 <z_impl_k_sem_give>
	} else if (ctx->tx_buf) {
204027e0:	04442783          	lw	a5,68(s0)
204027e4:	f40782e3          	beqz	a5,20402728 <spi_sifive_xfer+0xb0>
		ctx->tx_buf += dfs * len;
204027e8:	00178793          	addi	a5,a5,1
204027ec:	04f42223          	sw	a5,68(s0)
204027f0:	f39ff06f          	j	20402728 <spi_sifive_xfer+0xb0>
	} else if (ctx->rx_buf) {
204027f4:	04c42783          	lw	a5,76(s0)
204027f8:	f80786e3          	beqz	a5,20402784 <spi_sifive_xfer+0x10c>
		ctx->rx_buf += dfs * len;
204027fc:	00178793          	addi	a5,a5,1
20402800:	04f42623          	sw	a5,76(s0)
20402804:	f81ff06f          	j	20402784 <spi_sifive_xfer+0x10c>
		sys_write32(SF_CSMODE_OFF, SPI_REG(dev, REG_CSMODE));
20402808:	0044a783          	lw	a5,4(s1)
	*(volatile uint32_t *)addr = data;
2040280c:	00300713          	li	a4,3
20402810:	0007a783          	lw	a5,0(a5)
20402814:	00e7ac23          	sw	a4,24(a5)
}
20402818:	f91ff06f          	j	204027a8 <spi_sifive_xfer+0x130>

2040281c <spi_sifive_transceive>:
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
2040281c:	0045d783          	lhu	a5,4(a1)
{
20402820:	fe010113          	addi	sp,sp,-32
20402824:	00002737          	lui	a4,0x2
20402828:	00812c23          	sw	s0,24(sp)
2040282c:	00912a23          	sw	s1,20(sp)
20402830:	01212823          	sw	s2,16(sp)
20402834:	01312623          	sw	s3,12(sp)
20402838:	01412423          	sw	s4,8(sp)
2040283c:	00112e23          	sw	ra,28(sp)
20402840:	01512223          	sw	s5,4(sp)
20402844:	00e7f7b3          	and	a5,a5,a4
	spi_context_lock(&SPI_DATA(dev)->ctx, false, NULL, config);
20402848:	01052903          	lw	s2,16(a0)
{
2040284c:	00050493          	mv	s1,a0
20402850:	00058413          	mv	s0,a1
20402854:	00060a13          	mv	s4,a2
20402858:	00068993          	mv	s3,a3
2040285c:	0a079063          	bnez	a5,204028fc <spi_sifive_transceive+0xe0>
	return z_impl_k_sem_take(sem, timeout);
20402860:	fff00593          	li	a1,-1
20402864:	fff00613          	li	a2,-1
20402868:	01090513          	addi	a0,s2,16
2040286c:	1e1000ef          	jal	ra,2040324c <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
20402870:	00892223          	sw	s0,4(s2)
	SPI_DATA(dev)->ctx.config = config;
20402874:	0104a783          	lw	a5,16(s1)
	if (config->cs == NULL) {
20402878:	00842683          	lw	a3,8(s0)
	SPI_DATA(dev)->ctx.config = config;
2040287c:	0087a023          	sw	s0,0(a5)
		sys_write32(SF_CSMODE_OFF, SPI_REG(dev, REG_CSMODE));
20402880:	0044a783          	lw	a5,4(s1)
20402884:	0007a703          	lw	a4,0(a5)
	if (config->cs == NULL) {
20402888:	08068463          	beqz	a3,20402910 <spi_sifive_transceive+0xf4>
	*(volatile uint32_t *)addr = data;
2040288c:	00300793          	li	a5,3
20402890:	00f72c23          	sw	a5,24(a4) # 2018 <__kernel_ram_size+0xfd8>
	bool hw_cs_control = false;
20402894:	00000a93          	li	s5,0
	rc = spi_config(dev, config->frequency, config->operation);
20402898:	00445603          	lhu	a2,4(s0)
2040289c:	00042583          	lw	a1,0(s0)
204028a0:	00048513          	mv	a0,s1
204028a4:	cb5ff0ef          	jal	ra,20402558 <spi_config>
204028a8:	00050913          	mv	s2,a0
	if (rc < 0) {
204028ac:	0104a403          	lw	s0,16(s1)
204028b0:	06055e63          	bgez	a0,2040292c <spi_sifive_transceive+0x110>
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
204028b4:	00042783          	lw	a5,0(s0)
204028b8:	00002737          	lui	a4,0x2
204028bc:	0047d783          	lhu	a5,4(a5)
204028c0:	00e7f7b3          	and	a5,a5,a4
204028c4:	00079863          	bnez	a5,204028d4 <spi_sifive_transceive+0xb8>
		ctx->owner = NULL;
204028c8:	00042223          	sw	zero,4(s0)
	z_impl_k_sem_give(sem);
204028cc:	01040513          	addi	a0,s0,16
204028d0:	111000ef          	jal	ra,204031e0 <z_impl_k_sem_give>
}
204028d4:	01c12083          	lw	ra,28(sp)
204028d8:	01812403          	lw	s0,24(sp)
204028dc:	01412483          	lw	s1,20(sp)
204028e0:	00c12983          	lw	s3,12(sp)
204028e4:	00812a03          	lw	s4,8(sp)
204028e8:	00412a83          	lw	s5,4(sp)
204028ec:	00090513          	mv	a0,s2
204028f0:	01012903          	lw	s2,16(sp)
204028f4:	02010113          	addi	sp,sp,32
204028f8:	00008067          	ret
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
204028fc:	01892783          	lw	a5,24(s2)
20402900:	f60790e3          	bnez	a5,20402860 <spi_sifive_transceive+0x44>
		(k_sem_count_get(&ctx->lock) == 0) &&
20402904:	00492783          	lw	a5,4(s2)
20402908:	f4f59ce3          	bne	a1,a5,20402860 <spi_sifive_transceive+0x44>
2040290c:	f69ff06f          	j	20402874 <spi_sifive_transceive+0x58>
		sys_write32(config->slave, SPI_REG(dev, REG_CSID));
20402910:	00645683          	lhu	a3,6(s0)
		hw_cs_control = true;
20402914:	00100a93          	li	s5,1
20402918:	00d72823          	sw	a3,16(a4) # 2010 <__kernel_ram_size+0xfd0>
		sys_write32(SF_CSMODE_OFF, SPI_REG(dev, REG_CSMODE));
2040291c:	0007a783          	lw	a5,0(a5)
20402920:	00300713          	li	a4,3
20402924:	00e7ac23          	sw	a4,24(a5)
}
20402928:	f71ff06f          	j	20402898 <spi_sifive_transceive+0x7c>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
2040292c:	0e0a1e63          	bnez	s4,20402a28 <spi_sifive_transceive+0x20c>
20402930:	02042a23          	sw	zero,52(s0)
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
20402934:	00000793          	li	a5,0
20402938:	02f42c23          	sw	a5,56(s0)
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
2040293c:	04840613          	addi	a2,s0,72
20402940:	03840593          	addi	a1,s0,56
20402944:	03440513          	addi	a0,s0,52
20402948:	965ff0ef          	jal	ra,204022ac <spi_context_get_next_buf.constprop.0>
	ctx->tx_buf = (const uint8_t *)
2040294c:	04a42223          	sw	a0,68(s0)
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
20402950:	0e099863          	bnez	s3,20402a40 <spi_sifive_transceive+0x224>
20402954:	02042e23          	sw	zero,60(s0)
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
20402958:	00000793          	li	a5,0
2040295c:	04f42023          	sw	a5,64(s0)
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
20402960:	05040613          	addi	a2,s0,80
20402964:	04040593          	addi	a1,s0,64
20402968:	03c40513          	addi	a0,s0,60
2040296c:	941ff0ef          	jal	ra,204022ac <spi_context_get_next_buf.constprop.0>
	ctx->rx_buf = (uint8_t *)
20402970:	04a42623          	sw	a0,76(s0)
	ctx->sync_status = 0;
20402974:	02042823          	sw	zero,48(s0)
	if (!hw_cs_control) {
20402978:	0e0a9063          	bnez	s5,20402a58 <spi_sifive_transceive+0x23c>
	_spi_context_cs_control(ctx, on, false);
2040297c:	0104a503          	lw	a0,16(s1)
20402980:	00000613          	li	a2,0
20402984:	00100593          	li	a1,1
20402988:	9adff0ef          	jal	ra,20402334 <_spi_context_cs_control>
	spi_sifive_xfer(dev, hw_cs_control);
2040298c:	000a8593          	mv	a1,s5
20402990:	00048513          	mv	a0,s1
20402994:	ce5ff0ef          	jal	ra,20402678 <spi_sifive_xfer>
	rc = spi_context_wait_for_completion(&SPI_DATA(dev)->ctx);
20402998:	0104a403          	lw	s0,16(s1)
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
2040299c:	04842703          	lw	a4,72(s0)
204029a0:	05042783          	lw	a5,80(s0)
204029a4:	00e7f463          	bgeu	a5,a4,204029ac <spi_sifive_transceive+0x190>
204029a8:	00070793          	mv	a5,a4
204029ac:	00002737          	lui	a4,0x2
204029b0:	f4070713          	addi	a4,a4,-192 # 1f40 <__kernel_ram_size+0xf00>
204029b4:	02e787b3          	mul	a5,a5,a4
			     ctx->config->frequency;
204029b8:	00042703          	lw	a4,0(s0)
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
204029bc:	3e800613          	li	a2,1000
204029c0:	00000693          	li	a3,0
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
204029c4:	00072583          	lw	a1,0(a4)
204029c8:	02b7d7b3          	divu	a5,a5,a1
		timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
204029cc:	0c878793          	addi	a5,a5,200
204029d0:	0197d593          	srli	a1,a5,0x19
204029d4:	00779793          	slli	a5,a5,0x7
204029d8:	3e778513          	addi	a0,a5,999
204029dc:	00f537b3          	sltu	a5,a0,a5
204029e0:	00b785b3          	add	a1,a5,a1
204029e4:	901fd0ef          	jal	ra,204002e4 <__udivdi3>
204029e8:	00058613          	mv	a2,a1
204029ec:	00050593          	mv	a1,a0
	return z_impl_k_sem_take(sem, timeout);
204029f0:	02040513          	addi	a0,s0,32
204029f4:	059000ef          	jal	ra,2040324c <z_impl_k_sem_take>
		return -ETIMEDOUT;
204029f8:	f8c00913          	li	s2,-116
	if (k_sem_take(&ctx->sync, timeout)) {
204029fc:	00051463          	bnez	a0,20402a04 <spi_sifive_transceive+0x1e8>
	status = ctx->sync_status;
20402a00:	03042903          	lw	s2,48(s0)
	spi_context_release(&SPI_DATA(dev)->ctx, rc);
20402a04:	0104a503          	lw	a0,16(s1)
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
20402a08:	00002737          	lui	a4,0x2
20402a0c:	00052783          	lw	a5,0(a0)
20402a10:	0047d783          	lhu	a5,4(a5)
20402a14:	00e7f7b3          	and	a5,a5,a4
20402a18:	ea079ee3          	bnez	a5,204028d4 <spi_sifive_transceive+0xb8>
		ctx->owner = NULL;
20402a1c:	00052223          	sw	zero,4(a0)
	z_impl_k_sem_give(sem);
20402a20:	01050513          	addi	a0,a0,16
20402a24:	eadff06f          	j	204028d0 <spi_sifive_transceive+0xb4>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
20402a28:	000a2703          	lw	a4,0(s4)
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
20402a2c:	00000793          	li	a5,0
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
20402a30:	02e42a23          	sw	a4,52(s0)
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
20402a34:	f00702e3          	beqz	a4,20402938 <spi_sifive_transceive+0x11c>
20402a38:	004a2783          	lw	a5,4(s4)
20402a3c:	efdff06f          	j	20402938 <spi_sifive_transceive+0x11c>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
20402a40:	0009a703          	lw	a4,0(s3)
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
20402a44:	00000793          	li	a5,0
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
20402a48:	02e42e23          	sw	a4,60(s0)
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
20402a4c:	f00708e3          	beqz	a4,2040295c <spi_sifive_transceive+0x140>
20402a50:	0049a783          	lw	a5,4(s3)
20402a54:	f09ff06f          	j	2040295c <spi_sifive_transceive+0x140>
		sys_write32(SF_CSMODE_HOLD, SPI_REG(dev, REG_CSMODE));
20402a58:	0044a783          	lw	a5,4(s1)
	*(volatile uint32_t *)addr = data;
20402a5c:	00200713          	li	a4,2
20402a60:	0007a783          	lw	a5,0(a5)
20402a64:	00e7ac23          	sw	a4,24(a5)
}
20402a68:	f25ff06f          	j	2040298c <spi_sifive_transceive+0x170>

20402a6c <uart_sifive_poll_out>:
 * @param c Character to send
 */
static void uart_sifive_poll_out(const struct device *dev,
					 unsigned char c)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20402a6c:	00452783          	lw	a5,4(a0)
20402a70:	0007a783          	lw	a5,0(a5)

	/* Wait while TX FIFO is full */
	while (uart->tx & TXDATA_FULL) {
20402a74:	0007a703          	lw	a4,0(a5)
20402a78:	fe074ee3          	bltz	a4,20402a74 <uart_sifive_poll_out+0x8>
	}

	uart->tx = (int)c;
20402a7c:	00b7a023          	sw	a1,0(a5)
}
20402a80:	00008067          	ret

20402a84 <uart_sifive_poll_in>:
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_sifive_poll_in(const struct device *dev, unsigned char *c)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20402a84:	00452783          	lw	a5,4(a0)
20402a88:	0007a783          	lw	a5,0(a5)
	uint32_t val = uart->rx;
20402a8c:	0047a783          	lw	a5,4(a5)

	if (val & RXDATA_EMPTY) {
20402a90:	0007c863          	bltz	a5,20402aa0 <uart_sifive_poll_in+0x1c>
		return -1;
	}

	*c = (unsigned char)(val & RXDATA_MASK);
20402a94:	00f58023          	sb	a5,0(a1)

	return 0;
20402a98:	00000513          	li	a0,0
20402a9c:	00008067          	ret
		return -1;
20402aa0:	fff00513          	li	a0,-1
}
20402aa4:	00008067          	ret

20402aa8 <uart_sifive_init>:
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */


static int uart_sifive_init(const struct device *dev)
{
	const struct uart_sifive_device_config * const cfg = DEV_CFG(dev);
20402aa8:	00452683          	lw	a3,4(a0)
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);

	/* Enable TX and RX channels */
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20402aac:	000705b7          	lui	a1,0x70
	/* Setup IRQ handler */
	cfg->cfg_func();
#endif

	return 0;
}
20402ab0:	00000513          	li	a0,0
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20402ab4:	0106a703          	lw	a4,16(a3)
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20402ab8:	00c6a783          	lw	a5,12(a3)
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20402abc:	0006a603          	lw	a2,0(a3)
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20402ac0:	01071713          	slli	a4,a4,0x10
20402ac4:	00b77733          	and	a4,a4,a1
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20402ac8:	01079793          	slli	a5,a5,0x10
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20402acc:	00176713          	ori	a4,a4,1
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20402ad0:	00b7f7b3          	and	a5,a5,a1
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20402ad4:	00e62423          	sw	a4,8(a2)
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20402ad8:	0017e793          	ori	a5,a5,1
	uart->div = cfg->sys_clk_freq / cfg->baud_rate - 1;
20402adc:	0086a703          	lw	a4,8(a3)
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20402ae0:	00f62623          	sw	a5,12(a2)
	uart->div = cfg->sys_clk_freq / cfg->baud_rate - 1;
20402ae4:	0046a783          	lw	a5,4(a3)
20402ae8:	02e7d7b3          	divu	a5,a5,a4
20402aec:	fff78793          	addi	a5,a5,-1
20402af0:	00f62c23          	sw	a5,24(a2)
}
20402af4:	00008067          	ret

20402af8 <mtime>:
	volatile uint32_t *r = (uint32_t *)RISCV_MTIME_BASE;
	uint32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
20402af8:	0200c7b7          	lui	a5,0x200c
20402afc:	ffc7a703          	lw	a4,-4(a5) # 200bffc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2003ffc>
		lo = r[0];
20402b00:	ff87a503          	lw	a0,-8(a5)
	} while (r[1] != hi);
20402b04:	ffc7a583          	lw	a1,-4(a5)
20402b08:	fee59ae3          	bne	a1,a4,20402afc <mtime+0x4>

	return (((uint64_t)hi) << 32) | lo;
#endif
}
20402b0c:	00008067          	ret

20402b10 <timer_isr>:

static void timer_isr(const void *arg)
{
20402b10:	ff010113          	addi	sp,sp,-16
20402b14:	00812423          	sw	s0,8(sp)
20402b18:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20402b1c:	00800413          	li	s0,8
20402b20:	30043473          	csrrc	s0,mstatus,s0
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
20402b24:	fd5ff0ef          	jal	ra,20402af8 <mtime>
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
20402b28:	800006b7          	lui	a3,0x80000
20402b2c:	00068693          	mv	a3,a3
20402b30:	0006a783          	lw	a5,0(a3) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
20402b34:	0046a703          	lw	a4,4(a3)
	uint64_t now = mtime();
20402b38:	00050613          	mv	a2,a0
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
20402b3c:	40f507b3          	sub	a5,a0,a5
20402b40:	00f53533          	sltu	a0,a0,a5
20402b44:	40e58733          	sub	a4,a1,a4
20402b48:	40a70733          	sub	a4,a4,a0
20402b4c:	01871713          	slli	a4,a4,0x18
20402b50:	0087d513          	srli	a0,a5,0x8
20402b54:	00a76533          	or	a0,a4,a0

	last_count = now;
20402b58:	00c6a023          	sw	a2,0(a3)
20402b5c:	00b6a223          	sw	a1,4(a3)
	key = (mstatus & MSTATUS_IEN);
20402b60:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20402b64:	30042473          	csrrs	s0,mstatus,s0
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
20402b68:	00812403          	lw	s0,8(sp)
20402b6c:	00c12083          	lw	ra,12(sp)
20402b70:	01010113          	addi	sp,sp,16
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
20402b74:	33c0106f          	j	20403eb0 <sys_clock_announce>

20402b78 <sys_clock_driver_init>:
{
	return (mtime() << CONFIG_RISCV_MACHINE_TIMER_SYSTEM_CLOCK_DIVIDER);
}

static int sys_clock_driver_init(const struct device *dev)
{
20402b78:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(dev);

	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
20402b7c:	00000593          	li	a1,0
20402b80:	00700513          	li	a0,7
{
20402b84:	00112623          	sw	ra,12(sp)
	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
20402b88:	db9fe0ef          	jal	ra,20401940 <arch_irq_priority_set>
	last_count = mtime();
20402b8c:	f6dff0ef          	jal	ra,20402af8 <mtime>
20402b90:	800007b7          	lui	a5,0x80000
20402b94:	00078793          	mv	a5,a5
20402b98:	00a7a023          	sw	a0,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
20402b9c:	00b7a223          	sw	a1,4(a5)
	set_mtimecmp(last_count + CYC_PER_TICK);
20402ba0:	10050713          	addi	a4,a0,256
	r[1] = 0xffffffff;
20402ba4:	020047b7          	lui	a5,0x2004
20402ba8:	fff00693          	li	a3,-1
20402bac:	00d7a223          	sw	a3,4(a5) # 2004004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1ffc004>
	set_mtimecmp(last_count + CYC_PER_TICK);
20402bb0:	00a73533          	sltu	a0,a4,a0
20402bb4:	00b50533          	add	a0,a0,a1
	r[0] = (uint32_t)time;
20402bb8:	00e7a023          	sw	a4,0(a5)
	r[1] = (uint32_t)(time >> 32);
20402bbc:	00a7a223          	sw	a0,4(a5)
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
20402bc0:	00700513          	li	a0,7
20402bc4:	d35fe0ef          	jal	ra,204018f8 <arch_irq_enable>
	return 0;
}
20402bc8:	00c12083          	lw	ra,12(sp)
20402bcc:	00000513          	li	a0,0
20402bd0:	01010113          	addi	sp,sp,16
20402bd4:	00008067          	ret

20402bd8 <sys_clock_set_timeout>:
	if (idle) {
20402bd8:	0c059c63          	bnez	a1,20402cb0 <sys_clock_set_timeout+0xd8>
{
20402bdc:	ff010113          	addi	sp,sp,-16
20402be0:	00112623          	sw	ra,12(sp)
20402be4:	00812423          	sw	s0,8(sp)
20402be8:	00912223          	sw	s1,4(sp)
	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
20402bec:	fff00793          	li	a5,-1
20402bf0:	0af51463          	bne	a0,a5,20402c98 <sys_clock_set_timeout+0xc0>
20402bf4:	00800437          	lui	s0,0x800
20402bf8:	ffd40413          	addi	s0,s0,-3 # 7ffffd <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7f7ffd>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
20402bfc:	008007b7          	lui	a5,0x800
20402c00:	ffd78713          	addi	a4,a5,-3 # 7ffffd <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7f7ffd>
20402c04:	0a874263          	blt	a4,s0,20402ca8 <sys_clock_set_timeout+0xd0>
	__asm__ volatile ("csrrc %0, mstatus, %1"
20402c08:	00800493          	li	s1,8
20402c0c:	3004b4f3          	csrrc	s1,mstatus,s1
	uint64_t now = mtime();
20402c10:	ee9ff0ef          	jal	ra,20402af8 <mtime>
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
20402c14:	800007b7          	lui	a5,0x80000
20402c18:	00078793          	mv	a5,a5
20402c1c:	0007a703          	lw	a4,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
20402c20:	0047a603          	lw	a2,4(a5)
	if (cyc <= MAX_CYC - adj) {
20402c24:	800007b7          	lui	a5,0x80000
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
20402c28:	40e506b3          	sub	a3,a0,a4
20402c2c:	0ff68693          	addi	a3,a3,255
	if (cyc <= MAX_CYC - adj) {
20402c30:	fff7c793          	not	a5,a5
	uint32_t adj, cyc = ticks * CYC_PER_TICK;
20402c34:	00841413          	slli	s0,s0,0x8
	if (cyc <= MAX_CYC - adj) {
20402c38:	40d785b3          	sub	a1,a5,a3
	key = (mstatus & MSTATUS_IEN);
20402c3c:	0084f493          	andi	s1,s1,8
20402c40:	0085e463          	bltu	a1,s0,20402c48 <sys_clock_set_timeout+0x70>
		cyc += adj;
20402c44:	00d407b3          	add	a5,s0,a3
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
20402c48:	f007f793          	andi	a5,a5,-256
	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
20402c4c:	40a70533          	sub	a0,a4,a0
20402c50:	00f50533          	add	a0,a0,a5
20402c54:	3e700693          	li	a3,999
20402c58:	00a6c463          	blt	a3,a0,20402c60 <sys_clock_set_timeout+0x88>
		cyc += CYC_PER_TICK;
20402c5c:	10078793          	addi	a5,a5,256 # 80000100 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000101>
	set_mtimecmp(cyc + last_count);
20402c60:	00e78733          	add	a4,a5,a4
20402c64:	00f737b3          	sltu	a5,a4,a5
	r[1] = 0xffffffff;
20402c68:	020046b7          	lui	a3,0x2004
	set_mtimecmp(cyc + last_count);
20402c6c:	00c787b3          	add	a5,a5,a2
	r[1] = 0xffffffff;
20402c70:	fff00613          	li	a2,-1
20402c74:	00c6a223          	sw	a2,4(a3) # 2004004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1ffc004>
	r[0] = (uint32_t)time;
20402c78:	00e6a023          	sw	a4,0(a3)
	r[1] = (uint32_t)(time >> 32);
20402c7c:	00f6a223          	sw	a5,4(a3)
	__asm__ volatile ("csrrs %0, mstatus, %1"
20402c80:	3004a4f3          	csrrs	s1,mstatus,s1
}
20402c84:	00c12083          	lw	ra,12(sp)
20402c88:	00812403          	lw	s0,8(sp)
20402c8c:	00412483          	lw	s1,4(sp)
20402c90:	01010113          	addi	sp,sp,16
20402c94:	00008067          	ret
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
20402c98:	fff50413          	addi	s0,a0,-1
20402c9c:	f68040e3          	bgtz	s0,20402bfc <sys_clock_set_timeout+0x24>
20402ca0:	00000413          	li	s0,0
20402ca4:	f65ff06f          	j	20402c08 <sys_clock_set_timeout+0x30>
20402ca8:	ffe78413          	addi	s0,a5,-2
20402cac:	f5dff06f          	j	20402c08 <sys_clock_set_timeout+0x30>
20402cb0:	00008067          	ret

20402cb4 <sys_clock_elapsed>:
{
20402cb4:	ff010113          	addi	sp,sp,-16
20402cb8:	00812423          	sw	s0,8(sp)
20402cbc:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20402cc0:	00800413          	li	s0,8
20402cc4:	30043473          	csrrc	s0,mstatus,s0
	uint32_t ret = ((uint32_t)mtime() - (uint32_t)last_count) / CYC_PER_TICK;
20402cc8:	e31ff0ef          	jal	ra,20402af8 <mtime>
20402ccc:	800007b7          	lui	a5,0x80000
20402cd0:	0007a783          	lw	a5,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	key = (mstatus & MSTATUS_IEN);
20402cd4:	00847413          	andi	s0,s0,8
20402cd8:	40f50533          	sub	a0,a0,a5
20402cdc:	00855513          	srli	a0,a0,0x8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20402ce0:	30042473          	csrrs	s0,mstatus,s0
}
20402ce4:	00c12083          	lw	ra,12(sp)
20402ce8:	00812403          	lw	s0,8(sp)
20402cec:	01010113          	addi	sp,sp,16
20402cf0:	00008067          	ret

20402cf4 <sys_clock_cycle_get_32>:
{
20402cf4:	ff010113          	addi	sp,sp,-16
20402cf8:	00112623          	sw	ra,12(sp)
	return (uint32_t)(mtime() << CONFIG_RISCV_MACHINE_TIMER_SYSTEM_CLOCK_DIVIDER);
20402cfc:	dfdff0ef          	jal	ra,20402af8 <mtime>
}
20402d00:	00c12083          	lw	ra,12(sp)
20402d04:	01010113          	addi	sp,sp,16
20402d08:	00008067          	ret

20402d0c <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
20402d0c:	00008067          	ret

20402d10 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20402d10:	00251713          	slli	a4,a0,0x2
20402d14:	204047b7          	lui	a5,0x20404
20402d18:	00150513          	addi	a0,a0,1
20402d1c:	5c478793          	addi	a5,a5,1476 # 204045c4 <levels.0>
20402d20:	00251513          	slli	a0,a0,0x2
{
20402d24:	fe010113          	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20402d28:	00e78733          	add	a4,a5,a4
20402d2c:	00a78533          	add	a0,a5,a0
{
20402d30:	00812c23          	sw	s0,24(sp)
20402d34:	01212823          	sw	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20402d38:	00072403          	lw	s0,0(a4) # 2000 <__kernel_ram_size+0xfc0>
20402d3c:	00052903          	lw	s2,0(a0)
{
20402d40:	01312623          	sw	s3,12(sp)
20402d44:	00112e23          	sw	ra,28(sp)
20402d48:	00912a23          	sw	s1,20(sp)
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
20402d4c:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20402d50:	03246063          	bltu	s0,s2,20402d70 <z_sys_init_run_level+0x60>
			}
			dev->state->initialized = true;
		}
	}
}
20402d54:	01c12083          	lw	ra,28(sp)
20402d58:	01812403          	lw	s0,24(sp)
20402d5c:	01412483          	lw	s1,20(sp)
20402d60:	01012903          	lw	s2,16(sp)
20402d64:	00c12983          	lw	s3,12(sp)
20402d68:	02010113          	addi	sp,sp,32
20402d6c:	00008067          	ret
		const struct device *dev = entry->dev;
20402d70:	00442483          	lw	s1,4(s0)
		int rc = entry->init(dev);
20402d74:	00042783          	lw	a5,0(s0)
20402d78:	00048513          	mv	a0,s1
20402d7c:	000780e7          	jalr	a5
		if (dev != NULL) {
20402d80:	02048863          	beqz	s1,20402db0 <z_sys_init_run_level+0xa0>
				dev->state->init_res = rc;
20402d84:	00c4a783          	lw	a5,12(s1)
			if (rc != 0) {
20402d88:	00050e63          	beqz	a0,20402da4 <z_sys_init_run_level+0x94>
				if (rc < 0) {
20402d8c:	41f55713          	srai	a4,a0,0x1f
20402d90:	00a74533          	xor	a0,a4,a0
20402d94:	40e50533          	sub	a0,a0,a4
				dev->state->init_res = rc;
20402d98:	00a9d463          	bge	s3,a0,20402da0 <z_sys_init_run_level+0x90>
20402d9c:	0ff00513          	li	a0,255
20402da0:	00a78023          	sb	a0,0(a5)
			dev->state->initialized = true;
20402da4:	0007d703          	lhu	a4,0(a5)
20402da8:	10076713          	ori	a4,a4,256
20402dac:	00e79023          	sh	a4,0(a5)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20402db0:	00840413          	addi	s0,s0,8
20402db4:	f9dff06f          	j	20402d50 <z_sys_init_run_level+0x40>

20402db8 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
20402db8:	00050e63          	beqz	a0,20402dd4 <z_device_ready+0x1c>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
20402dbc:	00c52783          	lw	a5,12(a0)
20402dc0:	0007a503          	lw	a0,0(a5)
20402dc4:	1ff57513          	andi	a0,a0,511
20402dc8:	f0050513          	addi	a0,a0,-256
20402dcc:	00153513          	seqz	a0,a0
20402dd0:	00008067          	ret
		return false;
20402dd4:	00000513          	li	a0,0
}
20402dd8:	00008067          	ret

20402ddc <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20402ddc:	00800793          	li	a5,8
20402de0:	3007b7f3          	csrrc	a5,mstatus,a5
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
20402de4:	0000006f          	j	20402de4 <arch_system_halt+0x8>

20402de8 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
20402de8:	ff010113          	addi	sp,sp,-16
20402dec:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
20402df0:	fedff0ef          	jal	ra,20402ddc <arch_system_halt>

20402df4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
20402df4:	fe010113          	addi	sp,sp,-32
20402df8:	00812c23          	sw	s0,24(sp)
20402dfc:	01212823          	sw	s2,16(sp)
20402e00:	00112e23          	sw	ra,28(sp)
20402e04:	00912a23          	sw	s1,20(sp)
20402e08:	00050913          	mv	s2,a0
20402e0c:	00b12623          	sw	a1,12(sp)
20402e10:	00800413          	li	s0,8
20402e14:	30043473          	csrrc	s0,mstatus,s0
	return z_impl_z_current_get();
20402e18:	435000ef          	jal	ra,20403a4c <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
20402e1c:	00c12583          	lw	a1,12(sp)
20402e20:	00050493          	mv	s1,a0
20402e24:	00090513          	mv	a0,s2
20402e28:	fc1ff0ef          	jal	ra,20402de8 <k_sys_fatal_error_handler>
	key = (mstatus & MSTATUS_IEN);
20402e2c:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20402e30:	30042473          	csrrs	s0,mstatus,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
20402e34:	01812403          	lw	s0,24(sp)
20402e38:	01c12083          	lw	ra,28(sp)
20402e3c:	01012903          	lw	s2,16(sp)
	z_impl_k_thread_abort(thread);
20402e40:	00048513          	mv	a0,s1
20402e44:	01412483          	lw	s1,20(sp)
20402e48:	02010113          	addi	sp,sp,32
20402e4c:	5010006f          	j	20403b4c <z_impl_k_thread_abort>

20402e50 <init_idle_thread>:
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
20402e50:	01800693          	li	a3,24
20402e54:	02d506b3          	mul	a3,a0,a3
{
20402e58:	fe010113          	addi	sp,sp,-32
20402e5c:	00812c23          	sw	s0,24(sp)
	z_setup_new_thread(thread, stack,
20402e60:	80000737          	lui	a4,0x80000
	struct k_thread *thread = &z_idle_threads[i];
20402e64:	80000437          	lui	s0,0x80000
	k_thread_stack_t *stack = z_idle_stacks[i];
20402e68:	00951313          	slli	t1,a0,0x9
	struct k_thread *thread = &z_idle_threads[i];
20402e6c:	02840413          	addi	s0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
20402e70:	00751513          	slli	a0,a0,0x7
	z_setup_new_thread(thread, stack,
20402e74:	13470713          	addi	a4,a4,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
20402e78:	800005b7          	lui	a1,0x80000
	struct k_thread *thread = &z_idle_threads[i];
20402e7c:	00a40433          	add	s0,s0,a0
	z_setup_new_thread(thread, stack,
20402e80:	00100793          	li	a5,1
20402e84:	00d70733          	add	a4,a4,a3
20402e88:	56058593          	addi	a1,a1,1376 # 80000560 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000561>
20402e8c:	204036b7          	lui	a3,0x20403
20402e90:	00f12023          	sw	a5,0(sp)
20402e94:	00012223          	sw	zero,4(sp)
20402e98:	00000793          	li	a5,0
20402e9c:	00040513          	mv	a0,s0
20402ea0:	00f00893          	li	a7,15
20402ea4:	00000813          	li	a6,0
20402ea8:	1c468693          	addi	a3,a3,452 # 204031c4 <idle>
20402eac:	20000613          	li	a2,512
20402eb0:	006585b3          	add	a1,a1,t1
{
20402eb4:	00112e23          	sw	ra,28(sp)
	z_setup_new_thread(thread, stack,
20402eb8:	168000ef          	jal	ra,20403020 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
20402ebc:	00d44783          	lbu	a5,13(s0)
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
20402ec0:	01c12083          	lw	ra,28(sp)
20402ec4:	ffb7f793          	andi	a5,a5,-5
20402ec8:	00f406a3          	sb	a5,13(s0)
20402ecc:	01812403          	lw	s0,24(sp)
20402ed0:	02010113          	addi	sp,sp,32
20402ed4:	00008067          	ret

20402ed8 <bg_thread_main>:
{
20402ed8:	ff010113          	addi	sp,sp,-16
	z_sys_post_kernel = true;
20402edc:	800007b7          	lui	a5,0x80000
20402ee0:	00100713          	li	a4,1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
20402ee4:	00200513          	li	a0,2
{
20402ee8:	00112623          	sw	ra,12(sp)
	z_sys_post_kernel = true;
20402eec:	02e78223          	sb	a4,36(a5) # 80000024 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000025>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
20402ef0:	e21ff0ef          	jal	ra,20402d10 <z_sys_init_run_level>
	boot_banner();
20402ef4:	154010ef          	jal	ra,20404048 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
20402ef8:	00300513          	li	a0,3
20402efc:	e15ff0ef          	jal	ra,20402d10 <z_sys_init_run_level>
	z_init_static_threads();
20402f00:	1a4000ef          	jal	ra,204030a4 <z_init_static_threads>
	main();
20402f04:	c1dfd0ef          	jal	ra,20400b20 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
20402f08:	800007b7          	lui	a5,0x80000
20402f0c:	0a878793          	addi	a5,a5,168 # 800000a8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800000a9>
20402f10:	00c7c703          	lbu	a4,12(a5)
20402f14:	ffe77713          	andi	a4,a4,-2
20402f18:	00e78623          	sb	a4,12(a5)
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
20402f1c:	00c12083          	lw	ra,12(sp)
20402f20:	01010113          	addi	sp,sp,16
20402f24:	00008067          	ret

20402f28 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
20402f28:	80000537          	lui	a0,0x80000
20402f2c:	800007b7          	lui	a5,0x80000
20402f30:	00050613          	mv	a2,a0
20402f34:	15878793          	addi	a5,a5,344 # 80000158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000159>
20402f38:	40c78633          	sub	a2,a5,a2
20402f3c:	00000593          	li	a1,0
20402f40:	00050513          	mv	a0,a0
20402f44:	b69fe06f          	j	20401aac <memset>

20402f48 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
20402f48:	f6010113          	addi	sp,sp,-160
20402f4c:	08812c23          	sw	s0,152(sp)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
20402f50:	10100793          	li	a5,257
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
20402f54:	80000437          	lui	s0,0x80000
20402f58:	13440413          	addi	s0,s0,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
	dummy_thread->base.user_options = K_ESSENTIAL;
20402f5c:	00f11e23          	sh	a5,28(sp)
	_current_cpu->current = dummy_thread;
20402f60:	01010793          	addi	a5,sp,16
20402f64:	08112e23          	sw	ra,156(sp)
20402f68:	00f42423          	sw	a5,8(s0)
20402f6c:	08912a23          	sw	s1,148(sp)
20402f70:	09212823          	sw	s2,144(sp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
20402f74:	d99ff0ef          	jal	ra,20402d0c <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
20402f78:	00000513          	li	a0,0
20402f7c:	d95ff0ef          	jal	ra,20402d10 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
20402f80:	00100513          	li	a0,1
20402f84:	d8dff0ef          	jal	ra,20402d10 <z_sys_init_run_level>
	z_sched_init();
20402f88:	2a1000ef          	jal	ra,20403a28 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20402f8c:	204047b7          	lui	a5,0x20404
20402f90:	5d878793          	addi	a5,a5,1496 # 204045d8 <levels.0+0x14>
	_kernel.ready_q.cache = &z_main_thread;
20402f94:	800004b7          	lui	s1,0x80000
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20402f98:	00f12223          	sw	a5,4(sp)
20402f9c:	204036b7          	lui	a3,0x20403
20402fa0:	00100793          	li	a5,1
20402fa4:	800005b7          	lui	a1,0x80000
	_kernel.ready_q.cache = &z_main_thread;
20402fa8:	0a848913          	addi	s2,s1,168 # 800000a8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800000a9>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20402fac:	00000893          	li	a7,0
20402fb0:	00000813          	li	a6,0
20402fb4:	00000713          	li	a4,0
20402fb8:	ed868693          	addi	a3,a3,-296 # 20402ed8 <bg_thread_main>
20402fbc:	40000613          	li	a2,1024
20402fc0:	16058593          	addi	a1,a1,352 # 80000160 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000161>
20402fc4:	00f12023          	sw	a5,0(sp)
20402fc8:	0a848513          	addi	a0,s1,168
20402fcc:	00000793          	li	a5,0
	_kernel.ready_q.cache = &z_main_thread;
20402fd0:	01242c23          	sw	s2,24(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20402fd4:	04c000ef          	jal	ra,20403020 <z_setup_new_thread>
20402fd8:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
20402fdc:	0a848513          	addi	a0,s1,168
20402fe0:	ffb7f793          	andi	a5,a5,-5
20402fe4:	00f906a3          	sb	a5,13(s2)
20402fe8:	71c000ef          	jal	ra,20403704 <z_ready_thread>
		init_idle_thread(i);
20402fec:	00000513          	li	a0,0
20402ff0:	e61ff0ef          	jal	ra,20402e50 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
20402ff4:	800007b7          	lui	a5,0x80000
20402ff8:	02878793          	addi	a5,a5,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
20402ffc:	00f42623          	sw	a5,12(s0)
		_kernel.cpus[i].irq_stack =
20403000:	800017b7          	lui	a5,0x80001
20403004:	f6078793          	addi	a5,a5,-160 # 80000f60 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000f61>
		_kernel.cpus[i].id = i;
20403008:	00040a23          	sb	zero,20(s0)
		_kernel.cpus[i].irq_stack =
2040300c:	00f42223          	sw	a5,4(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403010:	00800513          	li	a0,8
20403014:	30053573          	csrrc	a0,mstatus,a0
	ret = arch_swap(key);
20403018:	00857513          	andi	a0,a0,8
2040301c:	aa4fd0ef          	jal	ra,204002c0 <arch_swap>

20403020 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
20403020:	ff010113          	addi	sp,sp,-16
20403024:	00812423          	sw	s0,8(sp)
20403028:	00912223          	sw	s1,4(sp)
2040302c:	00112623          	sw	ra,12(sp)
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
20403030:	06850313          	addi	t1,a0,104 # 80000068 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000069>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
20403034:	06652423          	sw	t1,104(a0)
	list->tail = (sys_dnode_t *)list;
20403038:	06652623          	sw	t1,108(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
2040303c:	01012303          	lw	t1,16(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
20403040:	00f60613          	addi	a2,a2,15
20403044:	ff067613          	andi	a2,a2,-16
	stack_ptr = (char *)stack + stack_obj_size;
20403048:	00c584b3          	add	s1,a1,a2
	thread_base->user_options = (uint8_t)options;
2040304c:	00650623          	sb	t1,12(a0)
	thread_base->thread_state = (uint8_t)initial_state;
20403050:	00400313          	li	t1,4
	thread_base->pended_on = NULL;
20403054:	00052423          	sw	zero,8(a0)
	thread_base->thread_state = (uint8_t)initial_state;
20403058:	006506a3          	sb	t1,13(a0)

	thread_base->prio = priority;
2040305c:	01150723          	sb	a7,14(a0)

	thread_base->sched_locked = 0U;
20403060:	000507a3          	sb	zero,15(a0)
 * @return N/A
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
20403064:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
20403068:	00052e23          	sw	zero,28(a0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
2040306c:	00048613          	mv	a2,s1
{
20403070:	00050413          	mv	s0,a0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
20403074:	999fe0ef          	jal	ra,20401a0c <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
20403078:	800007b7          	lui	a5,0x80000
2040307c:	13c7a783          	lw	a5,316(a5) # 8000013c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000013d>
}
20403080:	00c12083          	lw	ra,12(sp)
	new_thread->init_data = NULL;
20403084:	06042223          	sw	zero,100(s0)
	new_thread->resource_pool = _current->resource_pool;
20403088:	0747a783          	lw	a5,116(a5)
}
2040308c:	00048513          	mv	a0,s1
20403090:	00412483          	lw	s1,4(sp)
	new_thread->resource_pool = _current->resource_pool;
20403094:	06f42a23          	sw	a5,116(s0)
}
20403098:	00812403          	lw	s0,8(sp)
2040309c:	01010113          	addi	sp,sp,16
204030a0:	00008067          	ret

204030a4 <z_init_static_threads>:
{
204030a4:	fd010113          	addi	sp,sp,-48
204030a8:	03212023          	sw	s2,32(sp)
204030ac:	02812423          	sw	s0,40(sp)
204030b0:	02912223          	sw	s1,36(sp)
204030b4:	02112623          	sw	ra,44(sp)
204030b8:	01312e23          	sw	s3,28(sp)
204030bc:	01412c23          	sw	s4,24(sp)
204030c0:	01512a23          	sw	s5,20(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
204030c4:	83818413          	addi	s0,gp,-1992 # 80001040 <__data_region_end>
204030c8:	83818493          	addi	s1,gp,-1992 # 80001040 <__data_region_end>
204030cc:	83818913          	addi	s2,gp,-1992 # 80001040 <__data_region_end>
204030d0:	05246063          	bltu	s0,s2,20403110 <z_init_static_threads+0x6c>
	_FOREACH_STATIC_THREAD(thread_data) {
204030d4:	00048413          	mv	s0,s1
	k_sched_lock();
204030d8:	36c000ef          	jal	ra,20403444 <k_sched_lock>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
204030dc:	fff00493          	li	s1,-1
204030e0:	3e700993          	li	s3,999

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
204030e4:	20403a37          	lui	s4,0x20403
	_FOREACH_STATIC_THREAD(thread_data) {
204030e8:	07246663          	bltu	s0,s2,20403154 <z_init_static_threads+0xb0>
}
204030ec:	02812403          	lw	s0,40(sp)
204030f0:	02c12083          	lw	ra,44(sp)
204030f4:	02412483          	lw	s1,36(sp)
204030f8:	02012903          	lw	s2,32(sp)
204030fc:	01c12983          	lw	s3,28(sp)
20403100:	01812a03          	lw	s4,24(sp)
20403104:	01412a83          	lw	s5,20(sp)
20403108:	03010113          	addi	sp,sp,48
	k_sched_unlock();
2040310c:	0850006f          	j	20403990 <k_sched_unlock>
		z_setup_new_thread(
20403110:	02c42783          	lw	a5,44(s0)
20403114:	00f12223          	sw	a5,4(sp)
20403118:	02042783          	lw	a5,32(s0)
2040311c:	00f12023          	sw	a5,0(sp)
20403120:	01442783          	lw	a5,20(s0)
20403124:	01c42883          	lw	a7,28(s0)
20403128:	01842803          	lw	a6,24(s0)
2040312c:	01042703          	lw	a4,16(s0)
20403130:	00c42683          	lw	a3,12(s0)
20403134:	00842603          	lw	a2,8(s0)
20403138:	00442583          	lw	a1,4(s0)
2040313c:	00042503          	lw	a0,0(s0)
20403140:	ee1ff0ef          	jal	ra,20403020 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
20403144:	00042783          	lw	a5,0(s0)
20403148:	0687a223          	sw	s0,100(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
2040314c:	03040413          	addi	s0,s0,48
20403150:	f81ff06f          	j	204030d0 <z_init_static_threads+0x2c>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
20403154:	02442783          	lw	a5,36(s0)
20403158:	04978063          	beq	a5,s1,20403198 <z_init_static_threads+0xf4>
			schedule_new_thread(thread_data->init_thread,
2040315c:	00042a83          	lw	s5,0(s0)
					    K_MSEC(thread_data->init_delay));
20403160:	0007d463          	bgez	a5,20403168 <z_init_static_threads+0xc4>
20403164:	00000793          	li	a5,0
20403168:	41f7d593          	srai	a1,a5,0x1f
2040316c:	0197d713          	srli	a4,a5,0x19
20403170:	00779793          	slli	a5,a5,0x7
20403174:	00759593          	slli	a1,a1,0x7
20403178:	3e778513          	addi	a0,a5,999
2040317c:	00b765b3          	or	a1,a4,a1
20403180:	00f537b3          	sltu	a5,a0,a5
20403184:	00b785b3          	add	a1,a5,a1
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
20403188:	01351c63          	bne	a0,s3,204031a0 <z_init_static_threads+0xfc>
2040318c:	00059a63          	bnez	a1,204031a0 <z_init_static_threads+0xfc>
	z_sched_start(thread);
20403190:	000a8513          	mv	a0,s5
20403194:	5a0000ef          	jal	ra,20403734 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
20403198:	03040413          	addi	s0,s0,48
2040319c:	f4dff06f          	j	204030e8 <z_init_static_threads+0x44>
204031a0:	3e800613          	li	a2,1000
204031a4:	00000693          	li	a3,0
204031a8:	93cfd0ef          	jal	ra,204002e4 <__udivdi3>
204031ac:	00050613          	mv	a2,a0
204031b0:	00058693          	mv	a3,a1
204031b4:	018a8513          	addi	a0,s5,24
204031b8:	784a0593          	addi	a1,s4,1924 # 20403784 <z_thread_timeout>
204031bc:	2ad000ef          	jal	ra,20403c68 <z_add_timeout>
204031c0:	fd9ff06f          	j	20403198 <z_init_static_threads+0xf4>

204031c4 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
204031c4:	ff010113          	addi	sp,sp,-16
204031c8:	00812423          	sw	s0,8(sp)
204031cc:	00112623          	sw	ra,12(sp)
204031d0:	00800413          	li	s0,8
204031d4:	300437f3          	csrrc	a5,mstatus,s0
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
204031d8:	efcfe0ef          	jal	ra,204018d4 <arch_cpu_idle>
204031dc:	ff9ff06f          	j	204031d4 <idle+0x10>

204031e0 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
204031e0:	ff010113          	addi	sp,sp,-16
204031e4:	00812423          	sw	s0,8(sp)
204031e8:	00912223          	sw	s1,4(sp)
204031ec:	00112623          	sw	ra,12(sp)
204031f0:	00050493          	mv	s1,a0
204031f4:	00800413          	li	s0,8
204031f8:	30043473          	csrrc	s0,mstatus,s0
	key = (mstatus & MSTATUS_IEN);
204031fc:	00847413          	andi	s0,s0,8
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
20403200:	7d8000ef          	jal	ra,204039d8 <z_unpend_first_thread>

	if (thread != NULL) {
20403204:	02050663          	beqz	a0,20403230 <z_impl_k_sem_give+0x50>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
20403208:	06052c23          	sw	zero,120(a0)
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
2040320c:	4f8000ef          	jal	ra,20403704 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
20403210:	00040593          	mv	a1,s0

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
20403214:	00812403          	lw	s0,8(sp)
20403218:	00c12083          	lw	ra,12(sp)
2040321c:	00412483          	lw	s1,4(sp)
	z_reschedule(&lock, key);
20403220:	80000537          	lui	a0,0x80000
20403224:	15850513          	addi	a0,a0,344 # 80000158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000159>
}
20403228:	01010113          	addi	sp,sp,16
	z_reschedule(&lock, key);
2040322c:	1b40006f          	j	204033e0 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
20403230:	0084a703          	lw	a4,8(s1)
20403234:	00c4a783          	lw	a5,12(s1)
20403238:	40e787b3          	sub	a5,a5,a4
2040323c:	00f037b3          	snez	a5,a5
20403240:	00e787b3          	add	a5,a5,a4
20403244:	00f4a423          	sw	a5,8(s1)
}
20403248:	fc9ff06f          	j	20403210 <z_impl_k_sem_give+0x30>

2040324c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
2040324c:	00058693          	mv	a3,a1
20403250:	00060713          	mv	a4,a2
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403254:	00800793          	li	a5,8
20403258:	3007b7f3          	csrrc	a5,mstatus,a5
	key = (mstatus & MSTATUS_IEN);
2040325c:	0087f593          	andi	a1,a5,8

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
20403260:	00852783          	lw	a5,8(a0)
20403264:	00078c63          	beqz	a5,2040327c <z_impl_k_sem_take+0x30>
		sem->count--;
20403268:	fff78793          	addi	a5,a5,-1
2040326c:	00f52423          	sw	a5,8(a0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403270:	3005a5f3          	csrrs	a1,mstatus,a1
		k_spin_unlock(&lock, key);
		ret = 0;
20403274:	00000513          	li	a0,0
		goto out;
20403278:	00008067          	ret
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
2040327c:	00c6e7b3          	or	a5,a3,a2
20403280:	00079863          	bnez	a5,20403290 <z_impl_k_sem_take+0x44>
20403284:	3005a5f3          	csrrs	a1,mstatus,a1
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
20403288:	ff000513          	li	a0,-16

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
2040328c:	00008067          	ret
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
20403290:	00050613          	mv	a2,a0
20403294:	80000537          	lui	a0,0x80000
20403298:	15850513          	addi	a0,a0,344 # 80000158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000159>
2040329c:	6b80006f          	j	20403954 <z_pend_curr>

204032a0 <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
204032a0:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
204032a4:	00052783          	lw	a5,0(a0)

	prev->next = next;
204032a8:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
204032ac:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
204032b0:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
204032b4:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
204032b8:	00008067          	ret

204032bc <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
204032bc:	ff010113          	addi	sp,sp,-16
204032c0:	00812423          	sw	s0,8(sp)
204032c4:	00112623          	sw	ra,12(sp)
204032c8:	00050413          	mv	s0,a0

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
204032cc:	fd5ff0ef          	jal	ra,204032a0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
204032d0:	00d44783          	lbu	a5,13(s0)
}
204032d4:	00c12083          	lw	ra,12(sp)
	thread->base.pended_on = NULL;
204032d8:	00042423          	sw	zero,8(s0)
204032dc:	ffd7f793          	andi	a5,a5,-3
204032e0:	00f406a3          	sb	a5,13(s0)
}
204032e4:	00812403          	lw	s0,8(sp)
204032e8:	01010113          	addi	sp,sp,16
204032ec:	00008067          	ret

204032f0 <z_reset_time_slice>:
{
204032f0:	ff010113          	addi	sp,sp,-16
204032f4:	00812423          	sw	s0,8(sp)
	if (slice_time != 0) {
204032f8:	80000437          	lui	s0,0x80000
204032fc:	01c40413          	addi	s0,s0,28 # 8000001c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000001d>
20403300:	00042783          	lw	a5,0(s0)
{
20403304:	00112623          	sw	ra,12(sp)
	if (slice_time != 0) {
20403308:	02078863          	beqz	a5,20403338 <z_reset_time_slice+0x48>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
2040330c:	9a9ff0ef          	jal	ra,20402cb4 <sys_clock_elapsed>
20403310:	00050793          	mv	a5,a0
20403314:	00042503          	lw	a0,0(s0)
}
20403318:	00812403          	lw	s0,8(sp)
2040331c:	00c12083          	lw	ra,12(sp)
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
20403320:	00f507b3          	add	a5,a0,a5
20403324:	80000737          	lui	a4,0x80000
20403328:	14f72223          	sw	a5,324(a4) # 80000144 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000145>
		z_set_timeout_expiry(slice_time, false);
2040332c:	00000593          	li	a1,0
}
20403330:	01010113          	addi	sp,sp,16
		z_set_timeout_expiry(slice_time, false);
20403334:	3250006f          	j	20403e58 <z_set_timeout_expiry>
}
20403338:	00c12083          	lw	ra,12(sp)
2040333c:	00812403          	lw	s0,8(sp)
20403340:	01010113          	addi	sp,sp,16
20403344:	00008067          	ret

20403348 <k_sched_time_slice_set>:
{
20403348:	ff010113          	addi	sp,sp,-16
2040334c:	00812423          	sw	s0,8(sp)
20403350:	00912223          	sw	s1,4(sp)
20403354:	01212023          	sw	s2,0(sp)
20403358:	00112623          	sw	ra,12(sp)
2040335c:	00050493          	mv	s1,a0
20403360:	00058913          	mv	s2,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403364:	00800413          	li	s0,8
20403368:	30043473          	csrrc	s0,mstatus,s0
		_current_cpu->slice_ticks = 0;
2040336c:	800007b7          	lui	a5,0x80000
20403370:	1407a223          	sw	zero,324(a5) # 80000144 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000145>
			return (uint32_t)((t * to_hz + off) / from_hz);
20403374:	00751793          	slli	a5,a0,0x7
20403378:	01955593          	srli	a1,a0,0x19
2040337c:	3e778513          	addi	a0,a5,999
20403380:	00f537b3          	sltu	a5,a0,a5
20403384:	00b785b3          	add	a1,a5,a1
20403388:	3e800613          	li	a2,1000
2040338c:	00000693          	li	a3,0
20403390:	f55fc0ef          	jal	ra,204002e4 <__udivdi3>
20403394:	800007b7          	lui	a5,0x80000
	key = (mstatus & MSTATUS_IEN);
20403398:	00847413          	andi	s0,s0,8
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
2040339c:	01c78793          	addi	a5,a5,28 # 8000001c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000001d>
204033a0:	02904863          	bgtz	s1,204033d0 <k_sched_time_slice_set+0x88>
			slice_time = MAX(2, slice_time);
204033a4:	00a7a023          	sw	a0,0(a5)
		slice_max_prio = prio;
204033a8:	800007b7          	lui	a5,0x80000
204033ac:	0127ac23          	sw	s2,24(a5) # 80000018 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000019>
		z_reset_time_slice();
204033b0:	f41ff0ef          	jal	ra,204032f0 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204033b4:	30042473          	csrrs	s0,mstatus,s0
}
204033b8:	00c12083          	lw	ra,12(sp)
204033bc:	00812403          	lw	s0,8(sp)
204033c0:	00412483          	lw	s1,4(sp)
204033c4:	00012903          	lw	s2,0(sp)
204033c8:	01010113          	addi	sp,sp,16
204033cc:	00008067          	ret
			slice_time = MAX(2, slice_time);
204033d0:	00200713          	li	a4,2
204033d4:	fce558e3          	bge	a0,a4,204033a4 <k_sched_time_slice_set+0x5c>
204033d8:	00200513          	li	a0,2
204033dc:	fc9ff06f          	j	204033a4 <k_sched_time_slice_set+0x5c>

204033e0 <z_reschedule>:
	 * have the single bit set).  But there is a mask applied to
	 * the argument in arch_irq_unlock() that has me worried
	 * that something elseswhere might try to set a bit?  Do it
	 * the safe way for now.
	 */
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
204033e0:	0085f713          	andi	a4,a1,8
{
204033e4:	00058513          	mv	a0,a1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
204033e8:	02070263          	beqz	a4,2040340c <z_reschedule+0x2c>
FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf);

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
204033ec:	800007b7          	lui	a5,0x80000
204033f0:	13478793          	addi	a5,a5,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
	if (resched(key.key) && need_swap()) {
204033f4:	0007a683          	lw	a3,0(a5)
204033f8:	00069a63          	bnez	a3,2040340c <z_reschedule+0x2c>
204033fc:	0187a683          	lw	a3,24(a5)
20403400:	0087a783          	lw	a5,8(a5)
20403404:	00f68463          	beq	a3,a5,2040340c <z_reschedule+0x2c>
20403408:	eb9fc06f          	j	204002c0 <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
2040340c:	30072773          	csrrs	a4,mstatus,a4
}
20403410:	00008067          	ret

20403414 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
20403414:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
20403418:	00078a63          	beqz	a5,2040342c <z_reschedule_irqlock+0x18>
	if (resched(key)) {
2040341c:	80000737          	lui	a4,0x80000
20403420:	13472703          	lw	a4,308(a4) # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
20403424:	00071463          	bnez	a4,2040342c <z_reschedule_irqlock+0x18>
20403428:	e99fc06f          	j	204002c0 <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
2040342c:	3007a7f3          	csrrs	a5,mstatus,a5
}
20403430:	00008067          	ret

20403434 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403434:	00800513          	li	a0,8
20403438:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(arch_irq_lock());
2040343c:	00857513          	andi	a0,a0,8
20403440:	fd5ff06f          	j	20403414 <z_reschedule_irqlock>

20403444 <k_sched_lock>:
20403444:	00800793          	li	a5,8
20403448:	3007b7f3          	csrrc	a5,mstatus,a5
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
2040344c:	80000737          	lui	a4,0x80000
20403450:	13c72683          	lw	a3,316(a4) # 8000013c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000013d>
20403454:	00f6c703          	lbu	a4,15(a3)
20403458:	fff70713          	addi	a4,a4,-1
2040345c:	00e687a3          	sb	a4,15(a3)
	key = (mstatus & MSTATUS_IEN);
20403460:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403464:	3007a7f3          	csrrs	a5,mstatus,a5
}
20403468:	00008067          	ret

2040346c <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
2040346c:	00050793          	mv	a5,a0
	return list->head == list;
20403470:	00052503          	lw	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20403474:	00a79463          	bne	a5,a0,2040347c <z_priq_dumb_best+0x10>
	struct k_thread *thread = NULL;
20403478:	00000513          	li	a0,0

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
2040347c:	00008067          	ret

20403480 <update_cache>:
{
20403480:	ff010113          	addi	sp,sp,-16
20403484:	01212023          	sw	s2,0(sp)
20403488:	00050913          	mv	s2,a0
	return _priq_run_best(curr_cpu_runq());
2040348c:	80000537          	lui	a0,0x80000
20403490:	15050513          	addi	a0,a0,336 # 80000150 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000151>
{
20403494:	00812423          	sw	s0,8(sp)
20403498:	00912223          	sw	s1,4(sp)
2040349c:	00112623          	sw	ra,12(sp)
204034a0:	80000437          	lui	s0,0x80000
	return _priq_run_best(curr_cpu_runq());
204034a4:	fc9ff0ef          	jal	ra,2040346c <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
204034a8:	13440413          	addi	s0,s0,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
204034ac:	00050493          	mv	s1,a0
204034b0:	00051463          	bnez	a0,204034b8 <update_cache+0x38>
204034b4:	00c42483          	lw	s1,12(s0)
	if (z_is_thread_prevented_from_running(_current)) {
204034b8:	00842783          	lw	a5,8(s0)
	if (preempt_ok != 0) {
204034bc:	02091c63          	bnez	s2,204034f4 <update_cache+0x74>
	if (z_is_thread_prevented_from_running(_current)) {
204034c0:	00d7c703          	lbu	a4,13(a5)
204034c4:	01f77713          	andi	a4,a4,31
204034c8:	02071663          	bnez	a4,204034f4 <update_cache+0x74>
	if (is_preempt(_current) || is_metairq(thread)) {
204034cc:	00e7d683          	lhu	a3,14(a5)
204034d0:	07f00713          	li	a4,127
204034d4:	02d77063          	bgeu	a4,a3,204034f4 <update_cache+0x74>
		_kernel.ready_q.cache = _current;
204034d8:	00f42c23          	sw	a5,24(s0)
}
204034dc:	00c12083          	lw	ra,12(sp)
204034e0:	00812403          	lw	s0,8(sp)
204034e4:	00412483          	lw	s1,4(sp)
204034e8:	00012903          	lw	s2,0(sp)
204034ec:	01010113          	addi	sp,sp,16
204034f0:	00008067          	ret
		if (thread != _current) {
204034f4:	00f48463          	beq	s1,a5,204034fc <update_cache+0x7c>
			z_reset_time_slice();
204034f8:	df9ff0ef          	jal	ra,204032f0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
204034fc:	00942c23          	sw	s1,24(s0)
}
20403500:	fddff06f          	j	204034dc <update_cache+0x5c>

20403504 <move_thread_to_end_of_prio_q>:
{
20403504:	ff010113          	addi	sp,sp,-16
20403508:	00812423          	sw	s0,8(sp)
2040350c:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
20403510:	00d54783          	lbu	a5,13(a0)
20403514:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
20403518:	01879713          	slli	a4,a5,0x18
2040351c:	41875713          	srai	a4,a4,0x18
20403520:	00075863          	bgez	a4,20403530 <move_thread_to_end_of_prio_q+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20403524:	07f7f793          	andi	a5,a5,127
20403528:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
2040352c:	d75ff0ef          	jal	ra,204032a0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
20403530:	00d44783          	lbu	a5,13(s0)
	return list->head == list;
20403534:	80000737          	lui	a4,0x80000
20403538:	13470693          	addi	a3,a4,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
2040353c:	f807e793          	ori	a5,a5,-128
20403540:	00f406a3          	sb	a5,13(s0)
20403544:	01c6a783          	lw	a5,28(a3)
	return (node == list->tail) ? NULL : node->next;
20403548:	0206a583          	lw	a1,32(a3)
2040354c:	800006b7          	lui	a3,0x80000
20403550:	15068693          	addi	a3,a3,336 # 80000150 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000151>
20403554:	13470713          	addi	a4,a4,308
	return sys_dlist_is_empty(list) ? NULL : list->head;
20403558:	04d78c63          	beq	a5,a3,204035b0 <move_thread_to_end_of_prio_q+0xac>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
2040355c:	04078a63          	beqz	a5,204035b0 <move_thread_to_end_of_prio_q+0xac>
	int32_t b1 = thread_1->base.prio;
20403560:	00e40503          	lb	a0,14(s0)
	int32_t b2 = thread_2->base.prio;
20403564:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
20403568:	02c50e63          	beq	a0,a2,204035a4 <move_thread_to_end_of_prio_q+0xa0>
		return b2 - b1;
2040356c:	40a60633          	sub	a2,a2,a0
		if (z_sched_prio_cmp(thread, t) > 0) {
20403570:	02c05a63          	blez	a2,204035a4 <move_thread_to_end_of_prio_q+0xa0>
	sys_dnode_t *const prev = successor->prev;
20403574:	0047a683          	lw	a3,4(a5)
	node->next = successor;
20403578:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
2040357c:	00d42223          	sw	a3,4(s0)
	prev->next = node;
20403580:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
20403584:	0087a223          	sw	s0,4(a5)
	update_cache(thread == _current);
20403588:	00872503          	lw	a0,8(a4)
}
2040358c:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
20403590:	40850533          	sub	a0,a0,s0
}
20403594:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
20403598:	00153513          	seqz	a0,a0
}
2040359c:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
204035a0:	ee1ff06f          	j	20403480 <update_cache>
	return (node == list->tail) ? NULL : node->next;
204035a4:	00b78663          	beq	a5,a1,204035b0 <move_thread_to_end_of_prio_q+0xac>
204035a8:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
204035ac:	fa079ce3          	bnez	a5,20403564 <move_thread_to_end_of_prio_q+0x60>
	node->next = list;
204035b0:	00d42023          	sw	a3,0(s0)
	node->prev = tail;
204035b4:	00b42223          	sw	a1,4(s0)
	tail->next = node;
204035b8:	0085a023          	sw	s0,0(a1)
	list->tail = node;
204035bc:	02872023          	sw	s0,32(a4)
}
204035c0:	fc9ff06f          	j	20403588 <move_thread_to_end_of_prio_q+0x84>

204035c4 <z_time_slice>:
{
204035c4:	ff010113          	addi	sp,sp,-16
204035c8:	00812423          	sw	s0,8(sp)
204035cc:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
204035d0:	00800413          	li	s0,8
204035d4:	30043473          	csrrc	s0,mstatus,s0
	if (slice_time && sliceable(_current)) {
204035d8:	800007b7          	lui	a5,0x80000
204035dc:	01c7a703          	lw	a4,28(a5) # 8000001c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000001d>
204035e0:	800007b7          	lui	a5,0x80000
	key = (mstatus & MSTATUS_IEN);
204035e4:	00847413          	andi	s0,s0,8
204035e8:	13478793          	addi	a5,a5,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
204035ec:	06070863          	beqz	a4,2040365c <z_time_slice+0x98>
204035f0:	00050693          	mv	a3,a0
204035f4:	0087a503          	lw	a0,8(a5)
		&& !z_is_idle_thread_object(thread);
204035f8:	07f00713          	li	a4,127
204035fc:	00e55603          	lhu	a2,14(a0)
20403600:	04c76e63          	bltu	a4,a2,2040365c <z_time_slice+0x98>
		&& !z_is_thread_prevented_from_running(thread)
20403604:	00d54703          	lbu	a4,13(a0)
20403608:	01f77713          	andi	a4,a4,31
2040360c:	04071863          	bnez	a4,2040365c <z_time_slice+0x98>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
20403610:	80000737          	lui	a4,0x80000
20403614:	00e50603          	lb	a2,14(a0)
20403618:	01872703          	lw	a4,24(a4) # 80000018 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000019>
2040361c:	04e64063          	blt	a2,a4,2040365c <z_time_slice+0x98>
		&& !z_is_idle_thread_object(thread);
20403620:	80000737          	lui	a4,0x80000
20403624:	02870713          	addi	a4,a4,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
20403628:	02e50a63          	beq	a0,a4,2040365c <z_time_slice+0x98>
		if (ticks >= _current_cpu->slice_ticks) {
2040362c:	0107a703          	lw	a4,16(a5)
20403630:	02e6c063          	blt	a3,a4,20403650 <z_time_slice+0x8c>
			move_thread_to_end_of_prio_q(_current);
20403634:	ed1ff0ef          	jal	ra,20403504 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
20403638:	cb9ff0ef          	jal	ra,204032f0 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
2040363c:	30042473          	csrrs	s0,mstatus,s0
}
20403640:	00c12083          	lw	ra,12(sp)
20403644:	00812403          	lw	s0,8(sp)
20403648:	01010113          	addi	sp,sp,16
2040364c:	00008067          	ret
			_current_cpu->slice_ticks -= ticks;
20403650:	40d70733          	sub	a4,a4,a3
20403654:	00e7a823          	sw	a4,16(a5)
20403658:	fe5ff06f          	j	2040363c <z_time_slice+0x78>
		_current_cpu->slice_ticks = 0;
2040365c:	0007a823          	sw	zero,16(a5)
20403660:	fddff06f          	j	2040363c <z_time_slice+0x78>

20403664 <ready_thread>:
20403664:	00d54783          	lbu	a5,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
20403668:	01879713          	slli	a4,a5,0x18
2040366c:	41875713          	srai	a4,a4,0x18
20403670:	08074863          	bltz	a4,20403700 <ready_thread+0x9c>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
20403674:	01f7f713          	andi	a4,a5,31
20403678:	08071463          	bnez	a4,20403700 <ready_thread+0x9c>
2040367c:	01852703          	lw	a4,24(a0)
20403680:	08071063          	bnez	a4,20403700 <ready_thread+0x9c>
	thread->base.thread_state |= _THREAD_QUEUED;
20403684:	f807e793          	ori	a5,a5,-128
	return list->head == list;
20403688:	80000737          	lui	a4,0x80000
2040368c:	13470693          	addi	a3,a4,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
20403690:	00f506a3          	sb	a5,13(a0)
20403694:	01c6a783          	lw	a5,28(a3)
	return (node == list->tail) ? NULL : node->next;
20403698:	0206a583          	lw	a1,32(a3)
2040369c:	800006b7          	lui	a3,0x80000
204036a0:	15068693          	addi	a3,a3,336 # 80000150 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000151>
204036a4:	13470713          	addi	a4,a4,308
	return sys_dlist_is_empty(list) ? NULL : list->head;
204036a8:	04d78263          	beq	a5,a3,204036ec <ready_thread+0x88>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
204036ac:	04078063          	beqz	a5,204036ec <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
204036b0:	00e50803          	lb	a6,14(a0)
	int32_t b2 = thread_2->base.prio;
204036b4:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
204036b8:	02c80463          	beq	a6,a2,204036e0 <ready_thread+0x7c>
		return b2 - b1;
204036bc:	41060633          	sub	a2,a2,a6
		if (z_sched_prio_cmp(thread, t) > 0) {
204036c0:	02c05063          	blez	a2,204036e0 <ready_thread+0x7c>
	sys_dnode_t *const prev = successor->prev;
204036c4:	0047a703          	lw	a4,4(a5)
	node->next = successor;
204036c8:	00f52023          	sw	a5,0(a0)
	node->prev = prev;
204036cc:	00e52223          	sw	a4,4(a0)
	prev->next = node;
204036d0:	00a72023          	sw	a0,0(a4)
	successor->prev = node;
204036d4:	00a7a223          	sw	a0,4(a5)
		update_cache(0);
204036d8:	00000513          	li	a0,0
204036dc:	da5ff06f          	j	20403480 <update_cache>
	return (node == list->tail) ? NULL : node->next;
204036e0:	00b78663          	beq	a5,a1,204036ec <ready_thread+0x88>
204036e4:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
204036e8:	fc0796e3          	bnez	a5,204036b4 <ready_thread+0x50>
	node->next = list;
204036ec:	00d52023          	sw	a3,0(a0)
	node->prev = tail;
204036f0:	00b52223          	sw	a1,4(a0)
	tail->next = node;
204036f4:	00a5a023          	sw	a0,0(a1)
	list->tail = node;
204036f8:	02a72023          	sw	a0,32(a4)
}
204036fc:	fddff06f          	j	204036d8 <ready_thread+0x74>
}
20403700:	00008067          	ret

20403704 <z_ready_thread>:
{
20403704:	ff010113          	addi	sp,sp,-16
20403708:	00812423          	sw	s0,8(sp)
2040370c:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403710:	00800413          	li	s0,8
20403714:	30043473          	csrrc	s0,mstatus,s0
			ready_thread(thread);
20403718:	f4dff0ef          	jal	ra,20403664 <ready_thread>
	key = (mstatus & MSTATUS_IEN);
2040371c:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403720:	30042473          	csrrs	s0,mstatus,s0
}
20403724:	00c12083          	lw	ra,12(sp)
20403728:	00812403          	lw	s0,8(sp)
2040372c:	01010113          	addi	sp,sp,16
20403730:	00008067          	ret

20403734 <z_sched_start>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403734:	00800593          	li	a1,8
20403738:	3005b5f3          	csrrc	a1,mstatus,a1
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
2040373c:	00d54703          	lbu	a4,13(a0)
	key = (mstatus & MSTATUS_IEN);
20403740:	0085f593          	andi	a1,a1,8
	if (z_has_thread_started(thread)) {
20403744:	00477693          	andi	a3,a4,4
20403748:	00069663          	bnez	a3,20403754 <z_sched_start+0x20>
	__asm__ volatile ("csrrs %0, mstatus, %1"
2040374c:	3005a5f3          	csrrs	a1,mstatus,a1
		return;
20403750:	00008067          	ret
{
20403754:	fe010113          	addi	sp,sp,-32
20403758:	00112e23          	sw	ra,28(sp)
	thread->base.thread_state &= ~_THREAD_PRESTART;
2040375c:	ffb77713          	andi	a4,a4,-5
20403760:	00e506a3          	sb	a4,13(a0)
20403764:	00b12623          	sw	a1,12(sp)
	ready_thread(thread);
20403768:	efdff0ef          	jal	ra,20403664 <ready_thread>
	z_reschedule(&sched_spinlock, key);
2040376c:	00c12583          	lw	a1,12(sp)
}
20403770:	01c12083          	lw	ra,28(sp)
	z_reschedule(&sched_spinlock, key);
20403774:	80000537          	lui	a0,0x80000
20403778:	15850513          	addi	a0,a0,344 # 80000158 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000159>
}
2040377c:	02010113          	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
20403780:	c61ff06f          	j	204033e0 <z_reschedule>

20403784 <z_thread_timeout>:
{
20403784:	fe010113          	addi	sp,sp,-32
20403788:	00912a23          	sw	s1,20(sp)
2040378c:	00112e23          	sw	ra,28(sp)
20403790:	00812c23          	sw	s0,24(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403794:	00800493          	li	s1,8
20403798:	3004b4f3          	csrrc	s1,mstatus,s1
		if (!killed) {
2040379c:	ff554783          	lbu	a5,-11(a0)
	key = (mstatus & MSTATUS_IEN);
204037a0:	0084f493          	andi	s1,s1,8
204037a4:	0287f793          	andi	a5,a5,40
204037a8:	02079863          	bnez	a5,204037d8 <z_thread_timeout+0x54>
204037ac:	00050413          	mv	s0,a0
			if (thread->base.pended_on != NULL) {
204037b0:	ff042783          	lw	a5,-16(s0)
	struct k_thread *thread = CONTAINER_OF(timeout,
204037b4:	fe850513          	addi	a0,a0,-24
			if (thread->base.pended_on != NULL) {
204037b8:	00078863          	beqz	a5,204037c8 <z_thread_timeout+0x44>
				unpend_thread_no_timeout(thread);
204037bc:	00a12623          	sw	a0,12(sp)
204037c0:	afdff0ef          	jal	ra,204032bc <unpend_thread_no_timeout>
204037c4:	00c12503          	lw	a0,12(sp)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
204037c8:	ff544783          	lbu	a5,-11(s0)
204037cc:	feb7f793          	andi	a5,a5,-21
204037d0:	fef40aa3          	sb	a5,-11(s0)
			ready_thread(thread);
204037d4:	e91ff0ef          	jal	ra,20403664 <ready_thread>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204037d8:	3004a4f3          	csrrs	s1,mstatus,s1
}
204037dc:	01c12083          	lw	ra,28(sp)
204037e0:	01812403          	lw	s0,24(sp)
204037e4:	01412483          	lw	s1,20(sp)
204037e8:	02010113          	addi	sp,sp,32
204037ec:	00008067          	ret

204037f0 <unready_thread>:
{
204037f0:	ff010113          	addi	sp,sp,-16
204037f4:	00812423          	sw	s0,8(sp)
204037f8:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
204037fc:	00d54783          	lbu	a5,13(a0)
20403800:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
20403804:	01879713          	slli	a4,a5,0x18
20403808:	41875713          	srai	a4,a4,0x18
2040380c:	00075863          	bgez	a4,2040381c <unready_thread+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20403810:	07f7f793          	andi	a5,a5,127
20403814:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
20403818:	a89ff0ef          	jal	ra,204032a0 <sys_dlist_remove>
	update_cache(thread == _current);
2040381c:	800007b7          	lui	a5,0x80000
20403820:	13c7a503          	lw	a0,316(a5) # 8000013c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000013d>
}
20403824:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
20403828:	40850533          	sub	a0,a0,s0
}
2040382c:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
20403830:	00153513          	seqz	a0,a0
}
20403834:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
20403838:	c49ff06f          	j	20403480 <update_cache>

2040383c <add_to_waitq_locked>:
{
2040383c:	ff010113          	addi	sp,sp,-16
20403840:	00812423          	sw	s0,8(sp)
20403844:	00912223          	sw	s1,4(sp)
20403848:	00050413          	mv	s0,a0
2040384c:	00112623          	sw	ra,12(sp)
20403850:	00058493          	mv	s1,a1
	unready_thread(thread);
20403854:	f9dff0ef          	jal	ra,204037f0 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
20403858:	00d44783          	lbu	a5,13(s0)
2040385c:	0027e793          	ori	a5,a5,2
20403860:	00f406a3          	sb	a5,13(s0)
	if (wait_q != NULL) {
20403864:	02048e63          	beqz	s1,204038a0 <add_to_waitq_locked+0x64>
	return list->head == list;
20403868:	0004a783          	lw	a5,0(s1)
		thread->base.pended_on = wait_q;
2040386c:	00942423          	sw	s1,8(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20403870:	04f48a63          	beq	s1,a5,204038c4 <add_to_waitq_locked+0x88>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20403874:	04078863          	beqz	a5,204038c4 <add_to_waitq_locked+0x88>
	int32_t b1 = thread_1->base.prio;
20403878:	00e40683          	lb	a3,14(s0)
	int32_t b2 = thread_2->base.prio;
2040387c:	00e78703          	lb	a4,14(a5)
	if (b1 != b2) {
20403880:	02e68a63          	beq	a3,a4,204038b4 <add_to_waitq_locked+0x78>
		return b2 - b1;
20403884:	40d70733          	sub	a4,a4,a3
		if (z_sched_prio_cmp(thread, t) > 0) {
20403888:	02e05663          	blez	a4,204038b4 <add_to_waitq_locked+0x78>
	sys_dnode_t *const prev = successor->prev;
2040388c:	0047a703          	lw	a4,4(a5)
	node->next = successor;
20403890:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
20403894:	00e42223          	sw	a4,4(s0)
	prev->next = node;
20403898:	00872023          	sw	s0,0(a4)
	successor->prev = node;
2040389c:	0087a223          	sw	s0,4(a5)
}
204038a0:	00c12083          	lw	ra,12(sp)
204038a4:	00812403          	lw	s0,8(sp)
204038a8:	00412483          	lw	s1,4(sp)
204038ac:	01010113          	addi	sp,sp,16
204038b0:	00008067          	ret
	return (node == list->tail) ? NULL : node->next;
204038b4:	0044a703          	lw	a4,4(s1)
204038b8:	00e78663          	beq	a5,a4,204038c4 <add_to_waitq_locked+0x88>
204038bc:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
204038c0:	fa079ee3          	bnez	a5,2040387c <add_to_waitq_locked+0x40>
	sys_dnode_t *const tail = list->tail;
204038c4:	0044a783          	lw	a5,4(s1)
	node->next = list;
204038c8:	00942023          	sw	s1,0(s0)
	node->prev = tail;
204038cc:	00f42223          	sw	a5,4(s0)
	tail->next = node;
204038d0:	0087a023          	sw	s0,0(a5)
	list->tail = node;
204038d4:	0084a223          	sw	s0,4(s1)
}
204038d8:	fc9ff06f          	j	204038a0 <add_to_waitq_locked+0x64>

204038dc <pend>:
{
204038dc:	fe010113          	addi	sp,sp,-32
204038e0:	00812c23          	sw	s0,24(sp)
204038e4:	00912a23          	sw	s1,20(sp)
204038e8:	00112e23          	sw	ra,28(sp)
204038ec:	00050493          	mv	s1,a0
204038f0:	00c12623          	sw	a2,12(sp)
204038f4:	00d12423          	sw	a3,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
204038f8:	00800413          	li	s0,8
204038fc:	30043473          	csrrc	s0,mstatus,s0
		add_to_waitq_locked(thread, wait_q);
20403900:	f3dff0ef          	jal	ra,2040383c <add_to_waitq_locked>
	key = (mstatus & MSTATUS_IEN);
20403904:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403908:	30042473          	csrrs	s0,mstatus,s0
	add_thread_timeout(thread, timeout);
2040390c:	00c12603          	lw	a2,12(sp)
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20403910:	fff00593          	li	a1,-1
20403914:	00812683          	lw	a3,8(sp)
20403918:	00b61463          	bne	a2,a1,20403920 <pend+0x44>
2040391c:	02c68263          	beq	a3,a2,20403940 <pend+0x64>
}
20403920:	01812403          	lw	s0,24(sp)
20403924:	01c12083          	lw	ra,28(sp)
20403928:	01848513          	addi	a0,s1,24
2040392c:	01412483          	lw	s1,20(sp)
20403930:	204035b7          	lui	a1,0x20403
20403934:	78458593          	addi	a1,a1,1924 # 20403784 <z_thread_timeout>
20403938:	02010113          	addi	sp,sp,32
2040393c:	32c0006f          	j	20403c68 <z_add_timeout>
20403940:	01c12083          	lw	ra,28(sp)
20403944:	01812403          	lw	s0,24(sp)
20403948:	01412483          	lw	s1,20(sp)
2040394c:	02010113          	addi	sp,sp,32
20403950:	00008067          	ret

20403954 <z_pend_curr>:
	pend(_current, wait_q, timeout);
20403954:	800007b7          	lui	a5,0x80000
20403958:	13c7a503          	lw	a0,316(a5) # 8000013c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000013d>
{
2040395c:	ff010113          	addi	sp,sp,-16
20403960:	00812423          	sw	s0,8(sp)
20403964:	00058413          	mv	s0,a1
20403968:	00060593          	mv	a1,a2
2040396c:	00068613          	mv	a2,a3
20403970:	00070693          	mv	a3,a4
20403974:	00112623          	sw	ra,12(sp)
	pend(_current, wait_q, timeout);
20403978:	f65ff0ef          	jal	ra,204038dc <pend>
2040397c:	00040513          	mv	a0,s0
}
20403980:	00812403          	lw	s0,8(sp)
20403984:	00c12083          	lw	ra,12(sp)
20403988:	01010113          	addi	sp,sp,16
2040398c:	935fc06f          	j	204002c0 <arch_swap>

20403990 <k_sched_unlock>:
{
20403990:	ff010113          	addi	sp,sp,-16
20403994:	00812423          	sw	s0,8(sp)
20403998:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
2040399c:	00800413          	li	s0,8
204039a0:	30043473          	csrrc	s0,mstatus,s0
		++_current->base.sched_locked;
204039a4:	800007b7          	lui	a5,0x80000
204039a8:	13c7a703          	lw	a4,316(a5) # 8000013c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000013d>
		update_cache(0);
204039ac:	00000513          	li	a0,0
	key = (mstatus & MSTATUS_IEN);
204039b0:	00847413          	andi	s0,s0,8
		++_current->base.sched_locked;
204039b4:	00f74783          	lbu	a5,15(a4)
204039b8:	00178793          	addi	a5,a5,1
204039bc:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
204039c0:	ac1ff0ef          	jal	ra,20403480 <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204039c4:	30042473          	csrrs	s0,mstatus,s0
}
204039c8:	00812403          	lw	s0,8(sp)
204039cc:	00c12083          	lw	ra,12(sp)
204039d0:	01010113          	addi	sp,sp,16
	z_reschedule_unlocked();
204039d4:	a61ff06f          	j	20403434 <z_reschedule_unlocked>

204039d8 <z_unpend_first_thread>:
{
204039d8:	ff010113          	addi	sp,sp,-16
204039dc:	00812423          	sw	s0,8(sp)
204039e0:	00112623          	sw	ra,12(sp)
204039e4:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
204039e8:	00800413          	li	s0,8
204039ec:	30043473          	csrrc	s0,mstatus,s0
		thread = _priq_wait_best(&wait_q->waitq);
204039f0:	a7dff0ef          	jal	ra,2040346c <z_priq_dumb_best>
	key = (mstatus & MSTATUS_IEN);
204039f4:	00847413          	andi	s0,s0,8
204039f8:	00050493          	mv	s1,a0
		if (thread != NULL) {
204039fc:	00050863          	beqz	a0,20403a0c <z_unpend_first_thread+0x34>
			unpend_thread_no_timeout(thread);
20403a00:	8bdff0ef          	jal	ra,204032bc <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
20403a04:	01848513          	addi	a0,s1,24
20403a08:	40c000ef          	jal	ra,20403e14 <z_abort_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403a0c:	30042473          	csrrs	s0,mstatus,s0
}
20403a10:	00c12083          	lw	ra,12(sp)
20403a14:	00812403          	lw	s0,8(sp)
20403a18:	00048513          	mv	a0,s1
20403a1c:	00412483          	lw	s1,4(sp)
20403a20:	01010113          	addi	sp,sp,16
20403a24:	00008067          	ret

20403a28 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
20403a28:	800007b7          	lui	a5,0x80000
20403a2c:	80000737          	lui	a4,0x80000
20403a30:	13478793          	addi	a5,a5,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
20403a34:	15070713          	addi	a4,a4,336 # 80000150 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000151>
20403a38:	00e7ae23          	sw	a4,28(a5)
	list->tail = (sys_dnode_t *)list;
20403a3c:	02e7a023          	sw	a4,32(a5)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
20403a40:	00000593          	li	a1,0
20403a44:	00000513          	li	a0,0
20403a48:	901ff06f          	j	20403348 <k_sched_time_slice_set>

20403a4c <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
20403a4c:	800007b7          	lui	a5,0x80000
20403a50:	13c7a503          	lw	a0,316(a5) # 8000013c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000013d>
20403a54:	00008067          	ret

20403a58 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
20403a58:	fe010113          	addi	sp,sp,-32
20403a5c:	00912a23          	sw	s1,20(sp)
20403a60:	00112e23          	sw	ra,28(sp)
20403a64:	00812c23          	sw	s0,24(sp)
20403a68:	01212823          	sw	s2,16(sp)
20403a6c:	01312623          	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403a70:	00800493          	li	s1,8
20403a74:	3004b4f3          	csrrc	s1,mstatus,s1
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
20403a78:	00d54783          	lbu	a5,13(a0)
	key = (mstatus & MSTATUS_IEN);
20403a7c:	0084f493          	andi	s1,s1,8
20403a80:	0087f713          	andi	a4,a5,8
20403a84:	02070263          	beqz	a4,20403aa8 <z_thread_abort+0x50>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403a88:	3004a4f3          	csrrs	s1,mstatus,s1
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
20403a8c:	01c12083          	lw	ra,28(sp)
20403a90:	01812403          	lw	s0,24(sp)
20403a94:	01412483          	lw	s1,20(sp)
20403a98:	01012903          	lw	s2,16(sp)
20403a9c:	00c12983          	lw	s3,12(sp)
20403aa0:	02010113          	addi	sp,sp,32
20403aa4:	00008067          	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
20403aa8:	fdf7f713          	andi	a4,a5,-33
20403aac:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
20403ab0:	01871693          	slli	a3,a4,0x18
20403ab4:	4186d693          	srai	a3,a3,0x18
20403ab8:	00050413          	mv	s0,a0
20403abc:	0406ce63          	bltz	a3,20403b18 <z_thread_abort+0xc0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
20403ac0:	00e506a3          	sb	a4,13(a0)
		if (thread->base.pended_on != NULL) {
20403ac4:	00842783          	lw	a5,8(s0)
20403ac8:	00078663          	beqz	a5,20403ad4 <z_thread_abort+0x7c>
			unpend_thread_no_timeout(thread);
20403acc:	00040513          	mv	a0,s0
20403ad0:	fecff0ef          	jal	ra,204032bc <unpend_thread_no_timeout>
20403ad4:	01840513          	addi	a0,s0,24
20403ad8:	33c000ef          	jal	ra,20403e14 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
20403adc:	06840993          	addi	s3,s0,104
	return list->head == list;
20403ae0:	06842903          	lw	s2,104(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20403ae4:	01390463          	beq	s2,s3,20403aec <z_thread_abort+0x94>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
20403ae8:	04091263          	bnez	s2,20403b2c <z_thread_abort+0xd4>
		update_cache(1);
20403aec:	00100513          	li	a0,1
20403af0:	991ff0ef          	jal	ra,20403480 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
20403af4:	800007b7          	lui	a5,0x80000
20403af8:	13478793          	addi	a5,a5,308 # 80000134 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000135>
20403afc:	0087a703          	lw	a4,8(a5)
20403b00:	f88714e3          	bne	a4,s0,20403a88 <z_thread_abort+0x30>
20403b04:	0007a783          	lw	a5,0(a5)
20403b08:	f80790e3          	bnez	a5,20403a88 <z_thread_abort+0x30>
20403b0c:	00048513          	mv	a0,s1
20403b10:	fb0fc0ef          	jal	ra,204002c0 <arch_swap>
	return ret;
20403b14:	f75ff06f          	j	20403a88 <z_thread_abort+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20403b18:	05f7f793          	andi	a5,a5,95
20403b1c:	0087e793          	ori	a5,a5,8
20403b20:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
20403b24:	f7cff0ef          	jal	ra,204032a0 <sys_dlist_remove>
}
20403b28:	f9dff06f          	j	20403ac4 <z_thread_abort+0x6c>
		unpend_thread_no_timeout(thread);
20403b2c:	00090513          	mv	a0,s2
20403b30:	f8cff0ef          	jal	ra,204032bc <unpend_thread_no_timeout>
20403b34:	01890513          	addi	a0,s2,24
20403b38:	2dc000ef          	jal	ra,20403e14 <z_abort_timeout>
		ready_thread(thread);
20403b3c:	00090513          	mv	a0,s2
	thread->arch.swap_return_value = value;
20403b40:	06092c23          	sw	zero,120(s2)
20403b44:	b21ff0ef          	jal	ra,20403664 <ready_thread>
20403b48:	f99ff06f          	j	20403ae0 <z_thread_abort+0x88>

20403b4c <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
20403b4c:	f0dff06f          	j	20403a58 <z_thread_abort>

20403b50 <z_data_copy>:
 * @return N/A
 */
void z_data_copy(void)
{
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
20403b50:	80001537          	lui	a0,0x80001
20403b54:	f6050613          	addi	a2,a0,-160 # 80000f60 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000f61>
	(void)memcpy(&__data_region_start, &__data_region_load_start,
20403b58:	83818793          	addi	a5,gp,-1992 # 80001040 <__data_region_end>
20403b5c:	204045b7          	lui	a1,0x20404
20403b60:	40c78633          	sub	a2,a5,a2
20403b64:	61858593          	addi	a1,a1,1560 # 20404618 <__data_load_start>
20403b68:	f6050513          	addi	a0,a0,-160
20403b6c:	f1dfd06f          	j	20401a88 <memcpy>

20403b70 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
20403b70:	800007b7          	lui	a5,0x80000
20403b74:	0207a783          	lw	a5,32(a5) # 80000020 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000021>
20403b78:	00079463          	bnez	a5,20403b80 <elapsed+0x10>
20403b7c:	938ff06f          	j	20402cb4 <sys_clock_elapsed>
}
20403b80:	00000513          	li	a0,0
20403b84:	00008067          	ret

20403b88 <next_timeout>:

static int32_t next_timeout(void)
{
20403b88:	ff010113          	addi	sp,sp,-16
	return list->head == list;
20403b8c:	82018793          	addi	a5,gp,-2016 # 80001028 <timeout_list>
20403b90:	00812423          	sw	s0,8(sp)
20403b94:	0007a403          	lw	s0,0(a5)
20403b98:	00112623          	sw	ra,12(sp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20403b9c:	00f41463          	bne	s0,a5,20403ba4 <next_timeout+0x1c>
20403ba0:	00000413          	li	s0,0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
20403ba4:	fcdff0ef          	jal	ra,20403b70 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
20403ba8:	02040c63          	beqz	s0,20403be0 <next_timeout+0x58>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
20403bac:	01042703          	lw	a4,16(s0)
20403bb0:	01442783          	lw	a5,20(s0)
20403bb4:	41f55693          	srai	a3,a0,0x1f
20403bb8:	40a70533          	sub	a0,a4,a0
20403bbc:	00a73733          	sltu	a4,a4,a0
20403bc0:	40d787b3          	sub	a5,a5,a3
20403bc4:	40e787b3          	sub	a5,a5,a4
	int32_t ret = to == NULL ? MAX_WAIT
20403bc8:	00f04663          	bgtz	a5,20403bd4 <next_timeout+0x4c>
20403bcc:	04079063          	bnez	a5,20403c0c <next_timeout+0x84>
20403bd0:	02050e63          	beqz	a0,20403c0c <next_timeout+0x84>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
20403bd4:	00f04663          	bgtz	a5,20403be0 <next_timeout+0x58>
20403bd8:	00079863          	bnez	a5,20403be8 <next_timeout+0x60>
20403bdc:	00055663          	bgez	a0,20403be8 <next_timeout+0x60>
	int32_t ret = to == NULL ? MAX_WAIT
20403be0:	80000537          	lui	a0,0x80000
20403be4:	fff54513          	not	a0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
20403be8:	800007b7          	lui	a5,0x80000
20403bec:	1447a783          	lw	a5,324(a5) # 80000144 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000145>
20403bf0:	00078663          	beqz	a5,20403bfc <next_timeout+0x74>
20403bf4:	00a7d463          	bge	a5,a0,20403bfc <next_timeout+0x74>
20403bf8:	00078513          	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
20403bfc:	00c12083          	lw	ra,12(sp)
20403c00:	00812403          	lw	s0,8(sp)
20403c04:	01010113          	addi	sp,sp,16
20403c08:	00008067          	ret
	int32_t ret = to == NULL ? MAX_WAIT
20403c0c:	00000513          	li	a0,0
20403c10:	fd9ff06f          	j	20403be8 <next_timeout+0x60>

20403c14 <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
20403c14:	00052783          	lw	a5,0(a0) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
20403c18:	02050c63          	beqz	a0,20403c50 <remove_timeout+0x3c>
	return (node == list->tail) ? NULL : node->next;
20403c1c:	8241a703          	lw	a4,-2012(gp) # 8000102c <timeout_list+0x4>
20403c20:	02e50863          	beq	a0,a4,20403c50 <remove_timeout+0x3c>
	if (next(t) != NULL) {
20403c24:	02078663          	beqz	a5,20403c50 <remove_timeout+0x3c>
		next(t)->dticks += t->dticks;
20403c28:	0107a703          	lw	a4,16(a5)
20403c2c:	01052683          	lw	a3,16(a0)
20403c30:	01452583          	lw	a1,20(a0)
20403c34:	0147a603          	lw	a2,20(a5)
20403c38:	00d706b3          	add	a3,a4,a3
20403c3c:	00e6b733          	sltu	a4,a3,a4
20403c40:	00b60633          	add	a2,a2,a1
20403c44:	00c70733          	add	a4,a4,a2
20403c48:	00d7a823          	sw	a3,16(a5)
20403c4c:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = node->prev;
20403c50:	00452703          	lw	a4,4(a0)
	prev->next = next;
20403c54:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
20403c58:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
20403c5c:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
20403c60:	00052223          	sw	zero,4(a0)
}
20403c64:	00008067          	ret

20403c68 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
20403c68:	fe010113          	addi	sp,sp,-32
20403c6c:	00812c23          	sw	s0,24(sp)
20403c70:	00912a23          	sw	s1,20(sp)
20403c74:	01312623          	sw	s3,12(sp)
20403c78:	00112e23          	sw	ra,28(sp)
20403c7c:	00068993          	mv	s3,a3
20403c80:	01212823          	sw	s2,16(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20403c84:	fff00693          	li	a3,-1
{
20403c88:	00050413          	mv	s0,a0
20403c8c:	00060493          	mv	s1,a2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20403c90:	00d61463          	bne	a2,a3,20403c98 <z_add_timeout+0x30>
20403c94:	16c98263          	beq	s3,a2,20403df8 <z_add_timeout+0x190>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
20403c98:	00b42423          	sw	a1,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403c9c:	00800913          	li	s2,8
20403ca0:	30093973          	csrrc	s2,mstatus,s2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
20403ca4:	ffe00693          	li	a3,-2
20403ca8:	409687b3          	sub	a5,a3,s1
20403cac:	00f6b733          	sltu	a4,a3,a5
20403cb0:	fff9c793          	not	a5,s3
20403cb4:	40e787b3          	sub	a5,a5,a4
	key = (mstatus & MSTATUS_IEN);
20403cb8:	00897913          	andi	s2,s2,8
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
20403cbc:	0607cc63          	bltz	a5,20403d34 <z_add_timeout+0xcc>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
20403cc0:	800007b7          	lui	a5,0x80000
20403cc4:	00878793          	addi	a5,a5,8 # 80000008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000009>
20403cc8:	0007a703          	lw	a4,0(a5)
20403ccc:	0047a783          	lw	a5,4(a5)
20403cd0:	40e68733          	sub	a4,a3,a4
20403cd4:	00e6b6b3          	sltu	a3,a3,a4
20403cd8:	fff7c793          	not	a5,a5
20403cdc:	40d787b3          	sub	a5,a5,a3
20403ce0:	409704b3          	sub	s1,a4,s1
20403ce4:	00973733          	sltu	a4,a4,s1
20403ce8:	413786b3          	sub	a3,a5,s3

			to->dticks = MAX(1, ticks);
20403cec:	40e686b3          	sub	a3,a3,a4
20403cf0:	00d04a63          	bgtz	a3,20403d04 <z_add_timeout+0x9c>
20403cf4:	00069463          	bnez	a3,20403cfc <z_add_timeout+0x94>
20403cf8:	00049663          	bnez	s1,20403d04 <z_add_timeout+0x9c>
20403cfc:	00100493          	li	s1,1
20403d00:	00000693          	li	a3,0
20403d04:	00942823          	sw	s1,16(s0)
	return list->head == list;
20403d08:	82018713          	addi	a4,gp,-2016 # 80001028 <timeout_list>
20403d0c:	00072783          	lw	a5,0(a4)
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
20403d10:	00d42a23          	sw	a3,20(s0)
20403d14:	82018613          	addi	a2,gp,-2016 # 80001028 <timeout_list>
	sys_dnode_t *const tail = list->tail;
20403d18:	00472803          	lw	a6,4(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20403d1c:	06c79263          	bne	a5,a2,20403d80 <z_add_timeout+0x118>
	node->next = list;
20403d20:	00c42023          	sw	a2,0(s0)
	node->prev = tail;
20403d24:	01042223          	sw	a6,4(s0)
	tail->next = node;
20403d28:	00882023          	sw	s0,0(a6)
	list->tail = node;
20403d2c:	00862223          	sw	s0,4(a2)
}
20403d30:	09c0006f          	j	20403dcc <z_add_timeout+0x164>
20403d34:	e3dff0ef          	jal	ra,20403b70 <elapsed>
20403d38:	00148793          	addi	a5,s1,1
20403d3c:	0097b4b3          	sltu	s1,a5,s1
20403d40:	013486b3          	add	a3,s1,s3
20403d44:	41f55493          	srai	s1,a0,0x1f
20403d48:	00a78533          	add	a0,a5,a0
20403d4c:	00f537b3          	sltu	a5,a0,a5
20403d50:	009686b3          	add	a3,a3,s1
20403d54:	00d786b3          	add	a3,a5,a3
20403d58:	00a42823          	sw	a0,16(s0)
20403d5c:	fadff06f          	j	20403d08 <z_add_timeout+0xa0>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
20403d60:	40e68733          	sub	a4,a3,a4
20403d64:	00e6b6b3          	sltu	a3,a3,a4
20403d68:	40a585b3          	sub	a1,a1,a0
20403d6c:	40d586b3          	sub	a3,a1,a3
20403d70:	00e42823          	sw	a4,16(s0)
20403d74:	00d42a23          	sw	a3,20(s0)
	return (node == list->tail) ? NULL : node->next;
20403d78:	faf804e3          	beq	a6,a5,20403d20 <z_add_timeout+0xb8>
20403d7c:	0007a783          	lw	a5,0(a5)
		for (t = first(); t != NULL; t = next(t)) {
20403d80:	fa0780e3          	beqz	a5,20403d20 <z_add_timeout+0xb8>
			if (t->dticks > to->dticks) {
20403d84:	0147a503          	lw	a0,20(a5)
20403d88:	01442583          	lw	a1,20(s0)
20403d8c:	0107a703          	lw	a4,16(a5)
20403d90:	01042683          	lw	a3,16(s0)
20403d94:	00a5c663          	blt	a1,a0,20403da0 <z_add_timeout+0x138>
20403d98:	fcb514e3          	bne	a0,a1,20403d60 <z_add_timeout+0xf8>
20403d9c:	fce6f2e3          	bgeu	a3,a4,20403d60 <z_add_timeout+0xf8>
				t->dticks -= to->dticks;
20403da0:	40d706b3          	sub	a3,a4,a3
20403da4:	00d73733          	sltu	a4,a4,a3
20403da8:	40b505b3          	sub	a1,a0,a1
20403dac:	40e58733          	sub	a4,a1,a4
20403db0:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = successor->prev;
20403db4:	0047a703          	lw	a4,4(a5)
20403db8:	00d7a823          	sw	a3,16(a5)
	node->next = successor;
20403dbc:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
20403dc0:	00e42223          	sw	a4,4(s0)
	prev->next = node;
20403dc4:	00872023          	sw	s0,0(a4)
	successor->prev = node;
20403dc8:	0087a223          	sw	s0,4(a5)
	return list->head == list;
20403dcc:	00062783          	lw	a5,0(a2)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20403dd0:	02c78263          	beq	a5,a2,20403df4 <z_add_timeout+0x18c>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
20403dd4:	02f41063          	bne	s0,a5,20403df4 <z_add_timeout+0x18c>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
20403dd8:	db1ff0ef          	jal	ra,20403b88 <next_timeout>

			if (next_time == 0 ||
20403ddc:	00050863          	beqz	a0,20403dec <z_add_timeout+0x184>
			    _current_cpu->slice_ticks != next_time) {
20403de0:	800007b7          	lui	a5,0x80000
			if (next_time == 0 ||
20403de4:	1447a783          	lw	a5,324(a5) # 80000144 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000145>
20403de8:	00a78663          	beq	a5,a0,20403df4 <z_add_timeout+0x18c>
				sys_clock_set_timeout(next_time, false);
20403dec:	00000593          	li	a1,0
20403df0:	de9fe0ef          	jal	ra,20402bd8 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403df4:	30092973          	csrrs	s2,mstatus,s2
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
20403df8:	01c12083          	lw	ra,28(sp)
20403dfc:	01812403          	lw	s0,24(sp)
20403e00:	01412483          	lw	s1,20(sp)
20403e04:	01012903          	lw	s2,16(sp)
20403e08:	00c12983          	lw	s3,12(sp)
20403e0c:	02010113          	addi	sp,sp,32
20403e10:	00008067          	ret

20403e14 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
20403e14:	ff010113          	addi	sp,sp,-16
20403e18:	00812423          	sw	s0,8(sp)
20403e1c:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403e20:	00800413          	li	s0,8
20403e24:	30043473          	csrrc	s0,mstatus,s0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
20403e28:	00052783          	lw	a5,0(a0)
	key = (mstatus & MSTATUS_IEN);
20403e2c:	00847413          	andi	s0,s0,8
20403e30:	02078063          	beqz	a5,20403e50 <z_abort_timeout+0x3c>
			remove_timeout(to);
20403e34:	de1ff0ef          	jal	ra,20403c14 <remove_timeout>
			ret = 0;
20403e38:	00000513          	li	a0,0
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403e3c:	30042473          	csrrs	s0,mstatus,s0
		}
	}

	return ret;
}
20403e40:	00c12083          	lw	ra,12(sp)
20403e44:	00812403          	lw	s0,8(sp)
20403e48:	01010113          	addi	sp,sp,16
20403e4c:	00008067          	ret
	int ret = -EINVAL;
20403e50:	fea00513          	li	a0,-22
20403e54:	fe9ff06f          	j	20403e3c <z_abort_timeout+0x28>

20403e58 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
20403e58:	fe010113          	addi	sp,sp,-32
20403e5c:	00812c23          	sw	s0,24(sp)
20403e60:	00912a23          	sw	s1,20(sp)
20403e64:	00112e23          	sw	ra,28(sp)
20403e68:	00050493          	mv	s1,a0
20403e6c:	00b12623          	sw	a1,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403e70:	00800413          	li	s0,8
20403e74:	30043473          	csrrc	s0,mstatus,s0
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
20403e78:	d11ff0ef          	jal	ra,20403b88 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
20403e7c:	00100793          	li	a5,1
	key = (mstatus & MSTATUS_IEN);
20403e80:	00847413          	andi	s0,s0,8
20403e84:	00a7da63          	bge	a5,a0,20403e98 <z_set_timeout_expiry+0x40>
20403e88:	00c12583          	lw	a1,12(sp)
20403e8c:	00954663          	blt	a0,s1,20403e98 <z_set_timeout_expiry+0x40>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
20403e90:	00048513          	mv	a0,s1
20403e94:	d45fe0ef          	jal	ra,20402bd8 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403e98:	30042473          	csrrs	s0,mstatus,s0
		}
	}
}
20403e9c:	01c12083          	lw	ra,28(sp)
20403ea0:	01812403          	lw	s0,24(sp)
20403ea4:	01412483          	lw	s1,20(sp)
20403ea8:	02010113          	addi	sp,sp,32
20403eac:	00008067          	ret

20403eb0 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
20403eb0:	fd010113          	addi	sp,sp,-48
20403eb4:	02812423          	sw	s0,40(sp)
20403eb8:	02912223          	sw	s1,36(sp)
20403ebc:	02112623          	sw	ra,44(sp)
20403ec0:	03212023          	sw	s2,32(sp)
20403ec4:	01312e23          	sw	s3,28(sp)
20403ec8:	01412c23          	sw	s4,24(sp)
20403ecc:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403ed0:	00800413          	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
20403ed4:	ef0ff0ef          	jal	ra,204035c4 <z_time_slice>
20403ed8:	30043473          	csrrc	s0,mstatus,s0
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
20403edc:	80000937          	lui	s2,0x80000
20403ee0:	02992023          	sw	s1,32(s2) # 80000020 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000021>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
20403ee4:	800004b7          	lui	s1,0x80000
	key = (mstatus & MSTATUS_IEN);
20403ee8:	00847413          	andi	s0,s0,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
20403eec:	02090913          	addi	s2,s2,32
	return list->head == list;
20403ef0:	82018993          	addi	s3,gp,-2016 # 80001028 <timeout_list>
		curr_tick += dt;
20403ef4:	00848493          	addi	s1,s1,8 # 80000008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000009>
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403ef8:	00800a13          	li	s4,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
20403efc:	00092783          	lw	a5,0(s2)
20403f00:	0009a503          	lw	a0,0(s3)
		curr_tick += dt;
20403f04:	0004a683          	lw	a3,0(s1)
20403f08:	0044a883          	lw	a7,4(s1)
20403f0c:	41f7d593          	srai	a1,a5,0x1f
	return sys_dlist_is_empty(list) ? NULL : list->head;
20403f10:	03350a63          	beq	a0,s3,20403f44 <sys_clock_announce+0x94>
	while (first() != NULL && first()->dticks <= announce_remaining) {
20403f14:	02050863          	beqz	a0,20403f44 <sys_clock_announce+0x94>
20403f18:	01452603          	lw	a2,20(a0)
20403f1c:	01052703          	lw	a4,16(a0)
20403f20:	00c5c663          	blt	a1,a2,20403f2c <sys_clock_announce+0x7c>
20403f24:	06b61663          	bne	a2,a1,20403f90 <sys_clock_announce+0xe0>
20403f28:	06e7f463          	bgeu	a5,a4,20403f90 <sys_clock_announce+0xe0>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
20403f2c:	40f70833          	sub	a6,a4,a5
20403f30:	01073733          	sltu	a4,a4,a6
20403f34:	40b60633          	sub	a2,a2,a1
20403f38:	40e60733          	sub	a4,a2,a4
20403f3c:	01052823          	sw	a6,16(a0)
20403f40:	00e52a23          	sw	a4,20(a0)
	}

	curr_tick += announce_remaining;
20403f44:	00d786b3          	add	a3,a5,a3
20403f48:	011585b3          	add	a1,a1,a7
20403f4c:	00f6b7b3          	sltu	a5,a3,a5
20403f50:	00b787b3          	add	a5,a5,a1
20403f54:	00d4a023          	sw	a3,0(s1)
20403f58:	00f4a223          	sw	a5,4(s1)
	announce_remaining = 0;
20403f5c:	00092023          	sw	zero,0(s2)

	sys_clock_set_timeout(next_timeout(), false);
20403f60:	c29ff0ef          	jal	ra,20403b88 <next_timeout>
20403f64:	00000593          	li	a1,0
20403f68:	c71fe0ef          	jal	ra,20402bd8 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20403f6c:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
20403f70:	02c12083          	lw	ra,44(sp)
20403f74:	02812403          	lw	s0,40(sp)
20403f78:	02412483          	lw	s1,36(sp)
20403f7c:	02012903          	lw	s2,32(sp)
20403f80:	01c12983          	lw	s3,28(sp)
20403f84:	01812a03          	lw	s4,24(sp)
20403f88:	03010113          	addi	sp,sp,48
20403f8c:	00008067          	ret
		curr_tick += dt;
20403f90:	00d706b3          	add	a3,a4,a3
		announce_remaining -= dt;
20403f94:	40e787b3          	sub	a5,a5,a4
		curr_tick += dt;
20403f98:	41f75593          	srai	a1,a4,0x1f
20403f9c:	00e6b633          	sltu	a2,a3,a4
20403fa0:	011585b3          	add	a1,a1,a7
		announce_remaining -= dt;
20403fa4:	00f92023          	sw	a5,0(s2)
		t->dticks = 0;
20403fa8:	00000813          	li	a6,0
20403fac:	00000793          	li	a5,0
		curr_tick += dt;
20403fb0:	00b605b3          	add	a1,a2,a1
		t->dticks = 0;
20403fb4:	00f52823          	sw	a5,16(a0)
20403fb8:	01052a23          	sw	a6,20(a0)
		curr_tick += dt;
20403fbc:	00d4a023          	sw	a3,0(s1)
20403fc0:	00b4a223          	sw	a1,4(s1)
		remove_timeout(t);
20403fc4:	00a12623          	sw	a0,12(sp)
20403fc8:	c4dff0ef          	jal	ra,20403c14 <remove_timeout>
20403fcc:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
20403fd0:	00c12503          	lw	a0,12(sp)
20403fd4:	00852783          	lw	a5,8(a0)
20403fd8:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
20403fdc:	300a3473          	csrrc	s0,mstatus,s4
	key = (mstatus & MSTATUS_IEN);
20403fe0:	00847413          	andi	s0,s0,8
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
20403fe4:	f19ff06f          	j	20403efc <sys_clock_announce+0x4c>

20403fe8 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
20403fe8:	04050e63          	beqz	a0,20404044 <z_impl_k_busy_wait+0x5c>
{
20403fec:	ff010113          	addi	sp,sp,-16
20403ff0:	00112623          	sw	ra,12(sp)
20403ff4:	00812423          	sw	s0,8(sp)
20403ff8:	00912223          	sw	s1,4(sp)
20403ffc:	00050413          	mv	s0,a0

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
20404000:	cf5fe0ef          	jal	ra,20402cf4 <sys_clock_cycle_get_32>
	uint32_t start_cycles = k_cycle_get_32();

	/* use 64-bit math to prevent overflow when multiplying */
	uint32_t cycles_to_wait = (uint32_t)(
		(uint64_t)usec_to_wait *
		(uint64_t)sys_clock_hw_cycles_per_sec() /
20404004:	000f4637          	lui	a2,0xf4
20404008:	01145593          	srli	a1,s0,0x11
2040400c:	00050493          	mv	s1,a0
20404010:	24060613          	addi	a2,a2,576 # f4240 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xec240>
20404014:	00f41513          	slli	a0,s0,0xf
20404018:	00000693          	li	a3,0
2040401c:	ac8fc0ef          	jal	ra,204002e4 <__udivdi3>
20404020:	00050413          	mv	s0,a0
20404024:	cd1fe0ef          	jal	ra,20402cf4 <sys_clock_cycle_get_32>

	for (;;) {
		uint32_t current_cycles = k_cycle_get_32();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
20404028:	409507b3          	sub	a5,a0,s1
2040402c:	fe87ece3          	bltu	a5,s0,20404024 <z_impl_k_busy_wait+0x3c>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
20404030:	00c12083          	lw	ra,12(sp)
20404034:	00812403          	lw	s0,8(sp)
20404038:	00412483          	lw	s1,4(sp)
2040403c:	01010113          	addi	sp,sp,16
20404040:	00008067          	ret
20404044:	00008067          	ret

20404048 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
20404048:	20404637          	lui	a2,0x20404
2040404c:	204045b7          	lui	a1,0x20404
20404050:	20404537          	lui	a0,0x20404
20404054:	44060613          	addi	a2,a2,1088 # 20404440 <__clz_tab+0x118>
20404058:	5e058593          	addi	a1,a1,1504 # 204045e0 <levels.0+0x1c>
2040405c:	5f050513          	addi	a0,a0,1520 # 204045f0 <levels.0+0x2c>
20404060:	b31fc06f          	j	20400b90 <printk>
