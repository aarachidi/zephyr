
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

20400000 <__start>:
SECTION_FUNC(vectors, __start)
#if defined(CONFIG_RISCV_GP)
	/* Initialize global pointer */
	.option push
	.option norelax
	la gp, __global_pointer$
20400000:	5fc02197          	auipc	gp,0x5fc02
20400004:	69818193          	addi	gp,gp,1688 # 80002698 <__global_pointer$>

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
20400008:	00000297          	auipc	t0,0x0
2040000c:	01c28293          	addi	t0,t0,28 # 20400024 <__irq_wrapper>
	csrw mtvec, t0
20400010:	30529073          	csrw	mtvec,t0

	/* Jump to __reset */
	tail __reset
20400014:	00c0006f          	j	20400020 <__reset>

Disassembly of section reset:

20400020 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
20400020:	131020ef          	jal	ra,20402950 <__initialize>

Disassembly of section exceptions:

20400024 <__irq_wrapper>:
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	STORE_CALLER_SAVED()
20400024:	fb010113          	addi	sp,sp,-80
20400028:	00112023          	sw	ra,0(sp)
2040002c:	00412223          	sw	tp,4(sp)
20400030:	00512423          	sw	t0,8(sp)
20400034:	00612623          	sw	t1,12(sp)
20400038:	00712823          	sw	t2,16(sp)
2040003c:	01c12a23          	sw	t3,20(sp)
20400040:	01d12c23          	sw	t4,24(sp)
20400044:	01e12e23          	sw	t5,28(sp)
20400048:	03f12023          	sw	t6,32(sp)
2040004c:	02a12223          	sw	a0,36(sp)
20400050:	02b12423          	sw	a1,40(sp)
20400054:	02c12623          	sw	a2,44(sp)
20400058:	02d12823          	sw	a3,48(sp)
2040005c:	02e12a23          	sw	a4,52(sp)
20400060:	02f12c23          	sw	a5,56(sp)
20400064:	03012e23          	sw	a6,60(sp)
20400068:	05112023          	sw	a7,64(sp)

skip_store_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Save MEPC register */
	csrr t0, mepc
2040006c:	341022f3          	csrr	t0,mepc
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
20400070:	04512223          	sw	t0,68(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, mstatus
20400074:	300022f3          	csrr	t0,mstatus
	RV_OP_STOREREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
20400078:	04512423          	sw	t0,72(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
2040007c:	228000ef          	jal	ra,204002a4 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
20400080:	00000313          	li	t1,0
	bnez a0, is_interrupt
20400084:	02051e63          	bnez	a0,204000c0 <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
20400088:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
2040008c:	800003b7          	lui	t2,0x80000
20400090:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
20400094:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
20400098:	00b00313          	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	beq t0, t1, is_kernel_syscall
2040009c:	00628a63          	beq	t0,t1,204000b0 <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	addi a0, sp, 0
204000a0:	00010513          	mv	a0,sp
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
	RV_OP_LOADREG t0, _thread_offset_to_priv_stack_start(t1)
	RV_OP_STOREREG sp, _thread_offset_to_user_sp(t1) /* Update user SP */
	addi sp, t0, CONFIG_PRIVILEGED_STACK_SIZE
#else
	la ra, no_reschedule
204000a4:	00000097          	auipc	ra,0x0
204000a8:	19408093          	addi	ra,ra,404 # 20400238 <no_reschedule>
#endif /* CONFIG_USERSPACE */

	tail _Fault
204000ac:	0450206f          	j	204028f0 <_Fault>

204000b0 <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
204000b0:	04412283          	lw	t0,68(sp)
	addi t0, t0, 4
204000b4:	00428293          	addi	t0,t0,4
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
204000b8:	04512223          	sw	t0,68(sp)
	j z_riscv_user_mode_enter_syscall
#endif /* CONFIG_USERSPACE */
	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
204000bc:	0800006f          	j	2040013c <reschedule>

204000c0 <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
204000c0:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
204000c4:	5fc00397          	auipc	t2,0x5fc00
204000c8:	20838393          	addi	t2,t2,520 # 800002cc <_kernel>
	RV_OP_LOADREG sp, _kernel_offset_to_irq_stack(t2)
204000cc:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
204000d0:	ff010113          	addi	sp,sp,-16
	RV_OP_STOREREG t0, 0x00(sp)
204000d4:	00512023          	sw	t0,0(sp)

204000d8 <on_irq_stack>:
	la t2, _kernel
#endif /* !CONFIG_USERSPACE && !CONFIG_PMP_STACK_GUARD */

on_irq_stack:
	/* Increment _kernel.cpus[0].nested variable */
	lw t3, _kernel_offset_to_nested(t2)
204000d8:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
204000dc:	001e0e13          	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
204000e0:	01c3a023          	sw	t3,0(t2)
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
204000e4:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
204000e8:	800002b7          	lui	t0,0x80000
204000ec:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
204000f0:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
204000f4:	1a0000ef          	jal	ra,20400294 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
204000f8:	00008297          	auipc	t0,0x8
204000fc:	f1428293          	addi	t0,t0,-236 # 2040800c <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
20400100:	00351513          	slli	a0,a0,0x3
	add t0, t0, a0
20400104:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	RV_OP_LOADREG a0, 0x00(t0)
20400108:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	RV_OP_LOADREG t1, RV_REGSIZE(t0)
2040010c:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1
20400110:	000300e7          	jalr	t1

20400114 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
20400114:	5fc00317          	auipc	t1,0x5fc00
20400118:	1b830313          	addi	t1,t1,440 # 800002cc <_kernel>

	/* Decrement _kernel.cpus[0].nested variable */
	lw t2, _kernel_offset_to_nested(t1)
2040011c:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
20400120:	fff38393          	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
20400124:	00732023          	sw	t2,0(t1)

#if !defined(CONFIG_USERSPACE) && !defined(CONFIG_PMP_STACK_GUARD)
	/* Restore thread stack pointer */
	RV_OP_LOADREG t0, 0x00(sp)
20400128:	00012283          	lw	t0,0(sp)
	addi sp, t0, 0
2040012c:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t2, _kernel_offset_to_current(t1)
20400130:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t1)
20400134:	01832e03          	lw	t3,24(t1)
	beq t3, t2, no_reschedule
20400138:	107e0063          	beq	t3,t2,20400238 <no_reschedule>

2040013c <reschedule>:
	 * Note:
	 *   Sometimes this code is execute back-to-back before the target thread
	 *   has a chance to run. If this happens, the current thread and the
	 *   target thread will be the same.
	 */
	la t0, _kernel
2040013c:	5fc00297          	auipc	t0,0x5fc00
20400140:	19028293          	addi	t0,t0,400 # 800002cc <_kernel>
	RV_OP_LOADREG t2, _kernel_offset_to_current(t0)
20400144:	0082a383          	lw	t2,8(t0)
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t0)
20400148:	0182ae03          	lw	t3,24(t0)
	beq t2, t3, no_reschedule
2040014c:	0fc38663          	beq	t2,t3,20400238 <no_reschedule>

#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	call z_thread_mark_switched_out
#endif
	/* Get reference to _kernel */
	la t0, _kernel
20400150:	5fc00297          	auipc	t0,0x5fc00
20400154:	17c28293          	addi	t0,t0,380 # 800002cc <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
20400158:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current kernel thread
	 * prior to handle context-switching
	 */
	STORE_CALLEE_SAVED(t1)
2040015c:	02832a23          	sw	s0,52(t1)
20400160:	02932c23          	sw	s1,56(t1)
20400164:	03232e23          	sw	s2,60(t1)
20400168:	05332023          	sw	s3,64(t1)
2040016c:	05432223          	sw	s4,68(t1)
20400170:	05532423          	sw	s5,72(t1)
20400174:	05632623          	sw	s6,76(t1)
20400178:	05732823          	sw	s7,80(t1)
2040017c:	05832a23          	sw	s8,84(t1)
20400180:	05932c23          	sw	s9,88(t1)
20400184:	05a32e23          	sw	s10,92(t1)
20400188:	07b32023          	sw	s11,96(t1)

2040018c <skip_callee_saved_reg>:

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	RV_OP_STOREREG sp, _thread_offset_to_sp(t1)
2040018c:	02232823          	sw	sp,48(t1)
	la t2, _k_neg_eagain
20400190:	00008397          	auipc	t2,0x8
20400194:	0b438393          	addi	t2,t2,180 # 20408244 <_k_neg_eagain>
	lw t3, 0x00(t2)
20400198:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
2040019c:	07c32c23          	sw	t3,120(t1)

	/* Get next thread to schedule. */
	RV_OP_LOADREG t1, _kernel_offset_to_ready_q_cache(t0)
204001a0:	0182a303          	lw	t1,24(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	RV_OP_STOREREG t1, _kernel_offset_to_current(t0)
204001a4:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	RV_OP_LOADREG sp, _thread_offset_to_sp(t1)
204001a8:	03032103          	lw	sp,48(t1)

	/* Restore callee-saved registers of new thread */
	LOAD_CALLEE_SAVED(t1)
204001ac:	03432403          	lw	s0,52(t1)
204001b0:	03832483          	lw	s1,56(t1)
204001b4:	03c32903          	lw	s2,60(t1)
204001b8:	04032983          	lw	s3,64(t1)
204001bc:	04432a03          	lw	s4,68(t1)
204001c0:	04832a83          	lw	s5,72(t1)
204001c4:	04c32b03          	lw	s6,76(t1)
204001c8:	05032b83          	lw	s7,80(t1)
204001cc:	05432c03          	lw	s8,84(t1)
204001d0:	05832c83          	lw	s9,88(t1)
204001d4:	05c32d03          	lw	s10,92(t1)
204001d8:	06032d83          	lw	s11,96(t1)
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
204001dc:	04412283          	lw	t0,68(sp)
	csrw mepc, t0
204001e0:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
204001e4:	04812283          	lw	t0,72(sp)
	csrw mstatus, t0
204001e8:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved_resched:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
204001ec:	00012083          	lw	ra,0(sp)
204001f0:	00412203          	lw	tp,4(sp)
204001f4:	00812283          	lw	t0,8(sp)
204001f8:	00c12303          	lw	t1,12(sp)
204001fc:	01012383          	lw	t2,16(sp)
20400200:	01412e03          	lw	t3,20(sp)
20400204:	01812e83          	lw	t4,24(sp)
20400208:	01c12f03          	lw	t5,28(sp)
2040020c:	02012f83          	lw	t6,32(sp)
20400210:	02412503          	lw	a0,36(sp)
20400214:	02812583          	lw	a1,40(sp)
20400218:	02c12603          	lw	a2,44(sp)
2040021c:	03012683          	lw	a3,48(sp)
20400220:	03412703          	lw	a4,52(sp)
20400224:	03812783          	lw	a5,56(sp)
20400228:	03c12803          	lw	a6,60(sp)
2040022c:	04012883          	lw	a7,64(sp)
20400230:	05010113          	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
20400234:	30200073          	mret

20400238 <no_reschedule>:
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
20400238:	04412283          	lw	t0,68(sp)
	csrw mepc, t0
2040023c:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
20400240:	04812283          	lw	t0,72(sp)
	csrw mstatus, t0
20400244:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
20400248:	00012083          	lw	ra,0(sp)
2040024c:	00412203          	lw	tp,4(sp)
20400250:	00812283          	lw	t0,8(sp)
20400254:	00c12303          	lw	t1,12(sp)
20400258:	01012383          	lw	t2,16(sp)
2040025c:	01412e03          	lw	t3,20(sp)
20400260:	01812e83          	lw	t4,24(sp)
20400264:	01c12f03          	lw	t5,28(sp)
20400268:	02012f83          	lw	t6,32(sp)
2040026c:	02412503          	lw	a0,36(sp)
20400270:	02812583          	lw	a1,40(sp)
20400274:	02c12603          	lw	a2,44(sp)
20400278:	03012683          	lw	a3,48(sp)
2040027c:	03412703          	lw	a4,52(sp)
20400280:	03812783          	lw	a5,56(sp)
20400284:	03c12803          	lw	a6,60(sp)
20400288:	04012883          	lw	a7,64(sp)
2040028c:	05010113          	addi	sp,sp,80

#ifdef CONFIG_PMP_STACK_GUARD
	csrrw sp, mscratch, sp
#endif /* CONFIG_PMP_STACK_GUARD */
	/* Call SOC_ERET to exit ISR */
	SOC_ERET
20400290:	30200073          	mret

20400294 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
20400294:	00100313          	li	t1,1
	sll t0, t1, a0
20400298:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
2040029c:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
204002a0:	00008067          	ret

204002a4 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
204002a4:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
204002a8:	80000337          	lui	t1,0x80000
	and t0, t0, t1
204002ac:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
204002b0:	00000513          	li	a0,0
	beqz t0, not_interrupt
204002b4:	00028463          	beqz	t0,204002bc <not_interrupt>
	addi a0, a0, 1
204002b8:	00150513          	addi	a0,a0,1

204002bc <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
204002bc:	00008067          	ret

204002c0 <arch_swap>:
 * key is stored in a0 register
 */
SECTION_FUNC(exception.other, arch_swap)

	/* Make a system call to perform context switch */
	ecall
204002c0:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * arch_swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called arch_thread_return_value_set(..).
	 */
	la t0, _kernel
204002c4:	5fc00297          	auipc	t0,0x5fc00
204002c8:	00828293          	addi	t0,t0,8 # 800002cc <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
204002cc:	0082a303          	lw	t1,8(t0)

	/* Load return value of arch_swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
204002d0:	07832383          	lw	t2,120(t1) # 80000078 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000079>

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, MSTATUS_IEN
204002d4:	00857513          	andi	a0,a0,8
	csrrs t0, mstatus, a0
204002d8:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
204002dc:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
204002e0:	00008067          	ret

Disassembly of section text:

204002e4 <__clzsi2>:
204002e4:	000107b7          	lui	a5,0x10
204002e8:	02f57a63          	bgeu	a0,a5,2040031c <__clzsi2+0x38>
204002ec:	0ff00793          	li	a5,255
204002f0:	00a7b7b3          	sltu	a5,a5,a0
204002f4:	00379793          	slli	a5,a5,0x3
204002f8:	20408737          	lui	a4,0x20408
204002fc:	02000693          	li	a3,32
20400300:	40f686b3          	sub	a3,a3,a5
20400304:	00f55533          	srl	a0,a0,a5
20400308:	24870793          	addi	a5,a4,584 # 20408248 <__clz_tab>
2040030c:	00a78533          	add	a0,a5,a0
20400310:	00054503          	lbu	a0,0(a0)
20400314:	40a68533          	sub	a0,a3,a0
20400318:	00008067          	ret
2040031c:	01000737          	lui	a4,0x1000
20400320:	01000793          	li	a5,16
20400324:	fce56ae3          	bltu	a0,a4,204002f8 <__clzsi2+0x14>
20400328:	01800793          	li	a5,24
2040032c:	fcdff06f          	j	204002f8 <__clzsi2+0x14>

20400330 <__ctzsi2>:
20400330:	40a007b3          	neg	a5,a0
20400334:	00a7f533          	and	a0,a5,a0
20400338:	000107b7          	lui	a5,0x10
2040033c:	02f57863          	bgeu	a0,a5,2040036c <__ctzsi2+0x3c>
20400340:	0ff00793          	li	a5,255
20400344:	00a7b7b3          	sltu	a5,a5,a0
20400348:	00379793          	slli	a5,a5,0x3
2040034c:	20408737          	lui	a4,0x20408
20400350:	00f55533          	srl	a0,a0,a5
20400354:	24870713          	addi	a4,a4,584 # 20408248 <__clz_tab>
20400358:	00a70533          	add	a0,a4,a0
2040035c:	00054503          	lbu	a0,0(a0)
20400360:	fff78793          	addi	a5,a5,-1 # ffff <__rom_region_size+0x6d43>
20400364:	00f50533          	add	a0,a0,a5
20400368:	00008067          	ret
2040036c:	01000737          	lui	a4,0x1000
20400370:	01000793          	li	a5,16
20400374:	fce56ce3          	bltu	a0,a4,2040034c <__ctzsi2+0x1c>
20400378:	01800793          	li	a5,24
2040037c:	fd1ff06f          	j	2040034c <__ctzsi2+0x1c>

20400380 <__udivdi3>:
20400380:	00050893          	mv	a7,a0
20400384:	00058793          	mv	a5,a1
20400388:	00060813          	mv	a6,a2
2040038c:	00068513          	mv	a0,a3
20400390:	00088313          	mv	t1,a7
20400394:	28069463          	bnez	a3,2040061c <__udivdi3+0x29c>
20400398:	204086b7          	lui	a3,0x20408
2040039c:	24868693          	addi	a3,a3,584 # 20408248 <__clz_tab>
204003a0:	0ec5f663          	bgeu	a1,a2,2040048c <__udivdi3+0x10c>
204003a4:	00010737          	lui	a4,0x10
204003a8:	0ce67863          	bgeu	a2,a4,20400478 <__udivdi3+0xf8>
204003ac:	0ff00713          	li	a4,255
204003b0:	00c73733          	sltu	a4,a4,a2
204003b4:	00371713          	slli	a4,a4,0x3
204003b8:	00e65533          	srl	a0,a2,a4
204003bc:	00a686b3          	add	a3,a3,a0
204003c0:	0006c683          	lbu	a3,0(a3)
204003c4:	02000513          	li	a0,32
204003c8:	00e68733          	add	a4,a3,a4
204003cc:	40e506b3          	sub	a3,a0,a4
204003d0:	00e50c63          	beq	a0,a4,204003e8 <__udivdi3+0x68>
204003d4:	00d795b3          	sll	a1,a5,a3
204003d8:	00e8d733          	srl	a4,a7,a4
204003dc:	00d61833          	sll	a6,a2,a3
204003e0:	00b765b3          	or	a1,a4,a1
204003e4:	00d89333          	sll	t1,a7,a3
204003e8:	01085893          	srli	a7,a6,0x10
204003ec:	0315d6b3          	divu	a3,a1,a7
204003f0:	01081613          	slli	a2,a6,0x10
204003f4:	01065613          	srli	a2,a2,0x10
204003f8:	01035793          	srli	a5,t1,0x10
204003fc:	0315f733          	remu	a4,a1,a7
20400400:	00068513          	mv	a0,a3
20400404:	02d605b3          	mul	a1,a2,a3
20400408:	01071713          	slli	a4,a4,0x10
2040040c:	00f767b3          	or	a5,a4,a5
20400410:	00b7fe63          	bgeu	a5,a1,2040042c <__udivdi3+0xac>
20400414:	010787b3          	add	a5,a5,a6
20400418:	fff68513          	addi	a0,a3,-1
2040041c:	0107e863          	bltu	a5,a6,2040042c <__udivdi3+0xac>
20400420:	00b7f663          	bgeu	a5,a1,2040042c <__udivdi3+0xac>
20400424:	ffe68513          	addi	a0,a3,-2
20400428:	010787b3          	add	a5,a5,a6
2040042c:	40b787b3          	sub	a5,a5,a1
20400430:	0317f733          	remu	a4,a5,a7
20400434:	01031313          	slli	t1,t1,0x10
20400438:	01035313          	srli	t1,t1,0x10
2040043c:	0317d7b3          	divu	a5,a5,a7
20400440:	01071713          	slli	a4,a4,0x10
20400444:	00676333          	or	t1,a4,t1
20400448:	02f606b3          	mul	a3,a2,a5
2040044c:	00078613          	mv	a2,a5
20400450:	00d37c63          	bgeu	t1,a3,20400468 <__udivdi3+0xe8>
20400454:	00680333          	add	t1,a6,t1
20400458:	fff78613          	addi	a2,a5,-1
2040045c:	01036663          	bltu	t1,a6,20400468 <__udivdi3+0xe8>
20400460:	00d37463          	bgeu	t1,a3,20400468 <__udivdi3+0xe8>
20400464:	ffe78613          	addi	a2,a5,-2
20400468:	01051513          	slli	a0,a0,0x10
2040046c:	00c56533          	or	a0,a0,a2
20400470:	00000593          	li	a1,0
20400474:	0e40006f          	j	20400558 <__udivdi3+0x1d8>
20400478:	01000537          	lui	a0,0x1000
2040047c:	01000713          	li	a4,16
20400480:	f2a66ce3          	bltu	a2,a0,204003b8 <__udivdi3+0x38>
20400484:	01800713          	li	a4,24
20400488:	f31ff06f          	j	204003b8 <__udivdi3+0x38>
2040048c:	00061663          	bnez	a2,20400498 <__udivdi3+0x118>
20400490:	00100713          	li	a4,1
20400494:	02c75833          	divu	a6,a4,a2
20400498:	00010737          	lui	a4,0x10
2040049c:	0ce87063          	bgeu	a6,a4,2040055c <__udivdi3+0x1dc>
204004a0:	0ff00713          	li	a4,255
204004a4:	01077463          	bgeu	a4,a6,204004ac <__udivdi3+0x12c>
204004a8:	00800513          	li	a0,8
204004ac:	00a85733          	srl	a4,a6,a0
204004b0:	00e686b3          	add	a3,a3,a4
204004b4:	0006c703          	lbu	a4,0(a3)
204004b8:	02000613          	li	a2,32
204004bc:	00a70733          	add	a4,a4,a0
204004c0:	40e606b3          	sub	a3,a2,a4
204004c4:	0ae61663          	bne	a2,a4,20400570 <__udivdi3+0x1f0>
204004c8:	410787b3          	sub	a5,a5,a6
204004cc:	00100593          	li	a1,1
204004d0:	01085893          	srli	a7,a6,0x10
204004d4:	01081613          	slli	a2,a6,0x10
204004d8:	01065613          	srli	a2,a2,0x10
204004dc:	01035713          	srli	a4,t1,0x10
204004e0:	0317f6b3          	remu	a3,a5,a7
204004e4:	0317d7b3          	divu	a5,a5,a7
204004e8:	01069693          	slli	a3,a3,0x10
204004ec:	00e6e733          	or	a4,a3,a4
204004f0:	02f60e33          	mul	t3,a2,a5
204004f4:	00078513          	mv	a0,a5
204004f8:	01c77e63          	bgeu	a4,t3,20400514 <__udivdi3+0x194>
204004fc:	01070733          	add	a4,a4,a6
20400500:	fff78513          	addi	a0,a5,-1
20400504:	01076863          	bltu	a4,a6,20400514 <__udivdi3+0x194>
20400508:	01c77663          	bgeu	a4,t3,20400514 <__udivdi3+0x194>
2040050c:	ffe78513          	addi	a0,a5,-2
20400510:	01070733          	add	a4,a4,a6
20400514:	41c70733          	sub	a4,a4,t3
20400518:	031777b3          	remu	a5,a4,a7
2040051c:	01031313          	slli	t1,t1,0x10
20400520:	01035313          	srli	t1,t1,0x10
20400524:	03175733          	divu	a4,a4,a7
20400528:	01079793          	slli	a5,a5,0x10
2040052c:	0067e333          	or	t1,a5,t1
20400530:	02e606b3          	mul	a3,a2,a4
20400534:	00070613          	mv	a2,a4
20400538:	00d37c63          	bgeu	t1,a3,20400550 <__udivdi3+0x1d0>
2040053c:	00680333          	add	t1,a6,t1
20400540:	fff70613          	addi	a2,a4,-1 # ffff <__rom_region_size+0x6d43>
20400544:	01036663          	bltu	t1,a6,20400550 <__udivdi3+0x1d0>
20400548:	00d37463          	bgeu	t1,a3,20400550 <__udivdi3+0x1d0>
2040054c:	ffe70613          	addi	a2,a4,-2
20400550:	01051513          	slli	a0,a0,0x10
20400554:	00c56533          	or	a0,a0,a2
20400558:	00008067          	ret
2040055c:	01000737          	lui	a4,0x1000
20400560:	01000513          	li	a0,16
20400564:	f4e864e3          	bltu	a6,a4,204004ac <__udivdi3+0x12c>
20400568:	01800513          	li	a0,24
2040056c:	f41ff06f          	j	204004ac <__udivdi3+0x12c>
20400570:	00d81833          	sll	a6,a6,a3
20400574:	00e7d533          	srl	a0,a5,a4
20400578:	00d89333          	sll	t1,a7,a3
2040057c:	00d797b3          	sll	a5,a5,a3
20400580:	00e8d733          	srl	a4,a7,a4
20400584:	01085893          	srli	a7,a6,0x10
20400588:	00f76633          	or	a2,a4,a5
2040058c:	03157733          	remu	a4,a0,a7
20400590:	01081793          	slli	a5,a6,0x10
20400594:	0107d793          	srli	a5,a5,0x10
20400598:	01065593          	srli	a1,a2,0x10
2040059c:	03155533          	divu	a0,a0,a7
204005a0:	01071713          	slli	a4,a4,0x10
204005a4:	00b76733          	or	a4,a4,a1
204005a8:	02a786b3          	mul	a3,a5,a0
204005ac:	00050593          	mv	a1,a0
204005b0:	00d77e63          	bgeu	a4,a3,204005cc <__udivdi3+0x24c>
204005b4:	01070733          	add	a4,a4,a6
204005b8:	fff50593          	addi	a1,a0,-1 # ffffff <__rom_region_size+0xff6d43>
204005bc:	01076863          	bltu	a4,a6,204005cc <__udivdi3+0x24c>
204005c0:	00d77663          	bgeu	a4,a3,204005cc <__udivdi3+0x24c>
204005c4:	ffe50593          	addi	a1,a0,-2
204005c8:	01070733          	add	a4,a4,a6
204005cc:	40d706b3          	sub	a3,a4,a3
204005d0:	0316f733          	remu	a4,a3,a7
204005d4:	01061613          	slli	a2,a2,0x10
204005d8:	01065613          	srli	a2,a2,0x10
204005dc:	0316d6b3          	divu	a3,a3,a7
204005e0:	01071713          	slli	a4,a4,0x10
204005e4:	02d78533          	mul	a0,a5,a3
204005e8:	00c767b3          	or	a5,a4,a2
204005ec:	00068713          	mv	a4,a3
204005f0:	00a7fe63          	bgeu	a5,a0,2040060c <__udivdi3+0x28c>
204005f4:	010787b3          	add	a5,a5,a6
204005f8:	fff68713          	addi	a4,a3,-1
204005fc:	0107e863          	bltu	a5,a6,2040060c <__udivdi3+0x28c>
20400600:	00a7f663          	bgeu	a5,a0,2040060c <__udivdi3+0x28c>
20400604:	ffe68713          	addi	a4,a3,-2
20400608:	010787b3          	add	a5,a5,a6
2040060c:	01059593          	slli	a1,a1,0x10
20400610:	40a787b3          	sub	a5,a5,a0
20400614:	00e5e5b3          	or	a1,a1,a4
20400618:	eb9ff06f          	j	204004d0 <__udivdi3+0x150>
2040061c:	18d5e663          	bltu	a1,a3,204007a8 <__udivdi3+0x428>
20400620:	00010737          	lui	a4,0x10
20400624:	04e6f463          	bgeu	a3,a4,2040066c <__udivdi3+0x2ec>
20400628:	0ff00713          	li	a4,255
2040062c:	00d735b3          	sltu	a1,a4,a3
20400630:	00359593          	slli	a1,a1,0x3
20400634:	20408737          	lui	a4,0x20408
20400638:	00b6d533          	srl	a0,a3,a1
2040063c:	24870713          	addi	a4,a4,584 # 20408248 <__clz_tab>
20400640:	00a70733          	add	a4,a4,a0
20400644:	00074703          	lbu	a4,0(a4)
20400648:	02000513          	li	a0,32
2040064c:	00b70733          	add	a4,a4,a1
20400650:	40e505b3          	sub	a1,a0,a4
20400654:	02e51663          	bne	a0,a4,20400680 <__udivdi3+0x300>
20400658:	00100513          	li	a0,1
2040065c:	eef6eee3          	bltu	a3,a5,20400558 <__udivdi3+0x1d8>
20400660:	00c8b533          	sltu	a0,a7,a2
20400664:	00154513          	xori	a0,a0,1
20400668:	ef1ff06f          	j	20400558 <__udivdi3+0x1d8>
2040066c:	01000737          	lui	a4,0x1000
20400670:	01000593          	li	a1,16
20400674:	fce6e0e3          	bltu	a3,a4,20400634 <__udivdi3+0x2b4>
20400678:	01800593          	li	a1,24
2040067c:	fb9ff06f          	j	20400634 <__udivdi3+0x2b4>
20400680:	00e65833          	srl	a6,a2,a4
20400684:	00b696b3          	sll	a3,a3,a1
20400688:	00d86833          	or	a6,a6,a3
2040068c:	00e7de33          	srl	t3,a5,a4
20400690:	01085e93          	srli	t4,a6,0x10
20400694:	03de76b3          	remu	a3,t3,t4
20400698:	00b797b3          	sll	a5,a5,a1
2040069c:	00e8d733          	srl	a4,a7,a4
204006a0:	00b61333          	sll	t1,a2,a1
204006a4:	00f76633          	or	a2,a4,a5
204006a8:	01081793          	slli	a5,a6,0x10
204006ac:	0107d793          	srli	a5,a5,0x10
204006b0:	01065713          	srli	a4,a2,0x10
204006b4:	03de5e33          	divu	t3,t3,t4
204006b8:	01069693          	slli	a3,a3,0x10
204006bc:	00e6e733          	or	a4,a3,a4
204006c0:	03c78f33          	mul	t5,a5,t3
204006c4:	000e0513          	mv	a0,t3
204006c8:	01e77e63          	bgeu	a4,t5,204006e4 <__udivdi3+0x364>
204006cc:	01070733          	add	a4,a4,a6
204006d0:	fffe0513          	addi	a0,t3,-1
204006d4:	01076863          	bltu	a4,a6,204006e4 <__udivdi3+0x364>
204006d8:	01e77663          	bgeu	a4,t5,204006e4 <__udivdi3+0x364>
204006dc:	ffee0513          	addi	a0,t3,-2
204006e0:	01070733          	add	a4,a4,a6
204006e4:	41e70733          	sub	a4,a4,t5
204006e8:	03d776b3          	remu	a3,a4,t4
204006ec:	03d75733          	divu	a4,a4,t4
204006f0:	01069693          	slli	a3,a3,0x10
204006f4:	02e78e33          	mul	t3,a5,a4
204006f8:	01061793          	slli	a5,a2,0x10
204006fc:	0107d793          	srli	a5,a5,0x10
20400700:	00f6e7b3          	or	a5,a3,a5
20400704:	00070613          	mv	a2,a4
20400708:	01c7fe63          	bgeu	a5,t3,20400724 <__udivdi3+0x3a4>
2040070c:	010787b3          	add	a5,a5,a6
20400710:	fff70613          	addi	a2,a4,-1 # ffffff <__rom_region_size+0xff6d43>
20400714:	0107e863          	bltu	a5,a6,20400724 <__udivdi3+0x3a4>
20400718:	01c7f663          	bgeu	a5,t3,20400724 <__udivdi3+0x3a4>
2040071c:	ffe70613          	addi	a2,a4,-2
20400720:	010787b3          	add	a5,a5,a6
20400724:	01051513          	slli	a0,a0,0x10
20400728:	00010eb7          	lui	t4,0x10
2040072c:	00c56533          	or	a0,a0,a2
20400730:	fffe8693          	addi	a3,t4,-1 # ffff <__rom_region_size+0x6d43>
20400734:	00d57833          	and	a6,a0,a3
20400738:	01055613          	srli	a2,a0,0x10
2040073c:	00d376b3          	and	a3,t1,a3
20400740:	01035313          	srli	t1,t1,0x10
20400744:	41c787b3          	sub	a5,a5,t3
20400748:	02d80e33          	mul	t3,a6,a3
2040074c:	02d606b3          	mul	a3,a2,a3
20400750:	010e5713          	srli	a4,t3,0x10
20400754:	02680833          	mul	a6,a6,t1
20400758:	00d80833          	add	a6,a6,a3
2040075c:	01070733          	add	a4,a4,a6
20400760:	02660633          	mul	a2,a2,t1
20400764:	00d77463          	bgeu	a4,a3,2040076c <__udivdi3+0x3ec>
20400768:	01d60633          	add	a2,a2,t4
2040076c:	01075693          	srli	a3,a4,0x10
20400770:	00c68633          	add	a2,a3,a2
20400774:	02c7e663          	bltu	a5,a2,204007a0 <__udivdi3+0x420>
20400778:	cec79ce3          	bne	a5,a2,20400470 <__udivdi3+0xf0>
2040077c:	000107b7          	lui	a5,0x10
20400780:	fff78793          	addi	a5,a5,-1 # ffff <__rom_region_size+0x6d43>
20400784:	00f77733          	and	a4,a4,a5
20400788:	01071713          	slli	a4,a4,0x10
2040078c:	00fe7e33          	and	t3,t3,a5
20400790:	00b898b3          	sll	a7,a7,a1
20400794:	01c70733          	add	a4,a4,t3
20400798:	00000593          	li	a1,0
2040079c:	dae8fee3          	bgeu	a7,a4,20400558 <__udivdi3+0x1d8>
204007a0:	fff50513          	addi	a0,a0,-1
204007a4:	ccdff06f          	j	20400470 <__udivdi3+0xf0>
204007a8:	00000593          	li	a1,0
204007ac:	00000513          	li	a0,0
204007b0:	da9ff06f          	j	20400558 <__udivdi3+0x1d8>

204007b4 <__umoddi3>:
204007b4:	00050e93          	mv	t4,a0
204007b8:	00058313          	mv	t1,a1
204007bc:	00060813          	mv	a6,a2
204007c0:	00068793          	mv	a5,a3
204007c4:	22069a63          	bnez	a3,204009f8 <__umoddi3+0x244>
204007c8:	20408737          	lui	a4,0x20408
204007cc:	24870713          	addi	a4,a4,584 # 20408248 <__clz_tab>
204007d0:	0cc5fc63          	bgeu	a1,a2,204008a8 <__umoddi3+0xf4>
204007d4:	000106b7          	lui	a3,0x10
204007d8:	0ad67e63          	bgeu	a2,a3,20400894 <__umoddi3+0xe0>
204007dc:	0ff00693          	li	a3,255
204007e0:	00c6f463          	bgeu	a3,a2,204007e8 <__umoddi3+0x34>
204007e4:	00800793          	li	a5,8
204007e8:	00f656b3          	srl	a3,a2,a5
204007ec:	00d70733          	add	a4,a4,a3
204007f0:	00074703          	lbu	a4,0(a4)
204007f4:	00f707b3          	add	a5,a4,a5
204007f8:	02000713          	li	a4,32
204007fc:	40f708b3          	sub	a7,a4,a5
20400800:	00f70c63          	beq	a4,a5,20400818 <__umoddi3+0x64>
20400804:	011315b3          	sll	a1,t1,a7
20400808:	00fed7b3          	srl	a5,t4,a5
2040080c:	01161833          	sll	a6,a2,a7
20400810:	00b7e5b3          	or	a1,a5,a1
20400814:	011e9533          	sll	a0,t4,a7
20400818:	01085693          	srli	a3,a6,0x10
2040081c:	02d5f7b3          	remu	a5,a1,a3
20400820:	01081613          	slli	a2,a6,0x10
20400824:	01065613          	srli	a2,a2,0x10
20400828:	01055713          	srli	a4,a0,0x10
2040082c:	02d5d5b3          	divu	a1,a1,a3
20400830:	01079793          	slli	a5,a5,0x10
20400834:	00e7e733          	or	a4,a5,a4
20400838:	02b605b3          	mul	a1,a2,a1
2040083c:	00b77a63          	bgeu	a4,a1,20400850 <__umoddi3+0x9c>
20400840:	01070733          	add	a4,a4,a6
20400844:	01076663          	bltu	a4,a6,20400850 <__umoddi3+0x9c>
20400848:	00b77463          	bgeu	a4,a1,20400850 <__umoddi3+0x9c>
2040084c:	01070733          	add	a4,a4,a6
20400850:	40b70733          	sub	a4,a4,a1
20400854:	02d777b3          	remu	a5,a4,a3
20400858:	01051513          	slli	a0,a0,0x10
2040085c:	01055513          	srli	a0,a0,0x10
20400860:	02d75733          	divu	a4,a4,a3
20400864:	01079793          	slli	a5,a5,0x10
20400868:	00a7e533          	or	a0,a5,a0
2040086c:	02e60733          	mul	a4,a2,a4
20400870:	00e57a63          	bgeu	a0,a4,20400884 <__umoddi3+0xd0>
20400874:	01050533          	add	a0,a0,a6
20400878:	01056663          	bltu	a0,a6,20400884 <__umoddi3+0xd0>
2040087c:	00e57463          	bgeu	a0,a4,20400884 <__umoddi3+0xd0>
20400880:	01050533          	add	a0,a0,a6
20400884:	40e50533          	sub	a0,a0,a4
20400888:	01155533          	srl	a0,a0,a7
2040088c:	00000593          	li	a1,0
20400890:	00008067          	ret
20400894:	010006b7          	lui	a3,0x1000
20400898:	01000793          	li	a5,16
2040089c:	f4d666e3          	bltu	a2,a3,204007e8 <__umoddi3+0x34>
204008a0:	01800793          	li	a5,24
204008a4:	f45ff06f          	j	204007e8 <__umoddi3+0x34>
204008a8:	00061663          	bnez	a2,204008b4 <__umoddi3+0x100>
204008ac:	00100693          	li	a3,1
204008b0:	02c6d833          	divu	a6,a3,a2
204008b4:	000106b7          	lui	a3,0x10
204008b8:	12d87663          	bgeu	a6,a3,204009e4 <__umoddi3+0x230>
204008bc:	0ff00693          	li	a3,255
204008c0:	0106f463          	bgeu	a3,a6,204008c8 <__umoddi3+0x114>
204008c4:	00800793          	li	a5,8
204008c8:	00f856b3          	srl	a3,a6,a5
204008cc:	00d70733          	add	a4,a4,a3
204008d0:	00074603          	lbu	a2,0(a4)
204008d4:	410305b3          	sub	a1,t1,a6
204008d8:	00f60633          	add	a2,a2,a5
204008dc:	02000793          	li	a5,32
204008e0:	40c788b3          	sub	a7,a5,a2
204008e4:	08c78663          	beq	a5,a2,20400970 <__umoddi3+0x1bc>
204008e8:	01181833          	sll	a6,a6,a7
204008ec:	00c357b3          	srl	a5,t1,a2
204008f0:	011315b3          	sll	a1,t1,a7
204008f4:	01085313          	srli	t1,a6,0x10
204008f8:	00ced633          	srl	a2,t4,a2
204008fc:	00b66633          	or	a2,a2,a1
20400900:	01081593          	slli	a1,a6,0x10
20400904:	0105d593          	srli	a1,a1,0x10
20400908:	011e9533          	sll	a0,t4,a7
2040090c:	0267d6b3          	divu	a3,a5,t1
20400910:	0267f733          	remu	a4,a5,t1
20400914:	01065793          	srli	a5,a2,0x10
20400918:	02d586b3          	mul	a3,a1,a3
2040091c:	01071713          	slli	a4,a4,0x10
20400920:	00f76733          	or	a4,a4,a5
20400924:	00d77a63          	bgeu	a4,a3,20400938 <__umoddi3+0x184>
20400928:	01070733          	add	a4,a4,a6
2040092c:	01076663          	bltu	a4,a6,20400938 <__umoddi3+0x184>
20400930:	00d77463          	bgeu	a4,a3,20400938 <__umoddi3+0x184>
20400934:	01070733          	add	a4,a4,a6
20400938:	40d706b3          	sub	a3,a4,a3
2040093c:	0266f733          	remu	a4,a3,t1
20400940:	01061613          	slli	a2,a2,0x10
20400944:	01065613          	srli	a2,a2,0x10
20400948:	0266d6b3          	divu	a3,a3,t1
2040094c:	01071713          	slli	a4,a4,0x10
20400950:	02d586b3          	mul	a3,a1,a3
20400954:	00c765b3          	or	a1,a4,a2
20400958:	00d5fa63          	bgeu	a1,a3,2040096c <__umoddi3+0x1b8>
2040095c:	010585b3          	add	a1,a1,a6
20400960:	0105e663          	bltu	a1,a6,2040096c <__umoddi3+0x1b8>
20400964:	00d5f463          	bgeu	a1,a3,2040096c <__umoddi3+0x1b8>
20400968:	010585b3          	add	a1,a1,a6
2040096c:	40d585b3          	sub	a1,a1,a3
20400970:	01085693          	srli	a3,a6,0x10
20400974:	02d5f733          	remu	a4,a1,a3
20400978:	01081793          	slli	a5,a6,0x10
2040097c:	0107d793          	srli	a5,a5,0x10
20400980:	01055613          	srli	a2,a0,0x10
20400984:	02d5d5b3          	divu	a1,a1,a3
20400988:	01071713          	slli	a4,a4,0x10
2040098c:	00c76733          	or	a4,a4,a2
20400990:	02b785b3          	mul	a1,a5,a1
20400994:	00b77a63          	bgeu	a4,a1,204009a8 <__umoddi3+0x1f4>
20400998:	01070733          	add	a4,a4,a6
2040099c:	01076663          	bltu	a4,a6,204009a8 <__umoddi3+0x1f4>
204009a0:	00b77463          	bgeu	a4,a1,204009a8 <__umoddi3+0x1f4>
204009a4:	01070733          	add	a4,a4,a6
204009a8:	40b705b3          	sub	a1,a4,a1
204009ac:	02d5f733          	remu	a4,a1,a3
204009b0:	01051513          	slli	a0,a0,0x10
204009b4:	01055513          	srli	a0,a0,0x10
204009b8:	02d5d5b3          	divu	a1,a1,a3
204009bc:	02b785b3          	mul	a1,a5,a1
204009c0:	01071793          	slli	a5,a4,0x10
204009c4:	00a7e533          	or	a0,a5,a0
204009c8:	00b57a63          	bgeu	a0,a1,204009dc <__umoddi3+0x228>
204009cc:	01050533          	add	a0,a0,a6
204009d0:	01056663          	bltu	a0,a6,204009dc <__umoddi3+0x228>
204009d4:	00b57463          	bgeu	a0,a1,204009dc <__umoddi3+0x228>
204009d8:	01050533          	add	a0,a0,a6
204009dc:	40b50533          	sub	a0,a0,a1
204009e0:	ea9ff06f          	j	20400888 <__umoddi3+0xd4>
204009e4:	010006b7          	lui	a3,0x1000
204009e8:	01000793          	li	a5,16
204009ec:	ecd86ee3          	bltu	a6,a3,204008c8 <__umoddi3+0x114>
204009f0:	01800793          	li	a5,24
204009f4:	ed5ff06f          	j	204008c8 <__umoddi3+0x114>
204009f8:	e8d5ece3          	bltu	a1,a3,20400890 <__umoddi3+0xdc>
204009fc:	000107b7          	lui	a5,0x10
20400a00:	04f6f863          	bgeu	a3,a5,20400a50 <__umoddi3+0x29c>
20400a04:	0ff00893          	li	a7,255
20400a08:	00d8b7b3          	sltu	a5,a7,a3
20400a0c:	00379793          	slli	a5,a5,0x3
20400a10:	20408737          	lui	a4,0x20408
20400a14:	00f6d833          	srl	a6,a3,a5
20400a18:	24870713          	addi	a4,a4,584 # 20408248 <__clz_tab>
20400a1c:	01070733          	add	a4,a4,a6
20400a20:	00074883          	lbu	a7,0(a4)
20400a24:	00f888b3          	add	a7,a7,a5
20400a28:	02000793          	li	a5,32
20400a2c:	41178833          	sub	a6,a5,a7
20400a30:	03179a63          	bne	a5,a7,20400a64 <__umoddi3+0x2b0>
20400a34:	0066e463          	bltu	a3,t1,20400a3c <__umoddi3+0x288>
20400a38:	e4ceece3          	bltu	t4,a2,20400890 <__umoddi3+0xdc>
20400a3c:	40ce8533          	sub	a0,t4,a2
20400a40:	40d305b3          	sub	a1,t1,a3
20400a44:	00aebeb3          	sltu	t4,t4,a0
20400a48:	41d585b3          	sub	a1,a1,t4
20400a4c:	e45ff06f          	j	20400890 <__umoddi3+0xdc>
20400a50:	01000737          	lui	a4,0x1000
20400a54:	01000793          	li	a5,16
20400a58:	fae6ece3          	bltu	a3,a4,20400a10 <__umoddi3+0x25c>
20400a5c:	01800793          	li	a5,24
20400a60:	fb1ff06f          	j	20400a10 <__umoddi3+0x25c>
20400a64:	011657b3          	srl	a5,a2,a7
20400a68:	010696b3          	sll	a3,a3,a6
20400a6c:	00d7ee33          	or	t3,a5,a3
20400a70:	01135f33          	srl	t5,t1,a7
20400a74:	011ed7b3          	srl	a5,t4,a7
20400a78:	010e9533          	sll	a0,t4,a6
20400a7c:	010e5e93          	srli	t4,t3,0x10
20400a80:	010315b3          	sll	a1,t1,a6
20400a84:	03df5333          	divu	t1,t5,t4
20400a88:	00b7e7b3          	or	a5,a5,a1
20400a8c:	010e1593          	slli	a1,t3,0x10
20400a90:	0105d593          	srli	a1,a1,0x10
20400a94:	0107d713          	srli	a4,a5,0x10
20400a98:	01061633          	sll	a2,a2,a6
20400a9c:	03df76b3          	remu	a3,t5,t4
20400aa0:	02658f33          	mul	t5,a1,t1
20400aa4:	01069693          	slli	a3,a3,0x10
20400aa8:	00e6e733          	or	a4,a3,a4
20400aac:	00030693          	mv	a3,t1
20400ab0:	01e77e63          	bgeu	a4,t5,20400acc <__umoddi3+0x318>
20400ab4:	01c70733          	add	a4,a4,t3
20400ab8:	fff30693          	addi	a3,t1,-1
20400abc:	01c76863          	bltu	a4,t3,20400acc <__umoddi3+0x318>
20400ac0:	01e77663          	bgeu	a4,t5,20400acc <__umoddi3+0x318>
20400ac4:	ffe30693          	addi	a3,t1,-2
20400ac8:	01c70733          	add	a4,a4,t3
20400acc:	41e70733          	sub	a4,a4,t5
20400ad0:	03d77333          	remu	t1,a4,t4
20400ad4:	01079793          	slli	a5,a5,0x10
20400ad8:	0107d793          	srli	a5,a5,0x10
20400adc:	03d75733          	divu	a4,a4,t4
20400ae0:	01031313          	slli	t1,t1,0x10
20400ae4:	00f36333          	or	t1,t1,a5
20400ae8:	02e585b3          	mul	a1,a1,a4
20400aec:	00070793          	mv	a5,a4
20400af0:	00b37e63          	bgeu	t1,a1,20400b0c <__umoddi3+0x358>
20400af4:	01c30333          	add	t1,t1,t3
20400af8:	fff70793          	addi	a5,a4,-1 # ffffff <__rom_region_size+0xff6d43>
20400afc:	01c36863          	bltu	t1,t3,20400b0c <__umoddi3+0x358>
20400b00:	00b37663          	bgeu	t1,a1,20400b0c <__umoddi3+0x358>
20400b04:	ffe70793          	addi	a5,a4,-2
20400b08:	01c30333          	add	t1,t1,t3
20400b0c:	01069693          	slli	a3,a3,0x10
20400b10:	00010f37          	lui	t5,0x10
20400b14:	00f6e6b3          	or	a3,a3,a5
20400b18:	40b305b3          	sub	a1,t1,a1
20400b1c:	ffff0313          	addi	t1,t5,-1 # ffff <__rom_region_size+0x6d43>
20400b20:	0066feb3          	and	t4,a3,t1
20400b24:	01065713          	srli	a4,a2,0x10
20400b28:	0106d693          	srli	a3,a3,0x10
20400b2c:	00667333          	and	t1,a2,t1
20400b30:	026e87b3          	mul	a5,t4,t1
20400b34:	02668333          	mul	t1,a3,t1
20400b38:	02ee8eb3          	mul	t4,t4,a4
20400b3c:	02e686b3          	mul	a3,a3,a4
20400b40:	006e8eb3          	add	t4,t4,t1
20400b44:	0107d713          	srli	a4,a5,0x10
20400b48:	01d70733          	add	a4,a4,t4
20400b4c:	00677463          	bgeu	a4,t1,20400b54 <__umoddi3+0x3a0>
20400b50:	01e686b3          	add	a3,a3,t5
20400b54:	01075313          	srli	t1,a4,0x10
20400b58:	00d306b3          	add	a3,t1,a3
20400b5c:	00010337          	lui	t1,0x10
20400b60:	fff30313          	addi	t1,t1,-1 # ffff <__rom_region_size+0x6d43>
20400b64:	00677733          	and	a4,a4,t1
20400b68:	01071713          	slli	a4,a4,0x10
20400b6c:	0067f7b3          	and	a5,a5,t1
20400b70:	00f707b3          	add	a5,a4,a5
20400b74:	00d5e663          	bltu	a1,a3,20400b80 <__umoddi3+0x3cc>
20400b78:	00d59e63          	bne	a1,a3,20400b94 <__umoddi3+0x3e0>
20400b7c:	00f57c63          	bgeu	a0,a5,20400b94 <__umoddi3+0x3e0>
20400b80:	40c78633          	sub	a2,a5,a2
20400b84:	00c7b7b3          	sltu	a5,a5,a2
20400b88:	01c787b3          	add	a5,a5,t3
20400b8c:	40f686b3          	sub	a3,a3,a5
20400b90:	00060793          	mv	a5,a2
20400b94:	40f507b3          	sub	a5,a0,a5
20400b98:	00f53533          	sltu	a0,a0,a5
20400b9c:	40d585b3          	sub	a1,a1,a3
20400ba0:	40a585b3          	sub	a1,a1,a0
20400ba4:	011598b3          	sll	a7,a1,a7
20400ba8:	0107d533          	srl	a0,a5,a6
20400bac:	00a8e533          	or	a0,a7,a0
20400bb0:	0105d5b3          	srl	a1,a1,a6
20400bb4:	cddff06f          	j	20400890 <__umoddi3+0xdc>

20400bb8 <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
20400bb8:	00008067          	ret

20400bbc <uart_out>:
{
	blink(&led1, 1000, 1);
}

void uart_out(void)
{
20400bbc:	ff010113          	addi	sp,sp,-16
20400bc0:	00912223          	sw	s1,4(sp)
20400bc4:	01212023          	sw	s2,0(sp)
20400bc8:	00112623          	sw	ra,12(sp)
20400bcc:	00812423          	sw	s0,8(sp)
	while (1) {
		struct printk_data_t *rx_data = k_fifo_get(&printk_fifo,
							   K_FOREVER);
		printk("Toggled led%d; counter=%d\n",
20400bd0:	204084b7          	lui	s1,0x20408
		/* coverity[OVERRUN] */
		return (void *) arch_syscall_invoke3(*(uintptr_t *)&queue, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_QUEUE_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_queue_get(queue, timeout);
20400bd4:	fff00593          	li	a1,-1
20400bd8:	fff00613          	li	a2,-1
20400bdc:	8e418513          	addi	a0,gp,-1820 # 80001f7c <printk_fifo>
20400be0:	200040ef          	jal	ra,20404de0 <z_impl_k_queue_get>
20400be4:	00852603          	lw	a2,8(a0)
20400be8:	00452583          	lw	a1,4(a0)
20400bec:	00050413          	mv	s0,a0
20400bf0:	34848513          	addi	a0,s1,840 # 20408348 <__clz_tab+0x100>
20400bf4:	434000ef          	jal	ra,20401028 <printk>
		       rx_data->led, rx_data->cnt);
		k_free(rx_data);
20400bf8:	00040513          	mv	a0,s0
20400bfc:	5ad060ef          	jal	ra,204079a8 <k_free>
	while (1) {
20400c00:	fd5ff06f          	j	20400bd4 <uart_out+0x18>

20400c04 <blink>:
{
20400c04:	fa010113          	addi	sp,sp,-96
20400c08:	04812c23          	sw	s0,88(sp)
20400c0c:	04912a23          	sw	s1,84(sp)
20400c10:	05512223          	sw	s5,68(sp)
20400c14:	00050493          	mv	s1,a0
20400c18:	04112e23          	sw	ra,92(sp)
	if (!device_is_ready(spec->port)) {
20400c1c:	00052503          	lw	a0,0(a0)
{
20400c20:	05212823          	sw	s2,80(sp)
20400c24:	05312623          	sw	s3,76(sp)
20400c28:	05412423          	sw	s4,72(sp)
20400c2c:	05612023          	sw	s6,64(sp)
20400c30:	03712e23          	sw	s7,60(sp)
20400c34:	03812c23          	sw	s8,56(sp)
20400c38:	03912a23          	sw	s9,52(sp)
20400c3c:	03a12823          	sw	s10,48(sp)
20400c40:	03b12623          	sw	s11,44(sp)
20400c44:	00058413          	mv	s0,a1
20400c48:	00060a93          	mv	s5,a2
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
20400c4c:	0d5030ef          	jal	ra,20404520 <z_device_ready>
20400c50:	0004a983          	lw	s3,0(s1)
20400c54:	28050a63          	beqz	a0,20400ee8 <blink+0x2e4>
 * @return a value from gpio_pin_configure()
 */
static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
					gpio_flags_t extra_flags)
{
	return gpio_pin_configure(spec->port,
20400c58:	0044cb03          	lbu	s6,4(s1)
				  spec->pin,
				  spec->dt_flags | extra_flags);
20400c5c:	0054ca03          	lbu	s4,5(s1)
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
20400c60:	03000793          	li	a5,48
20400c64:	030a7713          	andi	a4,s4,48
	const struct gpio_driver_api *api =
20400c68:	0089ac03          	lw	s8,8(s3)
	const struct gpio_driver_config *const cfg =
20400c6c:	0049ac83          	lw	s9,4(s3)
	struct gpio_driver_data *data =
20400c70:	0109ab83          	lw	s7,16(s3)
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
20400c74:	02f71e63          	bne	a4,a5,20400cb0 <blink+0xac>
20400c78:	20408937          	lui	s2,0x20408
20400c7c:	204085b7          	lui	a1,0x20408
20400c80:	20408537          	lui	a0,0x20408
20400c84:	3b058593          	addi	a1,a1,944 # 204083b0 <__clz_tab+0x168>
20400c88:	2e100693          	li	a3,737
20400c8c:	38490613          	addi	a2,s2,900 # 20408384 <__clz_tab+0x13c>
20400c90:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20400c94:	394000ef          	jal	ra,20401028 <printk>
20400c98:	20408537          	lui	a0,0x20408
20400c9c:	40c50513          	addi	a0,a0,1036 # 2040840c <__clz_tab+0x1c4>
20400ca0:	388000ef          	jal	ra,20401028 <printk>
20400ca4:	2e100593          	li	a1,737
20400ca8:	38490513          	addi	a0,s2,900
20400cac:	2c1010ef          	jal	ra,2040276c <assert_post_action>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
20400cb0:	006a7793          	andi	a5,s4,6
20400cb4:	00400713          	li	a4,4
20400cb8:	02e79863          	bne	a5,a4,20400ce8 <blink+0xe4>
20400cbc:	20408937          	lui	s2,0x20408
20400cc0:	204085b7          	lui	a1,0x20408
20400cc4:	20408537          	lui	a0,0x20408
20400cc8:	44c58593          	addi	a1,a1,1100 # 2040844c <__clz_tab+0x204>
20400ccc:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20400cd0:	2e900693          	li	a3,745
20400cd4:	38490613          	addi	a2,s2,900 # 20408384 <__clz_tab+0x13c>
20400cd8:	350000ef          	jal	ra,20401028 <printk>
20400cdc:	2e900593          	li	a1,745
20400ce0:	38490513          	addi	a0,s2,900
20400ce4:	289010ef          	jal	ra,2040276c <assert_post_action>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
20400ce8:	000ca783          	lw	a5,0(s9)
20400cec:	00100913          	li	s2,1
20400cf0:	01691933          	sll	s2,s2,s6
20400cf4:	00f977b3          	and	a5,s2,a5
20400cf8:	02079e63          	bnez	a5,20400d34 <blink+0x130>
20400cfc:	20408cb7          	lui	s9,0x20408
20400d00:	204085b7          	lui	a1,0x20408
20400d04:	20408537          	lui	a0,0x20408
20400d08:	48058593          	addi	a1,a1,1152 # 20408480 <__clz_tab+0x238>
20400d0c:	2fd00693          	li	a3,765
20400d10:	384c8613          	addi	a2,s9,900 # 20408384 <__clz_tab+0x13c>
20400d14:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20400d18:	310000ef          	jal	ra,20401028 <printk>
20400d1c:	20408537          	lui	a0,0x20408
20400d20:	4c050513          	addi	a0,a0,1216 # 204084c0 <__clz_tab+0x278>
20400d24:	304000ef          	jal	ra,20401028 <printk>
20400d28:	2fd00593          	li	a1,765
20400d2c:	384c8513          	addi	a0,s9,900
20400d30:	23d010ef          	jal	ra,2040276c <assert_post_action>
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
20400d34:	001a7713          	andi	a4,s4,1
		data->invert |= (gpio_port_pins_t)BIT(pin);
20400d38:	000ba783          	lw	a5,0(s7)
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
20400d3c:	1e070a63          	beqz	a4,20400f30 <blink+0x32c>
		data->invert |= (gpio_port_pins_t)BIT(pin);
20400d40:	0127e933          	or	s2,a5,s2
	return api->pin_configure(port, pin, flags);
20400d44:	000c2783          	lw	a5,0(s8)
20400d48:	012ba023          	sw	s2,0(s7)
20400d4c:	200a6613          	ori	a2,s4,512
20400d50:	000b0593          	mv	a1,s6
20400d54:	00098513          	mv	a0,s3
20400d58:	000780e7          	jalr	a5 # 10000 <__rom_region_size+0x6d44>
20400d5c:	00050913          	mv	s2,a0
	if (ret != 0) {
20400d60:	1c051e63          	bnez	a0,20400f3c <blink+0x338>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
20400d64:	00040793          	mv	a5,s0
20400d68:	00045463          	bgez	s0,20400d70 <blink+0x16c>
20400d6c:	00000793          	li	a5,0
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
20400d70:	0197d713          	srli	a4,a5,0x19
20400d74:	41f7d593          	srai	a1,a5,0x1f
20400d78:	00779793          	slli	a5,a5,0x7
20400d7c:	3e778513          	addi	a0,a5,999
20400d80:	00759593          	slli	a1,a1,0x7
20400d84:	00b765b3          	or	a1,a4,a1
20400d88:	00f537b3          	sltu	a5,a0,a5
20400d8c:	3e800613          	li	a2,1000
20400d90:	00000693          	li	a3,0
20400d94:	00b785b3          	add	a1,a5,a1
20400d98:	de8ff0ef          	jal	ra,20400380 <__udivdi3>
20400d9c:	00a12223          	sw	a0,4(sp)
20400da0:	00b12423          	sw	a1,8(sp)
		(const struct gpio_driver_config *)port->config;
	const struct gpio_driver_data *const data =
			(const struct gpio_driver_data *)port->data;

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
20400da4:	20408437          	lui	s0,0x20408
20400da8:	20408bb7          	lui	s7,0x20408
20400dac:	20408b37          	lui	s6,0x20408
20400db0:	20408c37          	lui	s8,0x20408
		__ASSERT_NO_MSG(mem_ptr != 0);
20400db4:	20408cb7          	lui	s9,0x20408
20400db8:	20408db7          	lui	s11,0x20408
		gpio_pin_set(spec->port, spec->pin, cnt % 2);
20400dbc:	0004a983          	lw	s3,0(s1)
20400dc0:	0044c703          	lbu	a4,4(s1)
20400dc4:	00100693          	li	a3,1
	const struct gpio_driver_data *const data =
20400dc8:	0109a803          	lw	a6,16(s3)
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
20400dcc:	00e69a33          	sll	s4,a3,a4
20400dd0:	0049a683          	lw	a3,4(s3)
20400dd4:	0006a683          	lw	a3,0(a3) # 1000000 <__rom_region_size+0xff6d44>
20400dd8:	00da76b3          	and	a3,s4,a3
20400ddc:	02069a63          	bnez	a3,20400e10 <blink+0x20c>
20400de0:	4bb00693          	li	a3,1211
20400de4:	38440613          	addi	a2,s0,900 # 20408384 <__clz_tab+0x13c>
20400de8:	480b8593          	addi	a1,s7,1152 # 20408480 <__clz_tab+0x238>
20400dec:	3ecb0513          	addi	a0,s6,1004 # 204083ec <__clz_tab+0x1a4>
20400df0:	01012623          	sw	a6,12(sp)
20400df4:	234000ef          	jal	ra,20401028 <printk>
20400df8:	4c0c0513          	addi	a0,s8,1216 # 204084c0 <__clz_tab+0x278>
20400dfc:	22c000ef          	jal	ra,20401028 <printk>
20400e00:	4bb00593          	li	a1,1211
20400e04:	38440513          	addi	a0,s0,900
20400e08:	165010ef          	jal	ra,2040276c <assert_post_action>
20400e0c:	00c12803          	lw	a6,12(sp)
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
20400e10:	00082683          	lw	a3,0(a6)
20400e14:	00da76b3          	and	a3,s4,a3
20400e18:	16069a63          	bnez	a3,20400f8c <blink+0x388>
20400e1c:	00200813          	li	a6,2
20400e20:	03096833          	rem	a6,s2,a6
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
20400e24:	0049a683          	lw	a3,4(s3)
20400e28:	0006a683          	lw	a3,0(a3)
20400e2c:	00da76b3          	and	a3,s4,a3
20400e30:	02069a63          	bnez	a3,20400e64 <blink+0x260>
20400e34:	49100693          	li	a3,1169
20400e38:	38440613          	addi	a2,s0,900
20400e3c:	480b8593          	addi	a1,s7,1152
20400e40:	3ecb0513          	addi	a0,s6,1004
20400e44:	01012623          	sw	a6,12(sp)
20400e48:	1e0000ef          	jal	ra,20401028 <printk>
20400e4c:	4c0c0513          	addi	a0,s8,1216
20400e50:	1d8000ef          	jal	ra,20401028 <printk>
20400e54:	49100593          	li	a1,1169
20400e58:	38440513          	addi	a0,s0,900
20400e5c:	111010ef          	jal	ra,2040276c <assert_post_action>
20400e60:	00c12803          	lw	a6,12(sp)
	if (value != 0)	{
20400e64:	12080a63          	beqz	a6,20400f98 <blink+0x394>
	return api->port_set_bits_raw(port, pins);
20400e68:	0089a683          	lw	a3,8(s3)
20400e6c:	00c6a683          	lw	a3,12(a3)
	return api->port_clear_bits_raw(port, pins);
20400e70:	000a0593          	mv	a1,s4
20400e74:	00098513          	mv	a0,s3
20400e78:	000680e7          	jalr	a3
		char *mem_ptr = k_malloc(size);
20400e7c:	00c00513          	li	a0,12
		struct printk_data_t tx_data = { .led = id, .cnt = cnt };
20400e80:	00012a23          	sw	zero,20(sp)
20400e84:	01512c23          	sw	s5,24(sp)
20400e88:	01212e23          	sw	s2,28(sp)
		char *mem_ptr = k_malloc(size);
20400e8c:	3fd060ef          	jal	ra,20407a88 <k_malloc>
20400e90:	00050993          	mv	s3,a0
		__ASSERT_NO_MSG(mem_ptr != 0);
20400e94:	02051263          	bnez	a0,20400eb8 <blink+0x2b4>
20400e98:	53cd8593          	addi	a1,s11,1340 # 2040853c <__clz_tab+0x2f4>
20400e9c:	3ecb0513          	addi	a0,s6,1004
20400ea0:	04f00693          	li	a3,79
20400ea4:	508c8613          	addi	a2,s9,1288 # 20408508 <__clz_tab+0x2c0>
20400ea8:	180000ef          	jal	ra,20401028 <printk>
20400eac:	04f00593          	li	a1,79
20400eb0:	508c8513          	addi	a0,s9,1288
20400eb4:	0b9010ef          	jal	ra,2040276c <assert_post_action>
		memcpy(mem_ptr, &tx_data, size);
20400eb8:	00c00613          	li	a2,12
20400ebc:	01410593          	addi	a1,sp,20
20400ec0:	00098513          	mv	a0,s3
20400ec4:	339010ef          	jal	ra,204029fc <memcpy>
		k_fifo_put(&printk_fifo, mem_ptr);
20400ec8:	00098593          	mv	a1,s3
20400ecc:	8e418513          	addi	a0,gp,-1820 # 80001f7c <printk_fifo>
20400ed0:	6fd030ef          	jal	ra,20404dcc <k_queue_append>
	return z_impl_k_sleep(timeout);
20400ed4:	00412503          	lw	a0,4(sp)
20400ed8:	00812583          	lw	a1,8(sp)
		cnt++;
20400edc:	00190913          	addi	s2,s2,1
20400ee0:	489050ef          	jal	ra,20406b68 <z_impl_k_sleep>
	while (1) {
20400ee4:	ed9ff06f          	j	20400dbc <blink+0x1b8>
}
20400ee8:	05812403          	lw	s0,88(sp)
		printk("Error: %s device is not ready\n", spec->port->name);
20400eec:	0009a583          	lw	a1,0(s3)
}
20400ef0:	05c12083          	lw	ra,92(sp)
20400ef4:	05412483          	lw	s1,84(sp)
20400ef8:	05012903          	lw	s2,80(sp)
20400efc:	04c12983          	lw	s3,76(sp)
20400f00:	04812a03          	lw	s4,72(sp)
20400f04:	04412a83          	lw	s5,68(sp)
20400f08:	04012b03          	lw	s6,64(sp)
20400f0c:	03c12b83          	lw	s7,60(sp)
20400f10:	03812c03          	lw	s8,56(sp)
20400f14:	03412c83          	lw	s9,52(sp)
20400f18:	03012d03          	lw	s10,48(sp)
20400f1c:	02c12d83          	lw	s11,44(sp)
		printk("Error: %s device is not ready\n", spec->port->name);
20400f20:	20408537          	lui	a0,0x20408
20400f24:	36450513          	addi	a0,a0,868 # 20408364 <__clz_tab+0x11c>
}
20400f28:	06010113          	addi	sp,sp,96
		printk("Error: %s device is not ready\n", spec->port->name);
20400f2c:	0fc0006f          	j	20401028 <printk>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
20400f30:	fff94913          	not	s2,s2
20400f34:	00f97933          	and	s2,s2,a5
20400f38:	e0dff06f          	j	20400d44 <blink+0x140>
}
20400f3c:	05812403          	lw	s0,88(sp)
		printk("Error %d: failed to configure pin %d (LED '%s')\n",
20400f40:	0084a683          	lw	a3,8(s1)
20400f44:	0044c603          	lbu	a2,4(s1)
}
20400f48:	05c12083          	lw	ra,92(sp)
20400f4c:	05412483          	lw	s1,84(sp)
20400f50:	05012903          	lw	s2,80(sp)
20400f54:	04c12983          	lw	s3,76(sp)
20400f58:	04812a03          	lw	s4,72(sp)
20400f5c:	04412a83          	lw	s5,68(sp)
20400f60:	04012b03          	lw	s6,64(sp)
20400f64:	03c12b83          	lw	s7,60(sp)
20400f68:	03812c03          	lw	s8,56(sp)
20400f6c:	03412c83          	lw	s9,52(sp)
20400f70:	03012d03          	lw	s10,48(sp)
20400f74:	02c12d83          	lw	s11,44(sp)
		printk("Error %d: failed to configure pin %d (LED '%s')\n",
20400f78:	00050593          	mv	a1,a0
20400f7c:	20408537          	lui	a0,0x20408
20400f80:	4d450513          	addi	a0,a0,1236 # 204084d4 <__clz_tab+0x28c>
}
20400f84:	06010113          	addi	sp,sp,96
		printk("Error %d: failed to configure pin %d (LED '%s')\n",
20400f88:	0a00006f          	j	20401028 <printk>
		value = (value != 0) ? 0 : 1;
20400f8c:	fff94813          	not	a6,s2
20400f90:	00187813          	andi	a6,a6,1
20400f94:	e91ff06f          	j	20400e24 <blink+0x220>
	return api->port_clear_bits_raw(port, pins);
20400f98:	0089a683          	lw	a3,8(s3)
20400f9c:	0106a683          	lw	a3,16(a3)
20400fa0:	ed1ff06f          	j	20400e70 <blink+0x26c>

20400fa4 <blink0>:
	blink(&led0, 100, 0);
20400fa4:	20408537          	lui	a0,0x20408
20400fa8:	00000613          	li	a2,0
20400fac:	06400593          	li	a1,100
20400fb0:	58850513          	addi	a0,a0,1416 # 20408588 <led0>
20400fb4:	c51ff06f          	j	20400c04 <blink>

20400fb8 <blink1>:
	blink(&led1, 1000, 1);
20400fb8:	20408537          	lui	a0,0x20408
20400fbc:	00100613          	li	a2,1
20400fc0:	3e800593          	li	a1,1000
20400fc4:	59450513          	addi	a0,a0,1428 # 20408594 <led1>
20400fc8:	c3dff06f          	j	20400c04 <blink>

20400fcc <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
20400fcc:	00000513          	li	a0,0
20400fd0:	00008067          	ret

20400fd4 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
20400fd4:	0005a783          	lw	a5,0(a1)
20400fd8:	00178793          	addi	a5,a5,1
20400fdc:	00f5a023          	sw	a5,0(a1)
	return _char_out(c);
20400fe0:	800027b7          	lui	a5,0x80002
20400fe4:	e987a783          	lw	a5,-360(a5) # 80001e98 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001e99>
20400fe8:	00078067          	jr	a5

20400fec <__printk_hook_install>:
	_char_out = fn;
20400fec:	800027b7          	lui	a5,0x80002
20400ff0:	e8a7ac23          	sw	a0,-360(a5) # 80001e98 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001e99>
}
20400ff4:	00008067          	ret

20400ff8 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
20400ff8:	fe010113          	addi	sp,sp,-32
20400ffc:	00050613          	mv	a2,a0
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
20401000:	20401537          	lui	a0,0x20401
{
20401004:	00058693          	mv	a3,a1
	cbvprintf(char_out, &ctx, fmt, ap);
20401008:	fd450513          	addi	a0,a0,-44 # 20400fd4 <char_out>
2040100c:	00c10593          	addi	a1,sp,12
{
20401010:	00112e23          	sw	ra,28(sp)
	struct out_context ctx = { 0 };
20401014:	00012623          	sw	zero,12(sp)
	cbvprintf(char_out, &ctx, fmt, ap);
20401018:	449000ef          	jal	ra,20401c60 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
2040101c:	01c12083          	lw	ra,28(sp)
20401020:	02010113          	addi	sp,sp,32
20401024:	00008067          	ret

20401028 <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
20401028:	fc010113          	addi	sp,sp,-64
2040102c:	02b12223          	sw	a1,36(sp)
	va_list ap;

	va_start(ap, fmt);
20401030:	02410593          	addi	a1,sp,36
{
20401034:	00112e23          	sw	ra,28(sp)
20401038:	02c12423          	sw	a2,40(sp)
2040103c:	02d12623          	sw	a3,44(sp)
20401040:	02e12823          	sw	a4,48(sp)
20401044:	02f12a23          	sw	a5,52(sp)
20401048:	03012c23          	sw	a6,56(sp)
2040104c:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
20401050:	00b12623          	sw	a1,12(sp)

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
20401054:	fa5ff0ef          	jal	ra,20400ff8 <vprintk>
	}
	va_end(ap);
}
20401058:	01c12083          	lw	ra,28(sp)
2040105c:	04010113          	addi	sp,sp,64
20401060:	00008067          	ret

20401064 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
20401064:	ff010113          	addi	sp,sp,-16
20401068:	00050793          	mv	a5,a0
2040106c:	00058513          	mv	a0,a1
20401070:	00060593          	mv	a1,a2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
20401074:	00068613          	mv	a2,a3
{
20401078:	00112623          	sw	ra,12(sp)
	entry(p1, p2, p3);
2040107c:	000780e7          	jalr	a5
	return z_impl_z_current_get();
20401080:	3c5050ef          	jal	ra,20406c44 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
20401084:	5ed050ef          	jal	ra,20406e70 <z_impl_k_thread_abort>

20401088 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
20401088:	00359593          	slli	a1,a1,0x3
2040108c:	00b50533          	add	a0,a0,a1
20401090:	00255503          	lhu	a0,2(a0)
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
20401094:	00155513          	srli	a0,a0,0x1
20401098:	00008067          	ret

2040109c <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
2040109c:	ff010113          	addi	sp,sp,-16
204010a0:	00112623          	sw	ra,12(sp)
204010a4:	00812423          	sw	s0,8(sp)
204010a8:	00912223          	sw	s1,4(sp)
204010ac:	00050413          	mv	s0,a0
204010b0:	00058493          	mv	s1,a1
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
204010b4:	fd5ff0ef          	jal	ra,20401088 <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
204010b8:	a2cff0ef          	jal	ra,204002e4 <__clzsi2>
204010bc:	01f00793          	li	a5,31
204010c0:	40a78533          	sub	a0,a5,a0
	if (b->next == 0U) {
204010c4:	00251713          	slli	a4,a0,0x2
204010c8:	00e40733          	add	a4,s0,a4
204010cc:	01072803          	lw	a6,16(a4)
	void *cmem = &buf[c];
204010d0:	00349793          	slli	a5,s1,0x3
		((uint16_t *)cmem)[f] = val;
204010d4:	00478593          	addi	a1,a5,4
204010d8:	01049693          	slli	a3,s1,0x10
204010dc:	00678793          	addi	a5,a5,6
204010e0:	00b405b3          	add	a1,s0,a1
204010e4:	00f407b3          	add	a5,s0,a5
204010e8:	0106d693          	srli	a3,a3,0x10
204010ec:	02081c63          	bnez	a6,20401124 <free_list_add+0x88>
		h->avail_buckets |= BIT(bidx);
204010f0:	00100613          	li	a2,1
204010f4:	00a61633          	sll	a2,a2,a0
204010f8:	00c42503          	lw	a0,12(s0)
204010fc:	00c56533          	or	a0,a0,a2
20401100:	00a42623          	sw	a0,12(s0)
		b->next = c;
20401104:	00972823          	sw	s1,16(a4)
20401108:	00d59023          	sh	a3,0(a1)
2040110c:	00d79023          	sh	a3,0(a5)
		free_list_add_bidx(h, c, bidx);
	}
}
20401110:	00c12083          	lw	ra,12(sp)
20401114:	00812403          	lw	s0,8(sp)
20401118:	00412483          	lw	s1,4(sp)
2040111c:	01010113          	addi	sp,sp,16
20401120:	00008067          	ret
	void *cmem = &buf[c];
20401124:	00381713          	slli	a4,a6,0x3
		return ((uint16_t *)cmem)[f];
20401128:	00470713          	addi	a4,a4,4
2040112c:	00e40733          	add	a4,s0,a4
20401130:	00075603          	lhu	a2,0(a4)
		((uint16_t *)cmem)[f] = val;
20401134:	00c59023          	sh	a2,0(a1)
20401138:	00361613          	slli	a2,a2,0x3
2040113c:	01079023          	sh	a6,0(a5)
20401140:	00c40433          	add	s0,s0,a2
20401144:	00d41323          	sh	a3,6(s0)
20401148:	00d71023          	sh	a3,0(a4)
2040114c:	fc5ff06f          	j	20401110 <free_list_add+0x74>

20401150 <free_list_remove_bidx>:
	void *cmem = &buf[c];
20401150:	00359693          	slli	a3,a1,0x3
		return ((uint16_t *)cmem)[f];
20401154:	00d506b3          	add	a3,a0,a3
20401158:	0066d703          	lhu	a4,6(a3)
2040115c:	00460793          	addi	a5,a2,4
	if (next_free_chunk(h, c) == c) {
20401160:	02e59663          	bne	a1,a4,2040118c <free_list_remove_bidx+0x3c>
		h->avail_buckets &= ~BIT(bidx);
20401164:	00100713          	li	a4,1
20401168:	00c71633          	sll	a2,a4,a2
2040116c:	00c52703          	lw	a4,12(a0)
20401170:	fff64613          	not	a2,a2
		b->next = 0;
20401174:	00279793          	slli	a5,a5,0x2
		h->avail_buckets &= ~BIT(bidx);
20401178:	00c77633          	and	a2,a4,a2
2040117c:	00c52623          	sw	a2,12(a0)
		b->next = 0;
20401180:	00f50533          	add	a0,a0,a5
20401184:	00052023          	sw	zero,0(a0)
}
20401188:	00008067          	ret
2040118c:	0046d683          	lhu	a3,4(a3)
		b->next = second;
20401190:	00279793          	slli	a5,a5,0x2
20401194:	00f507b3          	add	a5,a0,a5
20401198:	00e7a023          	sw	a4,0(a5)
		((uint16_t *)cmem)[f] = val;
2040119c:	00369793          	slli	a5,a3,0x3
204011a0:	00f507b3          	add	a5,a0,a5
204011a4:	00e79323          	sh	a4,6(a5)
204011a8:	00371713          	slli	a4,a4,0x3
204011ac:	00e50533          	add	a0,a0,a4
204011b0:	00d51223          	sh	a3,4(a0)
}
204011b4:	00008067          	ret

204011b8 <free_list_remove>:
{
204011b8:	ff010113          	addi	sp,sp,-16
204011bc:	00112623          	sw	ra,12(sp)
204011c0:	00812423          	sw	s0,8(sp)
204011c4:	00912223          	sw	s1,4(sp)
204011c8:	00050413          	mv	s0,a0
204011cc:	00058493          	mv	s1,a1
		int bidx = bucket_idx(h, chunk_size(h, c));
204011d0:	eb9ff0ef          	jal	ra,20401088 <chunk_size>
	return 31 - __builtin_clz(usable_sz);
204011d4:	910ff0ef          	jal	ra,204002e4 <__clzsi2>
		free_list_remove_bidx(h, c, bidx);
204011d8:	01f00613          	li	a2,31
204011dc:	40a60633          	sub	a2,a2,a0
204011e0:	00040513          	mv	a0,s0
}
204011e4:	00812403          	lw	s0,8(sp)
204011e8:	00c12083          	lw	ra,12(sp)
		free_list_remove_bidx(h, c, bidx);
204011ec:	00048593          	mv	a1,s1
}
204011f0:	00412483          	lw	s1,4(sp)
204011f4:	01010113          	addi	sp,sp,16
		free_list_remove_bidx(h, c, bidx);
204011f8:	f59ff06f          	j	20401150 <free_list_remove_bidx>

204011fc <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
204011fc:	fd010113          	addi	sp,sp,-48
20401200:	02912223          	sw	s1,36(sp)
20401204:	00050493          	mv	s1,a0
20401208:	00058513          	mv	a0,a1
2040120c:	03212023          	sw	s2,32(sp)
20401210:	01312e23          	sw	s3,28(sp)
20401214:	01412c23          	sw	s4,24(sp)
20401218:	01612823          	sw	s6,16(sp)
2040121c:	02112623          	sw	ra,44(sp)
20401220:	02812423          	sw	s0,40(sp)
20401224:	01512a23          	sw	s5,20(sp)
20401228:	00058a13          	mv	s4,a1
2040122c:	8b8ff0ef          	jal	ra,204002e4 <__clzsi2>
20401230:	01f00613          	li	a2,31
20401234:	40a60633          	sub	a2,a2,a0
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
20401238:	00261913          	slli	s2,a2,0x2
2040123c:	01248933          	add	s2,s1,s2
20401240:	01092b03          	lw	s6,16(s2)
20401244:	00050993          	mv	s3,a0
20401248:	060b0c63          	beqz	s6,204012c0 <alloc_chunk+0xc4>
2040124c:	00300a93          	li	s5,3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
20401250:	01092403          	lw	s0,16(s2)
			if (chunk_size(h, c) >= sz) {
20401254:	00048513          	mv	a0,s1
20401258:	00c12623          	sw	a2,12(sp)
2040125c:	00040593          	mv	a1,s0
20401260:	e29ff0ef          	jal	ra,20401088 <chunk_size>
20401264:	00c12603          	lw	a2,12(sp)
20401268:	03456e63          	bltu	a0,s4,204012a4 <alloc_chunk+0xa8>

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
2040126c:	00040593          	mv	a1,s0
20401270:	00048513          	mv	a0,s1
20401274:	eddff0ef          	jal	ra,20401150 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
20401278:	02c12083          	lw	ra,44(sp)
2040127c:	00040513          	mv	a0,s0
20401280:	02812403          	lw	s0,40(sp)
20401284:	02412483          	lw	s1,36(sp)
20401288:	02012903          	lw	s2,32(sp)
2040128c:	01c12983          	lw	s3,28(sp)
20401290:	01812a03          	lw	s4,24(sp)
20401294:	01412a83          	lw	s5,20(sp)
20401298:	01012b03          	lw	s6,16(sp)
2040129c:	03010113          	addi	sp,sp,48
204012a0:	00008067          	ret
		return ((uint16_t *)cmem)[f];
204012a4:	00341413          	slli	s0,s0,0x3
204012a8:	00848433          	add	s0,s1,s0
204012ac:	00645783          	lhu	a5,6(s0)
		} while (--i && b->next != first);
204012b0:	fffa8a93          	addi	s5,s5,-1
			b->next = next_free_chunk(h, c);
204012b4:	00f92823          	sw	a5,16(s2)
		} while (--i && b->next != first);
204012b8:	000a8463          	beqz	s5,204012c0 <alloc_chunk+0xc4>
204012bc:	f8fb1ae3          	bne	s6,a5,20401250 <alloc_chunk+0x54>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
204012c0:	02000413          	li	s0,32
204012c4:	00c4a583          	lw	a1,12(s1)
204012c8:	413409b3          	sub	s3,s0,s3
204012cc:	fff00413          	li	s0,-1
204012d0:	01341433          	sll	s0,s0,s3
204012d4:	00b47433          	and	s0,s0,a1
	if (bmask != 0U) {
204012d8:	fa0400e3          	beqz	s0,20401278 <alloc_chunk+0x7c>
		int minbucket = __builtin_ctz(bmask);
204012dc:	00040513          	mv	a0,s0
204012e0:	850ff0ef          	jal	ra,20400330 <__ctzsi2>
		chunkid_t c = h->buckets[minbucket].next;
204012e4:	00450793          	addi	a5,a0,4
204012e8:	00279793          	slli	a5,a5,0x2
204012ec:	00f487b3          	add	a5,s1,a5
204012f0:	0007a403          	lw	s0,0(a5)
		int minbucket = __builtin_ctz(bmask);
204012f4:	00050613          	mv	a2,a0
		chunkid_t c = h->buckets[minbucket].next;
204012f8:	f75ff06f          	j	2040126c <alloc_chunk+0x70>

204012fc <merge_chunks>:
{
204012fc:	fe010113          	addi	sp,sp,-32
20401300:	00112e23          	sw	ra,28(sp)
20401304:	00812c23          	sw	s0,24(sp)
20401308:	00912a23          	sw	s1,20(sp)
2040130c:	01212823          	sw	s2,16(sp)
20401310:	01312623          	sw	s3,12(sp)
20401314:	00050493          	mv	s1,a0
20401318:	00060413          	mv	s0,a2
2040131c:	00058913          	mv	s2,a1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
20401320:	d69ff0ef          	jal	ra,20401088 <chunk_size>
20401324:	00040593          	mv	a1,s0
20401328:	00050993          	mv	s3,a0
2040132c:	00048513          	mv	a0,s1
20401330:	d59ff0ef          	jal	ra,20401088 <chunk_size>
20401334:	00a989b3          	add	s3,s3,a0
		((uint16_t *)cmem)[f] = val;
20401338:	00391913          	slli	s2,s2,0x3
2040133c:	01248933          	add	s2,s1,s2
	chunk_set(h, c, SIZE_AND_USED, size << 1);
20401340:	00199793          	slli	a5,s3,0x1
		((uint16_t *)cmem)[f] = val;
20401344:	00f91123          	sh	a5,2(s2)
	return c + chunk_size(h, c);
20401348:	00040593          	mv	a1,s0
2040134c:	00048513          	mv	a0,s1
20401350:	d39ff0ef          	jal	ra,20401088 <chunk_size>
	void *cmem = &buf[c];
20401354:	00a40433          	add	s0,s0,a0
		((uint16_t *)cmem)[f] = val;
20401358:	00341413          	slli	s0,s0,0x3
2040135c:	00848433          	add	s0,s1,s0
20401360:	01341023          	sh	s3,0(s0)
}
20401364:	01c12083          	lw	ra,28(sp)
20401368:	01812403          	lw	s0,24(sp)
2040136c:	01412483          	lw	s1,20(sp)
20401370:	01012903          	lw	s2,16(sp)
20401374:	00c12983          	lw	s3,12(sp)
20401378:	02010113          	addi	sp,sp,32
2040137c:	00008067          	ret

20401380 <split_chunks>:
{
20401380:	fe010113          	addi	sp,sp,-32
20401384:	00112e23          	sw	ra,28(sp)
20401388:	00812c23          	sw	s0,24(sp)
2040138c:	00912a23          	sw	s1,20(sp)
20401390:	01212823          	sw	s2,16(sp)
20401394:	01312623          	sw	s3,12(sp)
20401398:	00060413          	mv	s0,a2
2040139c:	00050913          	mv	s2,a0
204013a0:	00058493          	mv	s1,a1
	chunksz_t sz0 = chunk_size(h, lc);
204013a4:	ce5ff0ef          	jal	ra,20401088 <chunk_size>
	chunksz_t lsz = rc - lc;
204013a8:	40940733          	sub	a4,s0,s1
	chunksz_t rsz = sz0 - lsz;
204013ac:	408489b3          	sub	s3,s1,s0
204013b0:	00349493          	slli	s1,s1,0x3
204013b4:	009904b3          	add	s1,s2,s1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
204013b8:	00171793          	slli	a5,a4,0x1
		((uint16_t *)cmem)[f] = val;
204013bc:	00f49123          	sh	a5,2(s1)
204013c0:	00a989b3          	add	s3,s3,a0
	void *cmem = &buf[c];
204013c4:	00341793          	slli	a5,s0,0x3
		((uint16_t *)cmem)[f] = val;
204013c8:	00f907b3          	add	a5,s2,a5
	chunk_set(h, c, SIZE_AND_USED, size << 1);
204013cc:	00199693          	slli	a3,s3,0x1
	return c + chunk_size(h, c);
204013d0:	00040593          	mv	a1,s0
204013d4:	00090513          	mv	a0,s2
		((uint16_t *)cmem)[f] = val;
204013d8:	00d79123          	sh	a3,2(a5)
204013dc:	00e79023          	sh	a4,0(a5)
	return c + chunk_size(h, c);
204013e0:	ca9ff0ef          	jal	ra,20401088 <chunk_size>
	void *cmem = &buf[c];
204013e4:	00a40433          	add	s0,s0,a0
		((uint16_t *)cmem)[f] = val;
204013e8:	00341413          	slli	s0,s0,0x3
204013ec:	00890433          	add	s0,s2,s0
204013f0:	01341023          	sh	s3,0(s0)
}
204013f4:	01c12083          	lw	ra,28(sp)
204013f8:	01812403          	lw	s0,24(sp)
204013fc:	01412483          	lw	s1,20(sp)
20401400:	01012903          	lw	s2,16(sp)
20401404:	00c12983          	lw	s3,12(sp)
20401408:	02010113          	addi	sp,sp,32
2040140c:	00008067          	ret

20401410 <free_chunk>:
{
20401410:	ff010113          	addi	sp,sp,-16
20401414:	00812423          	sw	s0,8(sp)
20401418:	00912223          	sw	s1,4(sp)
2040141c:	00058413          	mv	s0,a1
20401420:	00050493          	mv	s1,a0
20401424:	00112623          	sw	ra,12(sp)
20401428:	01212023          	sw	s2,0(sp)
	return c + chunk_size(h, c);
2040142c:	c5dff0ef          	jal	ra,20401088 <chunk_size>
20401430:	00a405b3          	add	a1,s0,a0
		return ((uint16_t *)cmem)[f];
20401434:	00359793          	slli	a5,a1,0x3
20401438:	00f487b3          	add	a5,s1,a5
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
2040143c:	0027d783          	lhu	a5,2(a5)
	if (!chunk_used(h, right_chunk(h, c))) {
20401440:	0017f793          	andi	a5,a5,1
20401444:	02079463          	bnez	a5,2040146c <free_chunk+0x5c>
		free_list_remove(h, right_chunk(h, c));
20401448:	00048513          	mv	a0,s1
2040144c:	d6dff0ef          	jal	ra,204011b8 <free_list_remove>
	return c + chunk_size(h, c);
20401450:	00040593          	mv	a1,s0
20401454:	00048513          	mv	a0,s1
20401458:	c31ff0ef          	jal	ra,20401088 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
2040145c:	00a40633          	add	a2,s0,a0
20401460:	00040593          	mv	a1,s0
20401464:	00048513          	mv	a0,s1
20401468:	e95ff0ef          	jal	ra,204012fc <merge_chunks>
	void *cmem = &buf[c];
2040146c:	00341913          	slli	s2,s0,0x3
		return ((uint16_t *)cmem)[f];
20401470:	01248933          	add	s2,s1,s2
20401474:	00095583          	lhu	a1,0(s2)
	return c - chunk_field(h, c, LEFT_SIZE);
20401478:	40b405b3          	sub	a1,s0,a1
		return ((uint16_t *)cmem)[f];
2040147c:	00359793          	slli	a5,a1,0x3
20401480:	00f487b3          	add	a5,s1,a5
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
20401484:	0027d783          	lhu	a5,2(a5)
	if (!chunk_used(h, left_chunk(h, c))) {
20401488:	0017f793          	andi	a5,a5,1
2040148c:	02079463          	bnez	a5,204014b4 <free_chunk+0xa4>
		free_list_remove(h, left_chunk(h, c));
20401490:	00048513          	mv	a0,s1
20401494:	d25ff0ef          	jal	ra,204011b8 <free_list_remove>
		return ((uint16_t *)cmem)[f];
20401498:	00095583          	lhu	a1,0(s2)
		merge_chunks(h, left_chunk(h, c), c);
2040149c:	00040613          	mv	a2,s0
204014a0:	00048513          	mv	a0,s1
204014a4:	40b405b3          	sub	a1,s0,a1
204014a8:	e55ff0ef          	jal	ra,204012fc <merge_chunks>
204014ac:	00095783          	lhu	a5,0(s2)
	return c - chunk_field(h, c, LEFT_SIZE);
204014b0:	40f40433          	sub	s0,s0,a5
	free_list_add(h, c);
204014b4:	00040593          	mv	a1,s0
}
204014b8:	00812403          	lw	s0,8(sp)
204014bc:	00c12083          	lw	ra,12(sp)
204014c0:	00012903          	lw	s2,0(sp)
	free_list_add(h, c);
204014c4:	00048513          	mv	a0,s1
}
204014c8:	00412483          	lw	s1,4(sp)
204014cc:	01010113          	addi	sp,sp,16
	free_list_add(h, c);
204014d0:	bcdff06f          	j	2040109c <free_list_add>

204014d4 <sys_heap_free>:
	if (mem == NULL) {
204014d4:	10058c63          	beqz	a1,204015ec <sys_heap_free+0x118>
{
204014d8:	fe010113          	addi	sp,sp,-32
204014dc:	01212823          	sw	s2,16(sp)
	struct z_heap *h = heap->heap;
204014e0:	00052903          	lw	s2,0(a0)
{
204014e4:	00812c23          	sw	s0,24(sp)
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
204014e8:	ffc58413          	addi	s0,a1,-4
204014ec:	41240433          	sub	s0,s0,s2
{
204014f0:	01312623          	sw	s3,12(sp)
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
204014f4:	00345993          	srli	s3,s0,0x3
	void *cmem = &buf[c];
204014f8:	ff847413          	andi	s0,s0,-8
		return ((uint16_t *)cmem)[f];
204014fc:	00890433          	add	s0,s2,s0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
20401500:	00245783          	lhu	a5,2(s0)
{
20401504:	00912a23          	sw	s1,20(sp)
20401508:	00112e23          	sw	ra,28(sp)
2040150c:	01412423          	sw	s4,8(sp)
	__ASSERT(chunk_used(h, c),
20401510:	0017f793          	andi	a5,a5,1
20401514:	00058493          	mv	s1,a1
20401518:	04079063          	bnez	a5,20401558 <sys_heap_free+0x84>
2040151c:	20408a37          	lui	s4,0x20408
20401520:	204085b7          	lui	a1,0x20408
20401524:	20408537          	lui	a0,0x20408
20401528:	0a300693          	li	a3,163
2040152c:	5a0a0613          	addi	a2,s4,1440 # 204085a0 <led1+0xc>
20401530:	5c458593          	addi	a1,a1,1476 # 204085c4 <led1+0x30>
20401534:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20401538:	af1ff0ef          	jal	ra,20401028 <printk>
2040153c:	20408537          	lui	a0,0x20408
20401540:	00048593          	mv	a1,s1
20401544:	5d850513          	addi	a0,a0,1496 # 204085d8 <led1+0x44>
20401548:	ae1ff0ef          	jal	ra,20401028 <printk>
2040154c:	0a300593          	li	a1,163
20401550:	5a0a0513          	addi	a0,s4,1440
20401554:	218010ef          	jal	ra,2040276c <assert_post_action>
	return c + chunk_size(h, c);
20401558:	00098593          	mv	a1,s3
2040155c:	00090513          	mv	a0,s2
20401560:	b29ff0ef          	jal	ra,20401088 <chunk_size>
20401564:	00a98533          	add	a0,s3,a0
		return ((uint16_t *)cmem)[f];
20401568:	00351793          	slli	a5,a0,0x3
2040156c:	00f907b3          	add	a5,s2,a5
20401570:	0007d783          	lhu	a5,0(a5)
	return c - chunk_field(h, c, LEFT_SIZE);
20401574:	40f50533          	sub	a0,a0,a5
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
20401578:	04a98063          	beq	s3,a0,204015b8 <sys_heap_free+0xe4>
2040157c:	20408a37          	lui	s4,0x20408
20401580:	204085b7          	lui	a1,0x20408
20401584:	20408537          	lui	a0,0x20408
20401588:	0ab00693          	li	a3,171
2040158c:	5a0a0613          	addi	a2,s4,1440 # 204085a0 <led1+0xc>
20401590:	61058593          	addi	a1,a1,1552 # 20408610 <led1+0x7c>
20401594:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20401598:	a91ff0ef          	jal	ra,20401028 <printk>
2040159c:	20408537          	lui	a0,0x20408
204015a0:	00048593          	mv	a1,s1
204015a4:	63850513          	addi	a0,a0,1592 # 20408638 <led1+0xa4>
204015a8:	a81ff0ef          	jal	ra,20401028 <printk>
204015ac:	0ab00593          	li	a1,171
204015b0:	5a0a0513          	addi	a0,s4,1440
204015b4:	1b8010ef          	jal	ra,2040276c <assert_post_action>
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
204015b8:	00245783          	lhu	a5,2(s0)
}
204015bc:	01c12083          	lw	ra,28(sp)
204015c0:	01412483          	lw	s1,20(sp)
204015c4:	ffe7f793          	andi	a5,a5,-2
204015c8:	00f41123          	sh	a5,2(s0)
204015cc:	01812403          	lw	s0,24(sp)
204015d0:	00812a03          	lw	s4,8(sp)
	free_chunk(h, c);
204015d4:	00098593          	mv	a1,s3
204015d8:	00090513          	mv	a0,s2
}
204015dc:	00c12983          	lw	s3,12(sp)
204015e0:	01012903          	lw	s2,16(sp)
204015e4:	02010113          	addi	sp,sp,32
	free_chunk(h, c);
204015e8:	e29ff06f          	j	20401410 <free_chunk>
204015ec:	00008067          	ret

204015f0 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
204015f0:	ff010113          	addi	sp,sp,-16
204015f4:	01212023          	sw	s2,0(sp)
204015f8:	00112623          	sw	ra,12(sp)
204015fc:	00812423          	sw	s0,8(sp)
20401600:	00912223          	sw	s1,4(sp)
	struct z_heap *h = heap->heap;
20401604:	00052903          	lw	s2,0(a0)

	if (bytes == 0U || size_too_big(h, bytes)) {
20401608:	02059063          	bnez	a1,20401628 <sys_heap_alloc+0x38>
		return NULL;
2040160c:	00000513          	li	a0,0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
20401610:	00c12083          	lw	ra,12(sp)
20401614:	00812403          	lw	s0,8(sp)
20401618:	00412483          	lw	s1,4(sp)
2040161c:	00012903          	lw	s2,0(sp)
20401620:	01010113          	addi	sp,sp,16
20401624:	00008067          	ret
	if (bytes == 0U || size_too_big(h, bytes)) {
20401628:	00892703          	lw	a4,8(s2)
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
2040162c:	0035d793          	srli	a5,a1,0x3
20401630:	fce7fee3          	bgeu	a5,a4,2040160c <sys_heap_alloc+0x1c>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
20401634:	00b58593          	addi	a1,a1,11
20401638:	0035d413          	srli	s0,a1,0x3
	chunkid_t c = alloc_chunk(h, chunk_sz);
2040163c:	00040593          	mv	a1,s0
20401640:	00090513          	mv	a0,s2
20401644:	bb9ff0ef          	jal	ra,204011fc <alloc_chunk>
20401648:	00050493          	mv	s1,a0
	if (c == 0U) {
2040164c:	fc0500e3          	beqz	a0,2040160c <sys_heap_alloc+0x1c>
	if (chunk_size(h, c) > chunk_sz) {
20401650:	00050593          	mv	a1,a0
20401654:	00090513          	mv	a0,s2
20401658:	a31ff0ef          	jal	ra,20401088 <chunk_size>
2040165c:	02a47263          	bgeu	s0,a0,20401680 <sys_heap_alloc+0x90>
		split_chunks(h, c, c + chunk_sz);
20401660:	00848433          	add	s0,s1,s0
20401664:	00048593          	mv	a1,s1
20401668:	00090513          	mv	a0,s2
2040166c:	00040613          	mv	a2,s0
20401670:	d11ff0ef          	jal	ra,20401380 <split_chunks>
		free_list_add(h, c + chunk_sz);
20401674:	00040593          	mv	a1,s0
20401678:	00090513          	mv	a0,s2
2040167c:	a21ff0ef          	jal	ra,2040109c <free_list_add>
	void *cmem = &buf[c];
20401680:	00349493          	slli	s1,s1,0x3
20401684:	00990733          	add	a4,s2,s1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
20401688:	00275783          	lhu	a5,2(a4)
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
2040168c:	00448493          	addi	s1,s1,4
20401690:	00990533          	add	a0,s2,s1
20401694:	0017e793          	ori	a5,a5,1
20401698:	00f71123          	sh	a5,2(a4)
	return chunk_mem(h, c);
2040169c:	f75ff06f          	j	20401610 <sys_heap_alloc+0x20>

204016a0 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
204016a0:	fd010113          	addi	sp,sp,-48
204016a4:	01312e23          	sw	s3,28(sp)
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
204016a8:	40b009b3          	neg	s3,a1
{
204016ac:	02812423          	sw	s0,40(sp)
204016b0:	03212023          	sw	s2,32(sp)
204016b4:	02112623          	sw	ra,44(sp)
204016b8:	02912223          	sw	s1,36(sp)
204016bc:	01412c23          	sw	s4,24(sp)
204016c0:	01512a23          	sw	s5,20(sp)
204016c4:	01612823          	sw	s6,16(sp)
	rew = align & -align;
204016c8:	00b9f9b3          	and	s3,s3,a1
	struct z_heap *h = heap->heap;
204016cc:	00052903          	lw	s2,0(a0)
{
204016d0:	00060413          	mv	s0,a2
	if (align != rew) {
204016d4:	09358c63          	beq	a1,s3,2040176c <sys_heap_aligned_alloc+0xcc>
		align -= rew;
204016d8:	00400793          	li	a5,4
204016dc:	413585b3          	sub	a1,a1,s3
		return false;
204016e0:	00098493          	mv	s1,s3
204016e4:	0137f463          	bgeu	a5,s3,204016ec <sys_heap_aligned_alloc+0x4c>
204016e8:	00400493          	li	s1,4
204016ec:	00098a93          	mv	s5,s3
204016f0:	00058993          	mv	s3,a1
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
204016f4:	fff98a13          	addi	s4,s3,-1
204016f8:	013a77b3          	and	a5,s4,s3
204016fc:	02078e63          	beqz	a5,20401738 <sys_heap_aligned_alloc+0x98>
20401700:	20408b37          	lui	s6,0x20408
20401704:	204085b7          	lui	a1,0x20408
20401708:	20408537          	lui	a0,0x20408
2040170c:	67458593          	addi	a1,a1,1652 # 20408674 <led1+0xe0>
20401710:	12700693          	li	a3,295
20401714:	5a0b0613          	addi	a2,s6,1440 # 204085a0 <led1+0xc>
20401718:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040171c:	90dff0ef          	jal	ra,20401028 <printk>
20401720:	20408537          	lui	a0,0x20408
20401724:	69050513          	addi	a0,a0,1680 # 20408690 <led1+0xfc>
20401728:	901ff0ef          	jal	ra,20401028 <printk>
2040172c:	12700593          	li	a1,295
20401730:	5a0b0513          	addi	a0,s6,1440
20401734:	038010ef          	jal	ra,2040276c <assert_post_action>

	if (bytes == 0 || size_too_big(h, bytes)) {
20401738:	06041a63          	bnez	s0,204017ac <sys_heap_aligned_alloc+0x10c>
		return NULL;
2040173c:	00000a93          	li	s5,0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
20401740:	02c12083          	lw	ra,44(sp)
20401744:	02812403          	lw	s0,40(sp)
20401748:	02412483          	lw	s1,36(sp)
2040174c:	02012903          	lw	s2,32(sp)
20401750:	01c12983          	lw	s3,28(sp)
20401754:	01812a03          	lw	s4,24(sp)
20401758:	01012b03          	lw	s6,16(sp)
2040175c:	000a8513          	mv	a0,s5
20401760:	01412a83          	lw	s5,20(sp)
20401764:	03010113          	addi	sp,sp,48
20401768:	00008067          	ret
		if (align <= chunk_header_bytes(h)) {
2040176c:	00400793          	li	a5,4
20401770:	02b7e863          	bltu	a5,a1,204017a0 <sys_heap_aligned_alloc+0x100>
}
20401774:	02812403          	lw	s0,40(sp)
20401778:	02c12083          	lw	ra,44(sp)
2040177c:	02412483          	lw	s1,36(sp)
20401780:	02012903          	lw	s2,32(sp)
20401784:	01c12983          	lw	s3,28(sp)
20401788:	01812a03          	lw	s4,24(sp)
2040178c:	01412a83          	lw	s5,20(sp)
20401790:	01012b03          	lw	s6,16(sp)
			return sys_heap_alloc(heap, bytes);
20401794:	00060593          	mv	a1,a2
}
20401798:	03010113          	addi	sp,sp,48
			return sys_heap_alloc(heap, bytes);
2040179c:	e55ff06f          	j	204015f0 <sys_heap_alloc>
		rew = 0;
204017a0:	00000a93          	li	s5,0
		gap = chunk_header_bytes(h);
204017a4:	00400493          	li	s1,4
204017a8:	f4dff06f          	j	204016f4 <sys_heap_aligned_alloc+0x54>
	if (bytes == 0 || size_too_big(h, bytes)) {
204017ac:	00892703          	lw	a4,8(s2)
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
204017b0:	00345793          	srli	a5,s0,0x3
204017b4:	f8e7f4e3          	bgeu	a5,a4,2040173c <sys_heap_aligned_alloc+0x9c>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
204017b8:	00b40593          	addi	a1,s0,11
204017bc:	013585b3          	add	a1,a1,s3
204017c0:	409585b3          	sub	a1,a1,s1
	chunkid_t c0 = alloc_chunk(h, padded_sz);
204017c4:	0035d593          	srli	a1,a1,0x3
204017c8:	00090513          	mv	a0,s2
204017cc:	a31ff0ef          	jal	ra,204011fc <alloc_chunk>
204017d0:	00050593          	mv	a1,a0
	if (c0 == 0) {
204017d4:	f60504e3          	beqz	a0,2040173c <sys_heap_aligned_alloc+0x9c>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
204017d8:	004a8793          	addi	a5,s5,4
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
204017dc:	00351493          	slli	s1,a0,0x3
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
204017e0:	00f484b3          	add	s1,s1,a5
204017e4:	009904b3          	add	s1,s2,s1
204017e8:	014484b3          	add	s1,s1,s4
204017ec:	413009b3          	neg	s3,s3
204017f0:	0134f9b3          	and	s3,s1,s3
204017f4:	41598ab3          	sub	s5,s3,s5
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
204017f8:	008a8433          	add	s0,s5,s0
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
204017fc:	ffca8993          	addi	s3,s5,-4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
20401800:	00740413          	addi	s0,s0,7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
20401804:	412989b3          	sub	s3,s3,s2
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
20401808:	ff847413          	andi	s0,s0,-8
	chunkid_t c_end = end - chunk_buf(h);
2040180c:	41240433          	sub	s0,s0,s2
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
20401810:	0039d993          	srli	s3,s3,0x3
	chunkid_t c_end = end - chunk_buf(h);
20401814:	40345413          	srai	s0,s0,0x3
	if (c > c0) {
20401818:	03357063          	bgeu	a0,s3,20401838 <sys_heap_aligned_alloc+0x198>
		split_chunks(h, c0, c);
2040181c:	00a12623          	sw	a0,12(sp)
20401820:	00098613          	mv	a2,s3
20401824:	00090513          	mv	a0,s2
20401828:	b59ff0ef          	jal	ra,20401380 <split_chunks>
		free_list_add(h, c0);
2040182c:	00c12583          	lw	a1,12(sp)
20401830:	00090513          	mv	a0,s2
20401834:	869ff0ef          	jal	ra,2040109c <free_list_add>
	return c + chunk_size(h, c);
20401838:	00098593          	mv	a1,s3
2040183c:	00090513          	mv	a0,s2
20401840:	849ff0ef          	jal	ra,20401088 <chunk_size>
20401844:	00a98533          	add	a0,s3,a0
	if (right_chunk(h, c) > c_end) {
20401848:	02a47063          	bgeu	s0,a0,20401868 <sys_heap_aligned_alloc+0x1c8>
		split_chunks(h, c, c_end);
2040184c:	00098593          	mv	a1,s3
20401850:	00090513          	mv	a0,s2
20401854:	00040613          	mv	a2,s0
20401858:	b29ff0ef          	jal	ra,20401380 <split_chunks>
		free_list_add(h, c_end);
2040185c:	00040593          	mv	a1,s0
20401860:	00090513          	mv	a0,s2
20401864:	839ff0ef          	jal	ra,2040109c <free_list_add>
	void *cmem = &buf[c];
20401868:	00399993          	slli	s3,s3,0x3
2040186c:	01390933          	add	s2,s2,s3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
20401870:	00295783          	lhu	a5,2(s2)
20401874:	0017e793          	ori	a5,a5,1
20401878:	00f91123          	sh	a5,2(s2)
2040187c:	ec5ff06f          	j	20401740 <sys_heap_aligned_alloc+0xa0>

20401880 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
20401880:	fe010113          	addi	sp,sp,-32
20401884:	00812c23          	sw	s0,24(sp)
20401888:	00912a23          	sw	s1,20(sp)
2040188c:	01212823          	sw	s2,16(sp)
20401890:	00112e23          	sw	ra,28(sp)
20401894:	01312623          	sw	s3,12(sp)
20401898:	01412423          	sw	s4,8(sp)
2040189c:	01512223          	sw	s5,4(sp)
204018a0:	01612023          	sw	s6,0(sp)
	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		/* Must fit in a 15 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
204018a4:	000407b7          	lui	a5,0x40
{
204018a8:	00050913          	mv	s2,a0
204018ac:	00058413          	mv	s0,a1
204018b0:	00060493          	mv	s1,a2
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
204018b4:	18f66863          	bltu	a2,a5,20401a44 <sys_heap_init+0x1c4>
204018b8:	204089b7          	lui	s3,0x20408
204018bc:	204085b7          	lui	a1,0x20408
204018c0:	20408537          	lui	a0,0x20408
204018c4:	6b058593          	addi	a1,a1,1712 # 204086b0 <led1+0x11c>
204018c8:	1a500693          	li	a3,421
204018cc:	5a098613          	addi	a2,s3,1440 # 204085a0 <led1+0xc>
204018d0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204018d4:	f54ff0ef          	jal	ra,20401028 <printk>
204018d8:	20408537          	lui	a0,0x20408
204018dc:	6c850513          	addi	a0,a0,1736 # 204086c8 <led1+0x134>
204018e0:	f48ff0ef          	jal	ra,20401028 <printk>
204018e4:	1a500593          	li	a1,421
		/* Must fit in a 31 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
204018e8:	5a098513          	addi	a0,s3,1440
204018ec:	681000ef          	jal	ra,2040276c <assert_post_action>
	bytes -= heap_footer_bytes(bytes);
204018f0:	ffc48493          	addi	s1,s1,-4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
204018f4:	00740993          	addi	s3,s0,7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
204018f8:	00940433          	add	s0,s0,s1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
204018fc:	ff89f993          	andi	s3,s3,-8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
20401900:	ff847413          	andi	s0,s0,-8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
20401904:	41340433          	sub	s0,s0,s3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
20401908:	01700793          	li	a5,23
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
2040190c:	00345a13          	srli	s4,s0,0x3
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
20401910:	0287ee63          	bltu	a5,s0,2040194c <sys_heap_init+0xcc>
20401914:	204084b7          	lui	s1,0x20408
20401918:	204085b7          	lui	a1,0x20408
2040191c:	20408537          	lui	a0,0x20408
20401920:	72058593          	addi	a1,a1,1824 # 20408720 <led1+0x18c>
20401924:	1b500693          	li	a3,437
20401928:	5a048613          	addi	a2,s1,1440 # 204085a0 <led1+0xc>
2040192c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20401930:	ef8ff0ef          	jal	ra,20401028 <printk>
20401934:	20408537          	lui	a0,0x20408
20401938:	70450513          	addi	a0,a0,1796 # 20408704 <led1+0x170>
2040193c:	eecff0ef          	jal	ra,20401028 <printk>
20401940:	1b500593          	li	a1,437
20401944:	5a048513          	addi	a0,s1,1440
20401948:	625000ef          	jal	ra,2040276c <assert_post_action>

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
2040194c:	01392023          	sw	s3,0(s2)
	h->end_chunk = heap_sz;
20401950:	0149a423          	sw	s4,8(s3)
	h->avail_buckets = 0;
20401954:	0009a623          	sw	zero,12(s3)
	return 31 - __builtin_clz(usable_sz);
20401958:	000a0513          	mv	a0,s4
2040195c:	989fe0ef          	jal	ra,204002e4 <__clzsi2>
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
20401960:	02400493          	li	s1,36
20401964:	40a484b3          	sub	s1,s1,a0
20401968:	00249493          	slli	s1,s1,0x2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
2040196c:	00748493          	addi	s1,s1,7
20401970:	0034d493          	srli	s1,s1,0x3
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
20401974:	02000913          	li	s2,32
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
20401978:	00148793          	addi	a5,s1,1
	struct z_heap *h = (struct z_heap *)addr;
2040197c:	00098a93          	mv	s5,s3
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
20401980:	40a90933          	sub	s2,s2,a0
	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
20401984:	02fa7e63          	bgeu	s4,a5,204019c0 <sys_heap_init+0x140>
20401988:	20408b37          	lui	s6,0x20408
2040198c:	204085b7          	lui	a1,0x20408
20401990:	20408537          	lui	a0,0x20408
20401994:	74c58593          	addi	a1,a1,1868 # 2040874c <led1+0x1b8>
20401998:	1c500693          	li	a3,453
2040199c:	5a0b0613          	addi	a2,s6,1440 # 204085a0 <led1+0xc>
204019a0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204019a4:	e84ff0ef          	jal	ra,20401028 <printk>
204019a8:	20408537          	lui	a0,0x20408
204019ac:	70450513          	addi	a0,a0,1796 # 20408704 <led1+0x170>
204019b0:	e78ff0ef          	jal	ra,20401028 <printk>
204019b4:	1c500593          	li	a1,453
204019b8:	5a0b0513          	addi	a0,s6,1440
204019bc:	5b1000ef          	jal	ra,2040276c <assert_post_action>
204019c0:	00291913          	slli	s2,s2,0x2
204019c4:	01390933          	add	s2,s2,s3

	for (int i = 0; i < nb_buckets; i++) {
204019c8:	0b391c63          	bne	s2,s3,20401a80 <sys_heap_init+0x200>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
204019cc:	00149793          	slli	a5,s1,0x1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
204019d0:	0017e793          	ori	a5,a5,1
204019d4:	00fa9123          	sh	a5,2(s5)
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
204019d8:	409a0733          	sub	a4,s4,s1
	void *cmem = &buf[c];
204019dc:	00349793          	slli	a5,s1,0x3
		((uint16_t *)cmem)[f] = val;
204019e0:	000a9023          	sh	zero,0(s5)
204019e4:	00fa87b3          	add	a5,s5,a5
	chunk_set(h, c, SIZE_AND_USED, size << 1);
204019e8:	00171693          	slli	a3,a4,0x1
		((uint16_t *)cmem)[f] = val;
204019ec:	00979023          	sh	s1,0(a5) # 40000 <__rom_region_size+0x36d44>
204019f0:	00d79123          	sh	a3,2(a5)
204019f4:	008a8433          	add	s0,s5,s0
	void *cmem = &buf[c];
204019f8:	003a1513          	slli	a0,s4,0x3
		((uint16_t *)cmem)[f] = val;
204019fc:	00041123          	sh	zero,2(s0)
20401a00:	00e41023          	sh	a4,0(s0)
	void *cmem = &buf[c];
20401a04:	00aa8533          	add	a0,s5,a0
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
20401a08:	00255783          	lhu	a5,2(a0)
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
20401a0c:	01812403          	lw	s0,24(sp)
20401a10:	01c12083          	lw	ra,28(sp)
20401a14:	0017e793          	ori	a5,a5,1
20401a18:	01012903          	lw	s2,16(sp)
20401a1c:	00c12983          	lw	s3,12(sp)
20401a20:	00812a03          	lw	s4,8(sp)
20401a24:	00012b03          	lw	s6,0(sp)
20401a28:	00f51123          	sh	a5,2(a0)
	free_list_add(h, chunk0_size);
20401a2c:	00048593          	mv	a1,s1
20401a30:	000a8513          	mv	a0,s5
}
20401a34:	01412483          	lw	s1,20(sp)
20401a38:	00412a83          	lw	s5,4(sp)
20401a3c:	02010113          	addi	sp,sp,32
	free_list_add(h, chunk0_size);
20401a40:	e5cff06f          	j	2040109c <free_list_add>
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
20401a44:	00400793          	li	a5,4
20401a48:	eac7e4e3          	bltu	a5,a2,204018f0 <sys_heap_init+0x70>
20401a4c:	204089b7          	lui	s3,0x20408
20401a50:	204085b7          	lui	a1,0x20408
20401a54:	20408537          	lui	a0,0x20408
20401a58:	6e058593          	addi	a1,a1,1760 # 204086e0 <led1+0x14c>
20401a5c:	1ac00693          	li	a3,428
20401a60:	5a098613          	addi	a2,s3,1440 # 204085a0 <led1+0xc>
20401a64:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20401a68:	dc0ff0ef          	jal	ra,20401028 <printk>
20401a6c:	20408537          	lui	a0,0x20408
20401a70:	70450513          	addi	a0,a0,1796 # 20408704 <led1+0x170>
20401a74:	db4ff0ef          	jal	ra,20401028 <printk>
20401a78:	1ac00593          	li	a1,428
20401a7c:	e6dff06f          	j	204018e8 <sys_heap_init+0x68>
		h->buckets[i].next = 0;
20401a80:	0009a823          	sw	zero,16(s3)
	for (int i = 0; i < nb_buckets; i++) {
20401a84:	00498993          	addi	s3,s3,4
20401a88:	f41ff06f          	j	204019c8 <sys_heap_init+0x148>

20401a8c <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
20401a8c:	fd010113          	addi	sp,sp,-48
20401a90:	02812423          	sw	s0,40(sp)
20401a94:	02912223          	sw	s1,36(sp)
20401a98:	03212023          	sw	s2,32(sp)
20401a9c:	01312e23          	sw	s3,28(sp)
20401aa0:	01712623          	sw	s7,12(sp)
20401aa4:	01812423          	sw	s8,8(sp)
20401aa8:	01912223          	sw	s9,4(sp)
20401aac:	02112623          	sw	ra,44(sp)
20401ab0:	01412c23          	sw	s4,24(sp)
20401ab4:	01512a23          	sw	s5,20(sp)
20401ab8:	01612823          	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier);
20401abc:	00364783          	lbu	a5,3(a2)
{
20401ac0:	00070413          	mv	s0,a4
	switch (specifier) {
20401ac4:	06f00713          	li	a4,111
{
20401ac8:	00050c13          	mv	s8,a0
20401acc:	00058c93          	mv	s9,a1
20401ad0:	00060b93          	mv	s7,a2
20401ad4:	00068913          	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
20401ad8:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
20401adc:	00800493          	li	s1,8
20401ae0:	00e78c63          	beq	a5,a4,20401af8 <encode_uint+0x6c>
20401ae4:	0cf76263          	bltu	a4,a5,20401ba8 <encode_uint+0x11c>
20401ae8:	05800713          	li	a4,88
		return 10;
20401aec:	00a00493          	li	s1,10
	switch (specifier) {
20401af0:	00e79463          	bne	a5,a4,20401af8 <encode_uint+0x6c>
		return 16;
20401af4:	01000493          	li	s1,16
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
20401af8:	00000a93          	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
20401afc:	00900a13          	li	s4,9
20401b00:	01900b13          	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
20401b04:	00048613          	mv	a2,s1
20401b08:	00000693          	li	a3,0
20401b0c:	000c0513          	mv	a0,s8
20401b10:	000c8593          	mv	a1,s9
20401b14:	ca1fe0ef          	jal	ra,204007b4 <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
20401b18:	0ff57793          	andi	a5,a0,255
20401b1c:	0aaa6263          	bltu	s4,a0,20401bc0 <encode_uint+0x134>
20401b20:	03078793          	addi	a5,a5,48
20401b24:	0ff7f793          	andi	a5,a5,255
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
20401b28:	00048613          	mv	a2,s1
20401b2c:	00000693          	li	a3,0
20401b30:	000c0513          	mv	a0,s8
20401b34:	000c8593          	mv	a1,s9
		*--bp = (lsv <= 9) ? ('0' + lsv)
20401b38:	fef40fa3          	sb	a5,-1(s0)
20401b3c:	fff40413          	addi	s0,s0,-1
		value /= radix;
20401b40:	841fe0ef          	jal	ra,20400380 <__udivdi3>
	} while ((value != 0) && (bps < bp));
20401b44:	019a9463          	bne	s5,s9,20401b4c <encode_uint+0xc0>
20401b48:	009c6463          	bltu	s8,s1,20401b50 <encode_uint+0xc4>
20401b4c:	06896463          	bltu	s2,s0,20401bb4 <encode_uint+0x128>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
20401b50:	000bd783          	lhu	a5,0(s7)
20401b54:	0207f793          	andi	a5,a5,32
20401b58:	00078c63          	beqz	a5,20401b70 <encode_uint+0xe4>
		if (radix == 8) {
20401b5c:	00800793          	li	a5,8
20401b60:	06f49a63          	bne	s1,a5,20401bd4 <encode_uint+0x148>
			conv->altform_0 = true;
20401b64:	002bc783          	lbu	a5,2(s7)
20401b68:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
20401b6c:	00fb8123          	sb	a5,2(s7)
			;
		}
	}

	return bp;
}
20401b70:	02c12083          	lw	ra,44(sp)
20401b74:	00040513          	mv	a0,s0
20401b78:	02812403          	lw	s0,40(sp)
20401b7c:	02412483          	lw	s1,36(sp)
20401b80:	02012903          	lw	s2,32(sp)
20401b84:	01c12983          	lw	s3,28(sp)
20401b88:	01812a03          	lw	s4,24(sp)
20401b8c:	01412a83          	lw	s5,20(sp)
20401b90:	01012b03          	lw	s6,16(sp)
20401b94:	00c12b83          	lw	s7,12(sp)
20401b98:	00812c03          	lw	s8,8(sp)
20401b9c:	00412c83          	lw	s9,4(sp)
20401ba0:	03010113          	addi	sp,sp,48
20401ba4:	00008067          	ret
	switch (specifier) {
20401ba8:	0f77f793          	andi	a5,a5,247
20401bac:	07000713          	li	a4,112
20401bb0:	f3dff06f          	j	20401aec <encode_uint+0x60>
		value /= radix;
20401bb4:	00050c13          	mv	s8,a0
20401bb8:	00058c93          	mv	s9,a1
20401bbc:	f49ff06f          	j	20401b04 <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
20401bc0:	013b6663          	bltu	s6,s3,20401bcc <encode_uint+0x140>
20401bc4:	03778793          	addi	a5,a5,55
20401bc8:	f5dff06f          	j	20401b24 <encode_uint+0x98>
20401bcc:	05778793          	addi	a5,a5,87
20401bd0:	f55ff06f          	j	20401b24 <encode_uint+0x98>
		} else if (radix == 16) {
20401bd4:	01000793          	li	a5,16
20401bd8:	f8f49ce3          	bne	s1,a5,20401b70 <encode_uint+0xe4>
			conv->altform_0c = true;
20401bdc:	002bc783          	lbu	a5,2(s7)
20401be0:	0107e793          	ori	a5,a5,16
20401be4:	f89ff06f          	j	20401b6c <encode_uint+0xe0>

20401be8 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
20401be8:	fe010113          	addi	sp,sp,-32
20401bec:	00812c23          	sw	s0,24(sp)
20401bf0:	00912a23          	sw	s1,20(sp)
20401bf4:	01212823          	sw	s2,16(sp)
20401bf8:	01312623          	sw	s3,12(sp)
20401bfc:	01412423          	sw	s4,8(sp)
20401c00:	00112e23          	sw	ra,28(sp)
20401c04:	00050993          	mv	s3,a0
20401c08:	00058a13          	mv	s4,a1
20401c0c:	00060493          	mv	s1,a2
20401c10:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
20401c14:	00060413          	mv	s0,a2
20401c18:	40940533          	sub	a0,s0,s1
20401c1c:	01246863          	bltu	s0,s2,20401c2c <outs+0x44>
20401c20:	02091063          	bnez	s2,20401c40 <outs+0x58>
20401c24:	00044783          	lbu	a5,0(s0)
20401c28:	00078c63          	beqz	a5,20401c40 <outs+0x58>
		int rc = out((int)*sp++, ctx);
20401c2c:	00044503          	lbu	a0,0(s0)
20401c30:	000a0593          	mv	a1,s4
20401c34:	00140413          	addi	s0,s0,1
20401c38:	000980e7          	jalr	s3

		if (rc < 0) {
20401c3c:	fc055ee3          	bgez	a0,20401c18 <outs+0x30>
		}
		++count;
	}

	return (int)count;
}
20401c40:	01c12083          	lw	ra,28(sp)
20401c44:	01812403          	lw	s0,24(sp)
20401c48:	01412483          	lw	s1,20(sp)
20401c4c:	01012903          	lw	s2,16(sp)
20401c50:	00c12983          	lw	s3,12(sp)
20401c54:	00812a03          	lw	s4,8(sp)
20401c58:	02010113          	addi	sp,sp,32
20401c5c:	00008067          	ret

20401c60 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
20401c60:	f7010113          	addi	sp,sp,-144
20401c64:	07512a23          	sw	s5,116(sp)
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
20401c68:	20409ab7          	lui	s5,0x20409
20401c6c:	804a8793          	addi	a5,s5,-2044 # 20408804 <led1+0x270>
{
20401c70:	07612823          	sw	s6,112(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
20401c74:	20409b37          	lui	s6,0x20409
{
20401c78:	07712623          	sw	s7,108(sp)
20401c7c:	07812423          	sw	s8,104(sp)
		switch (conv->specifier) {
20401c80:	00f12223          	sw	a5,4(sp)
				conv->specifier = 'x';

				goto prec_int_pad0;
			}

			bps = "(nil)";
20401c84:	20408bb7          	lui	s7,0x20408
	switch ((enum length_mod_enum)conv->length_mod) {
20401c88:	85cb0793          	addi	a5,s6,-1956 # 2040885c <led1+0x2c8>
			bpe = bps + 5;
20401c8c:	20408c37          	lui	s8,0x20408
{
20401c90:	09212023          	sw	s2,128(sp)
20401c94:	07312e23          	sw	s3,124(sp)
20401c98:	07912223          	sw	s9,100(sp)
20401c9c:	07a12023          	sw	s10,96(sp)
20401ca0:	05b12e23          	sw	s11,92(sp)
20401ca4:	08112623          	sw	ra,140(sp)
20401ca8:	08812423          	sw	s0,136(sp)
20401cac:	08912223          	sw	s1,132(sp)
20401cb0:	07412c23          	sw	s4,120(sp)
20401cb4:	00050913          	mv	s2,a0
20401cb8:	00058993          	mv	s3,a1
20401cbc:	00060d13          	mv	s10,a2
20401cc0:	00068c93          	mv	s9,a3
	size_t count = 0;
20401cc4:	00000d93          	li	s11,0
	switch ((enum length_mod_enum)conv->length_mod) {
20401cc8:	00f12423          	sw	a5,8(sp)
			bps = "(nil)";
20401ccc:	778b8b93          	addi	s7,s7,1912 # 20408778 <led1+0x1e4>
			bpe = bps + 5;
20401cd0:	77dc0c13          	addi	s8,s8,1917 # 2040877d <led1+0x1e9>
	while (*fp != 0) {
20401cd4:	000d4403          	lbu	s0,0(s10)
20401cd8:	00041663          	bnez	s0,20401ce4 <cbvprintf+0x84>
			OUTC(' ');
			--width;
		}
	}

	return count;
20401cdc:	000d8513          	mv	a0,s11
20401ce0:	2290006f          	j	20402708 <cbvprintf+0xaa8>
		if (*fp != '%') {
20401ce4:	02500793          	li	a5,37
			OUTC(*fp++);
20401ce8:	001d0a13          	addi	s4,s10,1
		if (*fp != '%') {
20401cec:	02f40463          	beq	s0,a5,20401d14 <cbvprintf+0xb4>
			OUTC(*fp++);
20401cf0:	00098593          	mv	a1,s3
20401cf4:	00040513          	mv	a0,s0
20401cf8:	000900e7          	jalr	s2
20401cfc:	200546e3          	bltz	a0,20402708 <cbvprintf+0xaa8>
20401d00:	001d8d93          	addi	s11,s11,1
			continue;
20401d04:	000c8413          	mv	s0,s9
20401d08:	00040c93          	mv	s9,s0
20401d0c:	000a0d13          	mv	s10,s4
20401d10:	fc5ff06f          	j	20401cd4 <cbvprintf+0x74>
		} state = {
20401d14:	02000613          	li	a2,32
20401d18:	00000593          	li	a1,0
20401d1c:	03010513          	addi	a0,sp,48
20401d20:	501000ef          	jal	ra,20402a20 <memset>
	if (*sp == '%') {
20401d24:	001d4783          	lbu	a5,1(s10)
20401d28:	0e879263          	bne	a5,s0,20401e0c <cbvprintf+0x1ac>
		conv->specifier = *sp++;
20401d2c:	002d0a13          	addi	s4,s10,2
20401d30:	04f101a3          	sb	a5,67(sp)
		if (conv->width_star) {
20401d34:	04015783          	lhu	a5,64(sp)
20401d38:	1007f713          	andi	a4,a5,256
20401d3c:	52070e63          	beqz	a4,20402278 <cbvprintf+0x618>
			width = va_arg(ap, int);
20401d40:	000ca483          	lw	s1,0(s9)
20401d44:	004c8413          	addi	s0,s9,4
			if (width < 0) {
20401d48:	0004d863          	bgez	s1,20401d58 <cbvprintf+0xf8>
				conv->flag_dash = true;
20401d4c:	0047e793          	ori	a5,a5,4
20401d50:	04f11023          	sh	a5,64(sp)
				width = -width;
20401d54:	409004b3          	neg	s1,s1
		if (conv->prec_star) {
20401d58:	04015703          	lhu	a4,64(sp)
20401d5c:	40077793          	andi	a5,a4,1024
20401d60:	52078c63          	beqz	a5,20402298 <cbvprintf+0x638>
			int arg = va_arg(ap, int);
20401d64:	00042a83          	lw	s5,0(s0)
20401d68:	00440413          	addi	s0,s0,4
			if (arg < 0) {
20401d6c:	000ad863          	bgez	s5,20401d7c <cbvprintf+0x11c>
				conv->prec_present = false;
20401d70:	dff77713          	andi	a4,a4,-513
20401d74:	04e11023          	sh	a4,64(sp)
		int precision = -1;
20401d78:	fff00a93          	li	s5,-1
			= (enum specifier_cat_enum)conv->specifier_cat;
20401d7c:	04012583          	lw	a1,64(sp)
		conv->pad0_value = 0;
20401d80:	04012223          	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
20401d84:	04012423          	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
20401d88:	0105d693          	srli	a3,a1,0x10
			= (enum length_mod_enum)conv->length_mod;
20401d8c:	00b5d713          	srli	a4,a1,0xb
		enum specifier_cat_enum specifier_cat
20401d90:	0076f693          	andi	a3,a3,7
		if (specifier_cat == SPECIFIER_SINT) {
20401d94:	00100613          	li	a2,1
			= (enum length_mod_enum)conv->length_mod;
20401d98:	00f77713          	andi	a4,a4,15
		if (specifier_cat == SPECIFIER_SINT) {
20401d9c:	56c69263          	bne	a3,a2,20402300 <cbvprintf+0x6a0>
			switch (length_mod) {
20401da0:	00500613          	li	a2,5
20401da4:	50c70e63          	beq	a4,a2,204022c0 <cbvprintf+0x660>
20401da8:	00e66a63          	bltu	a2,a4,20401dbc <cbvprintf+0x15c>
20401dac:	00300693          	li	a3,3
20401db0:	4ed70e63          	beq	a4,a3,204022ac <cbvprintf+0x64c>
20401db4:	00400693          	li	a3,4
20401db8:	50d70463          	beq	a4,a3,204022c0 <cbvprintf+0x660>
					(sint_value_type)va_arg(ap, ptrdiff_t);
20401dbc:	00042683          	lw	a3,0(s0)
20401dc0:	00440413          	addi	s0,s0,4
20401dc4:	02d12823          	sw	a3,48(sp)
20401dc8:	41f6d693          	srai	a3,a3,0x1f
20401dcc:	02d12a23          	sw	a3,52(sp)
			if (length_mod == LENGTH_HH) {
20401dd0:	00100693          	li	a3,1
20401dd4:	50d71863          	bne	a4,a3,204022e4 <cbvprintf+0x684>
				value->uint = (unsigned char)value->uint;
20401dd8:	03014683          	lbu	a3,48(sp)
				value->uint = (unsigned short)value->uint;
20401ddc:	02d12823          	sw	a3,48(sp)
20401de0:	02012a23          	sw	zero,52(sp)
		if (conv->invalid || conv->unsupported) {
20401de4:	0035f593          	andi	a1,a1,3
20401de8:	5e058863          	beqz	a1,204023d8 <cbvprintf+0x778>
			OUTS(sp, fp);
20401dec:	000a0693          	mv	a3,s4
20401df0:	000d0613          	mv	a2,s10
20401df4:	00098593          	mv	a1,s3
20401df8:	00090513          	mv	a0,s2
20401dfc:	dedff0ef          	jal	ra,20401be8 <outs>
20401e00:	100544e3          	bltz	a0,20402708 <cbvprintf+0xaa8>
20401e04:	00ad8db3          	add	s11,s11,a0
			continue;
20401e08:	f01ff06f          	j	20401d08 <cbvprintf+0xa8>
20401e0c:	00000513          	li	a0,0
20401e10:	00000693          	li	a3,0
20401e14:	00000593          	li	a1,0
20401e18:	00000613          	li	a2,0
20401e1c:	00000713          	li	a4,0
		switch (*sp) {
20401e20:	02b00813          	li	a6,43
20401e24:	02d00893          	li	a7,45
20401e28:	03000313          	li	t1,48
20401e2c:	02000e13          	li	t3,32
20401e30:	02300e93          	li	t4,35
20401e34:	000a4783          	lbu	a5,0(s4)
20401e38:	13078863          	beq	a5,a6,20401f68 <cbvprintf+0x308>
20401e3c:	10f86e63          	bltu	a6,a5,20401f58 <cbvprintf+0x2f8>
20401e40:	13c78a63          	beq	a5,t3,20401f74 <cbvprintf+0x314>
20401e44:	13d78c63          	beq	a5,t4,20401f7c <cbvprintf+0x31c>
20401e48:	00070863          	beqz	a4,20401e58 <cbvprintf+0x1f8>
20401e4c:	04015703          	lhu	a4,64(sp)
20401e50:	00476713          	ori	a4,a4,4
20401e54:	04e11023          	sh	a4,64(sp)
20401e58:	00060863          	beqz	a2,20401e68 <cbvprintf+0x208>
20401e5c:	04015703          	lhu	a4,64(sp)
20401e60:	00876713          	ori	a4,a4,8
20401e64:	04e11023          	sh	a4,64(sp)
20401e68:	00058863          	beqz	a1,20401e78 <cbvprintf+0x218>
20401e6c:	04015703          	lhu	a4,64(sp)
20401e70:	01076713          	ori	a4,a4,16
20401e74:	04e11023          	sh	a4,64(sp)
20401e78:	00068863          	beqz	a3,20401e88 <cbvprintf+0x228>
20401e7c:	04015703          	lhu	a4,64(sp)
20401e80:	02076713          	ori	a4,a4,32
20401e84:	04e11023          	sh	a4,64(sp)
20401e88:	00050863          	beqz	a0,20401e98 <cbvprintf+0x238>
20401e8c:	04015703          	lhu	a4,64(sp)
20401e90:	04076713          	ori	a4,a4,64
20401e94:	04e11023          	sh	a4,64(sp)
	if (conv->flag_zero && conv->flag_dash) {
20401e98:	04012703          	lw	a4,64(sp)
20401e9c:	04400693          	li	a3,68
20401ea0:	04477713          	andi	a4,a4,68
20401ea4:	00d71863          	bne	a4,a3,20401eb4 <cbvprintf+0x254>
		conv->flag_zero = false;
20401ea8:	04015703          	lhu	a4,64(sp)
20401eac:	fbf77713          	andi	a4,a4,-65
20401eb0:	04e11023          	sh	a4,64(sp)
	conv->width_present = true;
20401eb4:	04015703          	lhu	a4,64(sp)
20401eb8:	08076693          	ori	a3,a4,128
20401ebc:	04d11023          	sh	a3,64(sp)
	if (*sp == '*') {
20401ec0:	02a00693          	li	a3,42
20401ec4:	10d79463          	bne	a5,a3,20401fcc <cbvprintf+0x36c>
			++sp;
20401ec8:	001a0793          	addi	a5,s4,1
		conv->width_star = true;
20401ecc:	18076713          	ori	a4,a4,384
		conv->unsupported |= ((conv->width_value < 0)
20401ed0:	04e11023          	sh	a4,64(sp)
	conv->prec_present = (*sp == '.');
20401ed4:	0007c603          	lbu	a2,0(a5)
20401ed8:	fd260713          	addi	a4,a2,-46
20401edc:	00173713          	seqz	a4,a4
20401ee0:	00971693          	slli	a3,a4,0x9
20401ee4:	04015703          	lhu	a4,64(sp)
20401ee8:	dff77713          	andi	a4,a4,-513
20401eec:	00d76733          	or	a4,a4,a3
20401ef0:	04e11023          	sh	a4,64(sp)
	if (!conv->prec_present) {
20401ef4:	02e00693          	li	a3,46
20401ef8:	0ed61a63          	bne	a2,a3,20401fec <cbvprintf+0x38c>
	if (*sp == '*') {
20401efc:	0017c603          	lbu	a2,1(a5)
20401f00:	02a00693          	li	a3,42
20401f04:	0cd60e63          	beq	a2,a3,20401fe0 <cbvprintf+0x380>
	++sp;
20401f08:	00178793          	addi	a5,a5,1
	size_t val = 0;
20401f0c:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
20401f10:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
20401f14:	00a00813          	li	a6,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
20401f18:	0007c683          	lbu	a3,0(a5)
20401f1c:	00178513          	addi	a0,a5,1
20401f20:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
20401f24:	16b67463          	bgeu	a2,a1,2040208c <cbvprintf+0x42c>
	conv->unsupported |= ((conv->prec_value < 0)
20401f28:	04012683          	lw	a3,64(sp)
	conv->prec_value = prec;
20401f2c:	04e12423          	sw	a4,72(sp)
			      || (prec != (size_t)conv->prec_value));
20401f30:	01f75713          	srli	a4,a4,0x1f
	conv->unsupported |= ((conv->prec_value < 0)
20401f34:	0016d693          	srli	a3,a3,0x1
20401f38:	0016f693          	andi	a3,a3,1
20401f3c:	00e6e733          	or	a4,a3,a4
20401f40:	04015683          	lhu	a3,64(sp)
20401f44:	00171713          	slli	a4,a4,0x1
20401f48:	ffd6f693          	andi	a3,a3,-3
20401f4c:	00e6e733          	or	a4,a3,a4
20401f50:	04e11023          	sh	a4,64(sp)
	return sp;
20401f54:	0980006f          	j	20401fec <cbvprintf+0x38c>
		switch (*sp) {
20401f58:	03178663          	beq	a5,a7,20401f84 <cbvprintf+0x324>
20401f5c:	ee6796e3          	bne	a5,t1,20401e48 <cbvprintf+0x1e8>
			conv->flag_zero = true;
20401f60:	00100513          	li	a0,1
20401f64:	0080006f          	j	20401f6c <cbvprintf+0x30c>
			conv->flag_plus = true;
20401f68:	00100613          	li	a2,1
			++sp;
20401f6c:	001a0a13          	addi	s4,s4,1
	} while (loop);
20401f70:	ec5ff06f          	j	20401e34 <cbvprintf+0x1d4>
			conv->flag_space = true;
20401f74:	00100593          	li	a1,1
20401f78:	ff5ff06f          	j	20401f6c <cbvprintf+0x30c>
			conv->flag_hash = true;
20401f7c:	00100693          	li	a3,1
20401f80:	fedff06f          	j	20401f6c <cbvprintf+0x30c>
		switch (*sp) {
20401f84:	00100713          	li	a4,1
20401f88:	fe5ff06f          	j	20401f6c <cbvprintf+0x30c>
		val = 10U * val + *sp++ - '0';
20401f8c:	03070733          	mul	a4,a4,a6
20401f90:	00050793          	mv	a5,a0
20401f94:	fd070713          	addi	a4,a4,-48
20401f98:	00d70733          	add	a4,a4,a3
20401f9c:	0007c683          	lbu	a3,0(a5)
20401fa0:	00178513          	addi	a0,a5,1
20401fa4:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
20401fa8:	feb672e3          	bgeu	a2,a1,20401f8c <cbvprintf+0x32c>
	if (sp != wp) {
20401fac:	f2fa04e3          	beq	s4,a5,20401ed4 <cbvprintf+0x274>
		conv->unsupported |= ((conv->width_value < 0)
20401fb0:	04015683          	lhu	a3,64(sp)
		conv->width_value = width;
20401fb4:	04e12223          	sw	a4,68(sp)
		conv->unsupported |= ((conv->width_value < 0)
20401fb8:	01f75713          	srli	a4,a4,0x1f
20401fbc:	00171713          	slli	a4,a4,0x1
20401fc0:	ffd6f693          	andi	a3,a3,-3
20401fc4:	00e6e733          	or	a4,a3,a4
20401fc8:	f09ff06f          	j	20401ed0 <cbvprintf+0x270>
20401fcc:	000a0793          	mv	a5,s4
	size_t val = 0;
20401fd0:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
20401fd4:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
20401fd8:	00a00813          	li	a6,10
20401fdc:	fc1ff06f          	j	20401f9c <cbvprintf+0x33c>
		conv->prec_star = true;
20401fe0:	40076713          	ori	a4,a4,1024
20401fe4:	04e11023          	sh	a4,64(sp)
		return ++sp;
20401fe8:	00278793          	addi	a5,a5,2
	switch (*sp) {
20401fec:	0007c603          	lbu	a2,0(a5)
20401ff0:	06c00713          	li	a4,108
		if (*++sp == 'h') {
20401ff4:	00178593          	addi	a1,a5,1
	switch (*sp) {
20401ff8:	10e60c63          	beq	a2,a4,20402110 <cbvprintf+0x4b0>
20401ffc:	0ac76263          	bltu	a4,a2,204020a0 <cbvprintf+0x440>
20402000:	06800713          	li	a4,104
20402004:	0ce60663          	beq	a2,a4,204020d0 <cbvprintf+0x470>
20402008:	06a00713          	li	a4,106
2040200c:	12e60863          	beq	a2,a4,2040213c <cbvprintf+0x4dc>
20402010:	04c00713          	li	a4,76
20402014:	14e60e63          	beq	a2,a4,20402170 <cbvprintf+0x510>
20402018:	00078593          	mv	a1,a5
	conv->specifier = *sp++;
2040201c:	0005c703          	lbu	a4,0(a1)
	switch (conv->specifier) {
20402020:	07800793          	li	a5,120
	conv->specifier = *sp++;
20402024:	00158a13          	addi	s4,a1,1
20402028:	04e101a3          	sb	a4,67(sp)
	switch (conv->specifier) {
2040202c:	22e7ec63          	bltu	a5,a4,20402264 <cbvprintf+0x604>
20402030:	05700793          	li	a5,87
20402034:	14e7ec63          	bltu	a5,a4,2040218c <cbvprintf+0x52c>
20402038:	04100793          	li	a5,65
2040203c:	00f70a63          	beq	a4,a5,20402050 <cbvprintf+0x3f0>
20402040:	fbb70713          	addi	a4,a4,-69
20402044:	0ff77713          	andi	a4,a4,255
20402048:	00200793          	li	a5,2
2040204c:	20e7ec63          	bltu	a5,a4,20402264 <cbvprintf+0x604>
		conv->specifier_cat = SPECIFIER_FP;
20402050:	04214783          	lbu	a5,66(sp)
20402054:	ff87f793          	andi	a5,a5,-8
20402058:	0047e793          	ori	a5,a5,4
2040205c:	04f10123          	sb	a5,66(sp)
			unsupported = true;
20402060:	00100793          	li	a5,1
	conv->unsupported |= unsupported;
20402064:	04012703          	lw	a4,64(sp)
20402068:	00175713          	srli	a4,a4,0x1
2040206c:	00177713          	andi	a4,a4,1
20402070:	00e7e7b3          	or	a5,a5,a4
20402074:	04015703          	lhu	a4,64(sp)
20402078:	00179793          	slli	a5,a5,0x1
2040207c:	ffd77713          	andi	a4,a4,-3
20402080:	00f767b3          	or	a5,a4,a5
20402084:	04f11023          	sh	a5,64(sp)
	return sp;
20402088:	cadff06f          	j	20401d34 <cbvprintf+0xd4>
		val = 10U * val + *sp++ - '0';
2040208c:	03070733          	mul	a4,a4,a6
20402090:	00050793          	mv	a5,a0
20402094:	fd070713          	addi	a4,a4,-48
20402098:	00e68733          	add	a4,a3,a4
2040209c:	e7dff06f          	j	20401f18 <cbvprintf+0x2b8>
	switch (*sp) {
204020a0:	07400713          	li	a4,116
204020a4:	0ae60a63          	beq	a2,a4,20402158 <cbvprintf+0x4f8>
204020a8:	07a00713          	li	a4,122
204020ac:	f6e616e3          	bne	a2,a4,20402018 <cbvprintf+0x3b8>
		conv->length_mod = LENGTH_Z;
204020b0:	04015783          	lhu	a5,64(sp)
204020b4:	ffff8737          	lui	a4,0xffff8
204020b8:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
204020bc:	00e7f7b3          	and	a5,a5,a4
204020c0:	00003737          	lui	a4,0x3
		conv->unsupported = true;
204020c4:	00e7e7b3          	or	a5,a5,a4
204020c8:	04f11023          	sh	a5,64(sp)
		break;
204020cc:	f51ff06f          	j	2040201c <cbvprintf+0x3bc>
		if (*++sp == 'h') {
204020d0:	04015503          	lhu	a0,64(sp)
204020d4:	0017c803          	lbu	a6,1(a5)
204020d8:	ffff86b7          	lui	a3,0xffff8
204020dc:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
204020e0:	00a77733          	and	a4,a4,a0
		if (*++sp == 'h') {
204020e4:	00c81e63          	bne	a6,a2,20402100 <cbvprintf+0x4a0>
			conv->length_mod = LENGTH_HH;
204020e8:	000016b7          	lui	a3,0x1
204020ec:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
204020f0:	00d76733          	or	a4,a4,a3
204020f4:	04e11023          	sh	a4,64(sp)
			++sp;
204020f8:	00278593          	addi	a1,a5,2
204020fc:	f21ff06f          	j	2040201c <cbvprintf+0x3bc>
			conv->length_mod = LENGTH_H;
20402100:	000017b7          	lui	a5,0x1
			conv->length_mod = LENGTH_L;
20402104:	00f76733          	or	a4,a4,a5
20402108:	04e11023          	sh	a4,64(sp)
2040210c:	f11ff06f          	j	2040201c <cbvprintf+0x3bc>
		if (*++sp == 'l') {
20402110:	04015503          	lhu	a0,64(sp)
20402114:	0017c803          	lbu	a6,1(a5) # 1001 <CONFIG_ISR_STACK_SIZE+0x801>
20402118:	ffff86b7          	lui	a3,0xffff8
2040211c:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
20402120:	00a77733          	and	a4,a4,a0
		if (*++sp == 'l') {
20402124:	00c81663          	bne	a6,a2,20402130 <cbvprintf+0x4d0>
			conv->length_mod = LENGTH_LL;
20402128:	000026b7          	lui	a3,0x2
2040212c:	fc5ff06f          	j	204020f0 <cbvprintf+0x490>
			conv->length_mod = LENGTH_L;
20402130:	000027b7          	lui	a5,0x2
20402134:	80078793          	addi	a5,a5,-2048 # 1800 <CONFIG_ISR_STACK_SIZE+0x1000>
20402138:	fcdff06f          	j	20402104 <cbvprintf+0x4a4>
		conv->length_mod = LENGTH_J;
2040213c:	04015783          	lhu	a5,64(sp)
20402140:	ffff8737          	lui	a4,0xffff8
20402144:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
20402148:	00e7f7b3          	and	a5,a5,a4
2040214c:	00003737          	lui	a4,0x3
		conv->length_mod = LENGTH_T;
20402150:	80070713          	addi	a4,a4,-2048 # 2800 <__kernel_ram_size+0x870>
20402154:	f71ff06f          	j	204020c4 <cbvprintf+0x464>
20402158:	04015783          	lhu	a5,64(sp)
2040215c:	ffff8737          	lui	a4,0xffff8
20402160:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
20402164:	00e7f7b3          	and	a5,a5,a4
20402168:	00004737          	lui	a4,0x4
2040216c:	fe5ff06f          	j	20402150 <cbvprintf+0x4f0>
		conv->unsupported = true;
20402170:	04015783          	lhu	a5,64(sp)
20402174:	ffff8737          	lui	a4,0xffff8
20402178:	7fd70713          	addi	a4,a4,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
2040217c:	00e7f7b3          	and	a5,a5,a4
20402180:	00004737          	lui	a4,0x4
20402184:	00270713          	addi	a4,a4,2 # 4002 <__kernel_ram_size+0x2072>
20402188:	f3dff06f          	j	204020c4 <cbvprintf+0x464>
	switch (conv->specifier) {
2040218c:	fa870793          	addi	a5,a4,-88
20402190:	0ff7f793          	andi	a5,a5,255
20402194:	02000693          	li	a3,32
20402198:	0cf6e663          	bltu	a3,a5,20402264 <cbvprintf+0x604>
2040219c:	204086b7          	lui	a3,0x20408
204021a0:	00279793          	slli	a5,a5,0x2
204021a4:	78068693          	addi	a3,a3,1920 # 20408780 <led1+0x1ec>
204021a8:	00d787b3          	add	a5,a5,a3
204021ac:	0007a783          	lw	a5,0(a5)
204021b0:	00078067          	jr	a5
		conv->specifier_cat = SPECIFIER_SINT;
204021b4:	04214783          	lbu	a5,66(sp)
204021b8:	ff87f793          	andi	a5,a5,-8
204021bc:	0017e793          	ori	a5,a5,1
		if (conv->length_mod == LENGTH_UPPER_L) {
204021c0:	04015683          	lhu	a3,64(sp)
		conv->specifier_cat = SPECIFIER_UINT;
204021c4:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
204021c8:	000087b7          	lui	a5,0x8
204021cc:	80078793          	addi	a5,a5,-2048 # 7800 <__kernel_ram_size+0x5870>
204021d0:	00f6f7b3          	and	a5,a3,a5
204021d4:	01079793          	slli	a5,a5,0x10
204021d8:	0107d793          	srli	a5,a5,0x10
204021dc:	00004637          	lui	a2,0x4
204021e0:	00c79663          	bne	a5,a2,204021ec <cbvprintf+0x58c>
			conv->invalid = true;
204021e4:	0016e693          	ori	a3,a3,1
204021e8:	04d11023          	sh	a3,64(sp)
		if (conv->specifier == 'c') {
204021ec:	06300693          	li	a3,99
	bool unsupported = false;
204021f0:	00000793          	li	a5,0
		if (conv->specifier == 'c') {
204021f4:	e6d718e3          	bne	a4,a3,20402064 <cbvprintf+0x404>
		if (conv->length_mod != LENGTH_NONE) {
204021f8:	04015703          	lhu	a4,64(sp)
204021fc:	000087b7          	lui	a5,0x8
20402200:	80078793          	addi	a5,a5,-2048 # 7800 <__kernel_ram_size+0x5870>
20402204:	00e7f7b3          	and	a5,a5,a4
20402208:	00f037b3          	snez	a5,a5
2040220c:	e59ff06f          	j	20402064 <cbvprintf+0x404>
		conv->specifier_cat = SPECIFIER_UINT;
20402210:	04214783          	lbu	a5,66(sp)
20402214:	ff87f793          	andi	a5,a5,-8
20402218:	0027e793          	ori	a5,a5,2
2040221c:	fa5ff06f          	j	204021c0 <cbvprintf+0x560>
		conv->specifier_cat = SPECIFIER_PTR;
20402220:	04214783          	lbu	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
20402224:	04015703          	lhu	a4,64(sp)
		conv->specifier_cat = SPECIFIER_PTR;
20402228:	ff87f793          	andi	a5,a5,-8
2040222c:	0037e793          	ori	a5,a5,3
20402230:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
20402234:	000087b7          	lui	a5,0x8
20402238:	80078793          	addi	a5,a5,-2048 # 7800 <__kernel_ram_size+0x5870>
2040223c:	00e7f7b3          	and	a5,a5,a4
20402240:	ffffc737          	lui	a4,0xffffc
20402244:	00e787b3          	add	a5,a5,a4
20402248:	0017b793          	seqz	a5,a5
2040224c:	e19ff06f          	j	20402064 <cbvprintf+0x404>
		conv->specifier_cat = SPECIFIER_PTR;
20402250:	04214783          	lbu	a5,66(sp)
20402254:	ff87f793          	andi	a5,a5,-8
20402258:	0037e793          	ori	a5,a5,3
2040225c:	04f10123          	sb	a5,66(sp)
20402260:	f99ff06f          	j	204021f8 <cbvprintf+0x598>
		conv->invalid = true;
20402264:	04015783          	lhu	a5,64(sp)
20402268:	0017e793          	ori	a5,a5,1
2040226c:	04f11023          	sh	a5,64(sp)
	bool unsupported = false;
20402270:	00000793          	li	a5,0
		break;
20402274:	df1ff06f          	j	20402064 <cbvprintf+0x404>
		} else if (conv->width_present) {
20402278:	0807f793          	andi	a5,a5,128
2040227c:	00078863          	beqz	a5,2040228c <cbvprintf+0x62c>
			width = conv->width_value;
20402280:	04412483          	lw	s1,68(sp)
20402284:	000c8413          	mv	s0,s9
20402288:	ad1ff06f          	j	20401d58 <cbvprintf+0xf8>
2040228c:	000c8413          	mv	s0,s9
		int width = -1;
20402290:	fff00493          	li	s1,-1
20402294:	ac5ff06f          	j	20401d58 <cbvprintf+0xf8>
		} else if (conv->prec_present) {
20402298:	20077713          	andi	a4,a4,512
		int precision = -1;
2040229c:	fff00a93          	li	s5,-1
		} else if (conv->prec_present) {
204022a0:	ac070ee3          	beqz	a4,20401d7c <cbvprintf+0x11c>
			precision = conv->prec_value;
204022a4:	04812a83          	lw	s5,72(sp)
204022a8:	ad5ff06f          	j	20401d7c <cbvprintf+0x11c>
					value->sint = va_arg(ap, long);
204022ac:	00440513          	addi	a0,s0,4
					value->uint = (wchar_t)va_arg(ap,
204022b0:	00042683          	lw	a3,0(s0)
204022b4:	02d12823          	sw	a3,48(sp)
204022b8:	41f6d693          	srai	a3,a3,0x1f
204022bc:	01c0006f          	j	204022d8 <cbvprintf+0x678>
					(sint_value_type)va_arg(ap, long long);
204022c0:	00740413          	addi	s0,s0,7
204022c4:	ff847413          	andi	s0,s0,-8
				value->sint =
204022c8:	00042603          	lw	a2,0(s0)
204022cc:	00442683          	lw	a3,4(s0)
					(sint_value_type)va_arg(ap, long long);
204022d0:	00840513          	addi	a0,s0,8
				value->sint =
204022d4:	02c12823          	sw	a2,48(sp)
204022d8:	02d12a23          	sw	a3,52(sp)
					(uint_value_type)va_arg(ap, size_t);
204022dc:	00050413          	mv	s0,a0
204022e0:	b05ff06f          	j	20401de4 <cbvprintf+0x184>
			} else if (length_mod == LENGTH_H) {
204022e4:	00200693          	li	a3,2
204022e8:	aed71ee3          	bne	a4,a3,20401de4 <cbvprintf+0x184>
				value->sint = (short)value->sint;
204022ec:	03011683          	lh	a3,48(sp)
204022f0:	02d12823          	sw	a3,48(sp)
204022f4:	41f6d693          	srai	a3,a3,0x1f
				value->dbl = va_arg(ap, double);
204022f8:	02d12a23          	sw	a3,52(sp)
204022fc:	ae9ff06f          	j	20401de4 <cbvprintf+0x184>
		} else if (specifier_cat == SPECIFIER_UINT) {
20402300:	00200513          	li	a0,2
20402304:	06a69463          	bne	a3,a0,2040236c <cbvprintf+0x70c>
			switch (length_mod) {
20402308:	00500693          	li	a3,5
2040230c:	fad70ae3          	beq	a4,a3,204022c0 <cbvprintf+0x660>
20402310:	00e6ea63          	bltu	a3,a4,20402324 <cbvprintf+0x6c4>
20402314:	00300693          	li	a3,3
20402318:	02d70a63          	beq	a4,a3,2040234c <cbvprintf+0x6ec>
2040231c:	00400693          	li	a3,4
20402320:	fad700e3          	beq	a4,a3,204022c0 <cbvprintf+0x660>
					(uint_value_type)va_arg(ap, size_t);
20402324:	00042683          	lw	a3,0(s0)
20402328:	02012a23          	sw	zero,52(sp)
2040232c:	00440413          	addi	s0,s0,4
20402330:	02d12823          	sw	a3,48(sp)
			if (length_mod == LENGTH_HH) {
20402334:	00100693          	li	a3,1
20402338:	aad700e3          	beq	a4,a3,20401dd8 <cbvprintf+0x178>
			} else if (length_mod == LENGTH_H) {
2040233c:	00200693          	li	a3,2
20402340:	aad712e3          	bne	a4,a3,20401de4 <cbvprintf+0x184>
				value->uint = (unsigned short)value->uint;
20402344:	03015683          	lhu	a3,48(sp)
20402348:	a95ff06f          	j	20401ddc <cbvprintf+0x17c>
				if ((!WCHAR_IS_SIGNED)
2040234c:	04314603          	lbu	a2,67(sp)
20402350:	06300693          	li	a3,99
				value->sint = va_arg(ap, int);
20402354:	00440513          	addi	a0,s0,4
				if ((!WCHAR_IS_SIGNED)
20402358:	f4d60ce3          	beq	a2,a3,204022b0 <cbvprintf+0x650>
					value->uint = va_arg(ap, unsigned long);
2040235c:	00042683          	lw	a3,0(s0)
20402360:	02012a23          	sw	zero,52(sp)
20402364:	02d12823          	sw	a3,48(sp)
20402368:	f75ff06f          	j	204022dc <cbvprintf+0x67c>
		} else if (specifier_cat == SPECIFIER_FP) {
2040236c:	00400613          	li	a2,4
20402370:	04c69a63          	bne	a3,a2,204023c4 <cbvprintf+0x764>
			if (length_mod == LENGTH_UPPER_L) {
20402374:	00800693          	li	a3,8
20402378:	02d71863          	bne	a4,a3,204023a8 <cbvprintf+0x748>
				value->ldbl = va_arg(ap, long double);
2040237c:	00042683          	lw	a3,0(s0)
20402380:	0006a803          	lw	a6,0(a3)
20402384:	0046a503          	lw	a0,4(a3)
20402388:	0086a603          	lw	a2,8(a3)
2040238c:	00c6a683          	lw	a3,12(a3)
20402390:	03012823          	sw	a6,48(sp)
20402394:	02a12a23          	sw	a0,52(sp)
20402398:	02c12c23          	sw	a2,56(sp)
2040239c:	02d12e23          	sw	a3,60(sp)
			value->ptr = va_arg(ap, void *);
204023a0:	00440413          	addi	s0,s0,4
204023a4:	a41ff06f          	j	20401de4 <cbvprintf+0x184>
				value->dbl = va_arg(ap, double);
204023a8:	00740693          	addi	a3,s0,7
204023ac:	ff86f693          	andi	a3,a3,-8
204023b0:	0006a603          	lw	a2,0(a3)
204023b4:	00868413          	addi	s0,a3,8
204023b8:	0046a683          	lw	a3,4(a3)
204023bc:	02c12823          	sw	a2,48(sp)
204023c0:	f39ff06f          	j	204022f8 <cbvprintf+0x698>
		} else if (specifier_cat == SPECIFIER_PTR) {
204023c4:	00300613          	li	a2,3
204023c8:	a0c69ee3          	bne	a3,a2,20401de4 <cbvprintf+0x184>
			value->ptr = va_arg(ap, void *);
204023cc:	00042683          	lw	a3,0(s0)
204023d0:	02d12823          	sw	a3,48(sp)
204023d4:	fcdff06f          	j	204023a0 <cbvprintf+0x740>
		switch (conv->specifier) {
204023d8:	04314683          	lbu	a3,67(sp)
204023dc:	07800613          	li	a2,120
204023e0:	92d664e3          	bltu	a2,a3,20401d08 <cbvprintf+0xa8>
204023e4:	06200613          	li	a2,98
204023e8:	00d66e63          	bltu	a2,a3,20402404 <cbvprintf+0x7a4>
204023ec:	02500713          	li	a4,37
204023f0:	02e68c63          	beq	a3,a4,20402428 <cbvprintf+0x7c8>
204023f4:	05800713          	li	a4,88
204023f8:	90e698e3          	bne	a3,a4,20401d08 <cbvprintf+0xa8>
204023fc:	00000b13          	li	s6,0
20402400:	2080006f          	j	20402608 <cbvprintf+0x9a8>
20402404:	f9d68693          	addi	a3,a3,-99
20402408:	0ff6f693          	andi	a3,a3,255
2040240c:	01500613          	li	a2,21
20402410:	8ed66ce3          	bltu	a2,a3,20401d08 <cbvprintf+0xa8>
20402414:	00412783          	lw	a5,4(sp)
20402418:	00269693          	slli	a3,a3,0x2
2040241c:	00f686b3          	add	a3,a3,a5
20402420:	0006a683          	lw	a3,0(a3)
20402424:	00068067          	jr	a3
			OUTC('%');
20402428:	00098593          	mv	a1,s3
2040242c:	02500513          	li	a0,37
20402430:	000900e7          	jalr	s2
20402434:	2c054a63          	bltz	a0,20402708 <cbvprintf+0xaa8>
20402438:	001d8d93          	addi	s11,s11,1
			break;
2040243c:	8cdff06f          	j	20401d08 <cbvprintf+0xa8>
			bps = (const char *)value->ptr;
20402440:	03012c83          	lw	s9,48(sp)
			if (precision >= 0) {
20402444:	160ac063          	bltz	s5,204025a4 <cbvprintf+0x944>
				len = strnlen(bps, precision);
20402448:	000a8593          	mv	a1,s5
2040244c:	000c8513          	mv	a0,s9
20402450:	588000ef          	jal	ra,204029d8 <strnlen>
			bpe = bps + len;
20402454:	00ac8d33          	add	s10,s9,a0
		char sign = 0;
20402458:	00000b13          	li	s6,0
		if (bps == NULL) {
2040245c:	8a0c86e3          	beqz	s9,20401d08 <cbvprintf+0xa8>
		size_t nj_len = (bpe - bps);
20402460:	419d07b3          	sub	a5,s10,s9
		if (sign != 0) {
20402464:	000b0463          	beqz	s6,2040246c <cbvprintf+0x80c>
			nj_len += 1U;
20402468:	00178793          	addi	a5,a5,1
		if (conv->altform_0c) {
2040246c:	04214703          	lbu	a4,66(sp)
20402470:	01077693          	andi	a3,a4,16
20402474:	26068663          	beqz	a3,204026e0 <cbvprintf+0xa80>
			nj_len += 2U;
20402478:	00278793          	addi	a5,a5,2
		nj_len += conv->pad0_value;
2040247c:	04412683          	lw	a3,68(sp)
		if (conv->pad_fp) {
20402480:	04077713          	andi	a4,a4,64
		nj_len += conv->pad0_value;
20402484:	00d787b3          	add	a5,a5,a3
		if (conv->pad_fp) {
20402488:	00070663          	beqz	a4,20402494 <cbvprintf+0x834>
			nj_len += conv->pad0_pre_exp;
2040248c:	04812703          	lw	a4,72(sp)
20402490:	00e787b3          	add	a5,a5,a4
		if (width > 0) {
20402494:	04905c63          	blez	s1,204024ec <cbvprintf+0x88c>
			width -= (int)nj_len;
20402498:	40f484b3          	sub	s1,s1,a5
			if (!conv->flag_dash) {
2040249c:	04012783          	lw	a5,64(sp)
204024a0:	0027d793          	srli	a5,a5,0x2
204024a4:	0017f793          	andi	a5,a5,1
204024a8:	04079263          	bnez	a5,204024ec <cbvprintf+0x88c>
				if (conv->flag_zero) {
204024ac:	04015783          	lhu	a5,64(sp)
204024b0:	0407f793          	andi	a5,a5,64
204024b4:	28078863          	beqz	a5,20402744 <cbvprintf+0xae4>
					if (sign != 0) {
204024b8:	280b0a63          	beqz	s6,2040274c <cbvprintf+0xaec>
						OUTC(sign);
204024bc:	00098593          	mv	a1,s3
204024c0:	000b0513          	mv	a0,s6
204024c4:	000900e7          	jalr	s2
204024c8:	24054063          	bltz	a0,20402708 <cbvprintf+0xaa8>
204024cc:	001d8d93          	addi	s11,s11,1
					pad = '0';
204024d0:	03000793          	li	a5,48
						sign = 0;
204024d4:	00000b13          	li	s6,0
204024d8:	01b48ab3          	add	s5,s1,s11
204024dc:	00048713          	mv	a4,s1
204024e0:	409a8db3          	sub	s11,s5,s1
				while (width-- > 0) {
204024e4:	fff48493          	addi	s1,s1,-1
204024e8:	20e04463          	bgtz	a4,204026f0 <cbvprintf+0xa90>
		if (sign != 0) {
204024ec:	000b0c63          	beqz	s6,20402504 <cbvprintf+0x8a4>
			OUTC(sign);
204024f0:	00098593          	mv	a1,s3
204024f4:	000b0513          	mv	a0,s6
204024f8:	000900e7          	jalr	s2
204024fc:	20054663          	bltz	a0,20402708 <cbvprintf+0xaa8>
20402500:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c | conv->altform_0) {
20402504:	04012783          	lw	a5,64(sp)
20402508:	0147d713          	srli	a4,a5,0x14
2040250c:	00177713          	andi	a4,a4,1
20402510:	00071863          	bnez	a4,20402520 <cbvprintf+0x8c0>
20402514:	0137d793          	srli	a5,a5,0x13
20402518:	0017f793          	andi	a5,a5,1
2040251c:	00078c63          	beqz	a5,20402534 <cbvprintf+0x8d4>
				OUTC('0');
20402520:	00098593          	mv	a1,s3
20402524:	03000513          	li	a0,48
20402528:	000900e7          	jalr	s2
2040252c:	1c054e63          	bltz	a0,20402708 <cbvprintf+0xaa8>
20402530:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c) {
20402534:	04214783          	lbu	a5,66(sp)
20402538:	0107f793          	andi	a5,a5,16
2040253c:	00078c63          	beqz	a5,20402554 <cbvprintf+0x8f4>
				OUTC(conv->specifier);
20402540:	04314503          	lbu	a0,67(sp)
20402544:	00098593          	mv	a1,s3
20402548:	000900e7          	jalr	s2
2040254c:	1a054e63          	bltz	a0,20402708 <cbvprintf+0xaa8>
20402550:	001d8d93          	addi	s11,s11,1
			while (pad_len-- > 0) {
20402554:	04412783          	lw	a5,68(sp)
20402558:	01b78ab3          	add	s5,a5,s11
2040255c:	41ba8733          	sub	a4,s5,s11
20402560:	1ee04a63          	bgtz	a4,20402754 <cbvprintf+0xaf4>
			OUTS(bps, bpe);
20402564:	000d0693          	mv	a3,s10
20402568:	000c8613          	mv	a2,s9
2040256c:	00098593          	mv	a1,s3
20402570:	00090513          	mv	a0,s2
20402574:	e74ff0ef          	jal	ra,20401be8 <outs>
20402578:	18054863          	bltz	a0,20402708 <cbvprintf+0xaa8>
2040257c:	01b50db3          	add	s11,a0,s11
		while (width > 0) {
20402580:	01b484b3          	add	s1,s1,s11
20402584:	41b487b3          	sub	a5,s1,s11
20402588:	f8f05063          	blez	a5,20401d08 <cbvprintf+0xa8>
			OUTC(' ');
2040258c:	00098593          	mv	a1,s3
20402590:	02000513          	li	a0,32
20402594:	000900e7          	jalr	s2
20402598:	16054863          	bltz	a0,20402708 <cbvprintf+0xaa8>
2040259c:	001d8d93          	addi	s11,s11,1
			--width;
204025a0:	fe5ff06f          	j	20402584 <cbvprintf+0x924>
				len = strlen(bps);
204025a4:	000c8513          	mv	a0,s9
204025a8:	410000ef          	jal	ra,204029b8 <strlen>
204025ac:	ea9ff06f          	j	20402454 <cbvprintf+0x7f4>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
204025b0:	03012783          	lw	a5,48(sp)
			bps = buf;
204025b4:	01810c93          	addi	s9,sp,24
			bpe = buf + 1;
204025b8:	01910d13          	addi	s10,sp,25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
204025bc:	00f10c23          	sb	a5,24(sp)
			break;
204025c0:	00000b13          	li	s6,0
204025c4:	e9dff06f          	j	20402460 <cbvprintf+0x800>
			if (conv->flag_plus) {
204025c8:	04015703          	lhu	a4,64(sp)
				sign = '+';
204025cc:	02b00b13          	li	s6,43
			if (conv->flag_plus) {
204025d0:	00877693          	andi	a3,a4,8
204025d4:	00069663          	bnez	a3,204025e0 <cbvprintf+0x980>
				sign = ' ';
204025d8:	00171b13          	slli	s6,a4,0x1
204025dc:	020b7b13          	andi	s6,s6,32
			sint = value->sint;
204025e0:	03412703          	lw	a4,52(sp)
204025e4:	03012683          	lw	a3,48(sp)
			if (sint < 0) {
204025e8:	02075063          	bgez	a4,20402608 <cbvprintf+0x9a8>
				value->uint = (uint_value_type)-sint;
204025ec:	40d00633          	neg	a2,a3
204025f0:	40e00733          	neg	a4,a4
204025f4:	00d036b3          	snez	a3,a3
204025f8:	40d70733          	sub	a4,a4,a3
204025fc:	02c12823          	sw	a2,48(sp)
20402600:	02e12a23          	sw	a4,52(sp)
				sign = '-';
20402604:	02d00b13          	li	s6,45
			bps = encode_uint(value->uint, conv, buf, bpe);
20402608:	03012503          	lw	a0,48(sp)
2040260c:	03412583          	lw	a1,52(sp)
20402610:	02e10713          	addi	a4,sp,46
20402614:	01810693          	addi	a3,sp,24
20402618:	04010613          	addi	a2,sp,64
2040261c:	c70ff0ef          	jal	ra,20401a8c <encode_uint>
20402620:	00050c93          	mv	s9,a0
			if (precision >= 0) {
20402624:	02e10d13          	addi	s10,sp,46
20402628:	e20acae3          	bltz	s5,2040245c <cbvprintf+0x7fc>
				conv->flag_zero = false;
2040262c:	04015683          	lhu	a3,64(sp)
				size_t len = bpe - bps;
20402630:	419d0733          	sub	a4,s10,s9
				conv->flag_zero = false;
20402634:	fbf6f693          	andi	a3,a3,-65
20402638:	04d11023          	sh	a3,64(sp)
				if (len < (size_t)precision) {
2040263c:	e35770e3          	bgeu	a4,s5,2040245c <cbvprintf+0x7fc>
					conv->pad0_value = precision - (int)len;
20402640:	40ea87b3          	sub	a5,s5,a4
20402644:	04f12223          	sw	a5,68(sp)
20402648:	e15ff06f          	j	2040245c <cbvprintf+0x7fc>
			if (value->ptr != NULL) {
2040264c:	03012503          	lw	a0,48(sp)
20402650:	08050263          	beqz	a0,204026d4 <cbvprintf+0xa74>
				bps = encode_uint((uintptr_t)value->ptr, conv,
20402654:	02e10713          	addi	a4,sp,46
20402658:	01810693          	addi	a3,sp,24
2040265c:	04010613          	addi	a2,sp,64
20402660:	00000593          	li	a1,0
20402664:	c28ff0ef          	jal	ra,20401a8c <encode_uint>
				conv->altform_0c = true;
20402668:	04215703          	lhu	a4,66(sp)
2040266c:	000086b7          	lui	a3,0x8
20402670:	81068693          	addi	a3,a3,-2032 # 7810 <__kernel_ram_size+0x5880>
20402674:	0ef77713          	andi	a4,a4,239
20402678:	00d76733          	or	a4,a4,a3
				bps = encode_uint((uintptr_t)value->ptr, conv,
2040267c:	00050c93          	mv	s9,a0
				conv->altform_0c = true;
20402680:	04e11123          	sh	a4,66(sp)
		char sign = 0;
20402684:	00000b13          	li	s6,0
				goto prec_int_pad0;
20402688:	f9dff06f          	j	20402624 <cbvprintf+0x9c4>
	switch ((enum length_mod_enum)conv->length_mod) {
2040268c:	00700693          	li	a3,7
				store_count(conv, value->ptr, count);
20402690:	03012783          	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
20402694:	e6e6ea63          	bltu	a3,a4,20401d08 <cbvprintf+0xa8>
20402698:	00812683          	lw	a3,8(sp)
2040269c:	00271713          	slli	a4,a4,0x2
204026a0:	00d70733          	add	a4,a4,a3
204026a4:	00072703          	lw	a4,0(a4) # ffffc000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffffc001>
204026a8:	00070067          	jr	a4
		*(signed char *)dp = (signed char)count;
204026ac:	01b78023          	sb	s11,0(a5)
		break;
204026b0:	e58ff06f          	j	20401d08 <cbvprintf+0xa8>
		*(short *)dp = (short)count;
204026b4:	01b79023          	sh	s11,0(a5)
		break;
204026b8:	e50ff06f          	j	20401d08 <cbvprintf+0xa8>
		*(intmax_t *)dp = (intmax_t)count;
204026bc:	41fdd713          	srai	a4,s11,0x1f
204026c0:	01b7a023          	sw	s11,0(a5)
204026c4:	00e7a223          	sw	a4,4(a5)
		break;
204026c8:	e40ff06f          	j	20401d08 <cbvprintf+0xa8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
204026cc:	01b7a023          	sw	s11,0(a5)
		break;
204026d0:	e38ff06f          	j	20401d08 <cbvprintf+0xa8>
			bps = "(nil)";
204026d4:	000b8c93          	mv	s9,s7
			bpe = bps + 5;
204026d8:	000c0d13          	mv	s10,s8
204026dc:	ee5ff06f          	j	204025c0 <cbvprintf+0x960>
		} else if (conv->altform_0) {
204026e0:	00877693          	andi	a3,a4,8
204026e4:	d8068ce3          	beqz	a3,2040247c <cbvprintf+0x81c>
			nj_len += 1U;
204026e8:	00178793          	addi	a5,a5,1
204026ec:	d91ff06f          	j	2040247c <cbvprintf+0x81c>
					OUTC(pad);
204026f0:	00078513          	mv	a0,a5
204026f4:	00098593          	mv	a1,s3
204026f8:	00f12623          	sw	a5,12(sp)
204026fc:	000900e7          	jalr	s2
20402700:	00c12783          	lw	a5,12(sp)
20402704:	dc055ce3          	bgez	a0,204024dc <cbvprintf+0x87c>
#undef OUTS
#undef OUTC
}
20402708:	08c12083          	lw	ra,140(sp)
2040270c:	08812403          	lw	s0,136(sp)
20402710:	08412483          	lw	s1,132(sp)
20402714:	08012903          	lw	s2,128(sp)
20402718:	07c12983          	lw	s3,124(sp)
2040271c:	07812a03          	lw	s4,120(sp)
20402720:	07412a83          	lw	s5,116(sp)
20402724:	07012b03          	lw	s6,112(sp)
20402728:	06c12b83          	lw	s7,108(sp)
2040272c:	06812c03          	lw	s8,104(sp)
20402730:	06412c83          	lw	s9,100(sp)
20402734:	06012d03          	lw	s10,96(sp)
20402738:	05c12d83          	lw	s11,92(sp)
2040273c:	09010113          	addi	sp,sp,144
20402740:	00008067          	ret
				char pad = ' ';
20402744:	02000793          	li	a5,32
20402748:	d91ff06f          	j	204024d8 <cbvprintf+0x878>
					pad = '0';
2040274c:	03000793          	li	a5,48
20402750:	d89ff06f          	j	204024d8 <cbvprintf+0x878>
				OUTC('0');
20402754:	00098593          	mv	a1,s3
20402758:	03000513          	li	a0,48
2040275c:	000900e7          	jalr	s2
20402760:	fa0544e3          	bltz	a0,20402708 <cbvprintf+0xaa8>
20402764:	001d8d93          	addi	s11,s11,1
20402768:	df5ff06f          	j	2040255c <cbvprintf+0x8fc>

2040276c <assert_post_action>:
	if (k_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
2040276c:	00deb7b7          	lui	a5,0xdeb
20402770:	d0078793          	addi	a5,a5,-768 # dead00 <__rom_region_size+0xde1a44>
20402774:	00078f13          	mv	t5,a5
20402778:	00400793          	li	a5,4
2040277c:	00078f93          	mv	t6,a5
20402780:	c0001073          	unimp
}
20402784:	00008067          	ret

20402788 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
20402788:	00008067          	ret

2040278c <arch_cpu_idle>:
 * '_pm_save_flag' variable is non-zero.
 *
 * @return N/A
 */
void arch_cpu_idle(void)
{
2040278c:	ff010113          	addi	sp,sp,-16
20402790:	00112623          	sw	ra,12(sp)
	sys_trace_idle();
20402794:	090000ef          	jal	ra,20402824 <sys_trace_idle>
 */
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	ulong_t mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
20402798:	00800793          	li	a5,8
2040279c:	3007a7f3          	csrrs	a5,mstatus,a5
	__asm__ volatile("wfi");
204027a0:	10500073          	wfi
	riscv_idle(MSTATUS_IEN);
}
204027a4:	00c12083          	lw	ra,12(sp)
204027a8:	01010113          	addi	sp,sp,16
204027ac:	00008067          	ret

204027b0 <arch_irq_enable>:
{
#if defined(CONFIG_3RD_LEVEL_INTERRUPTS)
	return ((irq >> 16) & 0xFF) != 0 ? 3 :
		(((irq >> 8) & 0xFF) == 0 ? 1 : 2);
#elif defined(CONFIG_2ND_LEVEL_INTERRUPTS)
	return ((irq >> 8) & 0xFF) == 0 ? 1 : 2;
204027b0:	00855793          	srli	a5,a0,0x8
204027b4:	0ff7f713          	andi	a4,a5,255
204027b8:	00071a63          	bnez	a4,204027cc <arch_irq_enable+0x1c>
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
204027bc:	00100793          	li	a5,1
204027c0:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
204027c4:	30452573          	csrrs	a0,mie,a0
}
204027c8:	00008067          	ret
		riscv_plic_irq_enable(irq);
204027cc:	fff78513          	addi	a0,a5,-1
204027d0:	4080006f          	j	20402bd8 <riscv_plic_irq_enable>

204027d4 <arch_irq_disable>:
204027d4:	00855793          	srli	a5,a0,0x8
204027d8:	0ff7f713          	andi	a4,a5,255
204027dc:	00071a63          	bnez	a4,204027f0 <arch_irq_disable+0x1c>
	 * Use atomic instruction csrrc to disable device interrupt in mie CSR.
	 * (atomic read and clear bits in CSR register)
	 */
	__asm__ volatile ("csrrc %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
204027e0:	00100793          	li	a5,1
204027e4:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrc %0, mie, %1\n"
204027e8:	30453573          	csrrc	a0,mie,a0
};
204027ec:	00008067          	ret
		riscv_plic_irq_disable(irq);
204027f0:	fff78513          	addi	a0,a5,-1
204027f4:	41c0006f          	j	20402c10 <riscv_plic_irq_disable>

204027f8 <arch_irq_priority_set>:
204027f8:	00855513          	srli	a0,a0,0x8
204027fc:	0ff57793          	andi	a5,a0,255
20402800:	00078663          	beqz	a5,2040280c <arch_irq_priority_set+0x14>
#if defined(CONFIG_RISCV_HAS_PLIC)
	unsigned int level = irq_get_level(irq);

	if (level == 2) {
		irq = irq_from_level_2(irq);
		riscv_plic_set_priority(irq, prio);
20402804:	fff50513          	addi	a0,a0,-1
20402808:	4440006f          	j	20402c4c <riscv_plic_set_priority>
#if defined(CONFIG_NUCLEI_ECLIC)
	nuclei_eclic_set_priority(irq, prio);
#endif

	return ;
}
2040280c:	00008067          	ret

20402810 <soc_interrupt_init>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20402810:	00800793          	li	a5,8
20402814:	3007b7f3          	csrrc	a5,mstatus,a5
__weak void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
20402818:	30405073          	csrwi	mie,0
2040281c:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
20402820:	00008067          	ret

20402824 <sys_trace_idle>:
20402824:	00008067          	ret

20402828 <pinmux_sifive_set>:
	((struct pinmux_sifive_regs_t *)(DEV_CFG(dev))->base)

static int pinmux_sifive_set(const struct device *dev, uint32_t pin,
			     uint32_t func)
{
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
20402828:	00452783          	lw	a5,4(a0)

	if (func > SIFIVE_PINMUX_IOF1 ||
2040282c:	00100713          	li	a4,1
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
20402830:	0007a783          	lw	a5,0(a5)
	if (func > SIFIVE_PINMUX_IOF1 ||
20402834:	04c76463          	bltu	a4,a2,2040287c <pinmux_sifive_set+0x54>
20402838:	01f00693          	li	a3,31
	    pin >= SIFIVE_PINMUX_PINS)
		return -EINVAL;
2040283c:	fea00513          	li	a0,-22
	if (func > SIFIVE_PINMUX_IOF1 ||
20402840:	04b6e063          	bltu	a3,a1,20402880 <pinmux_sifive_set+0x58>

	if (func == SIFIVE_PINMUX_IOF1)
		pinmux->iof_sel |= (SIFIVE_PINMUX_IOF1 << pin);
20402844:	00b715b3          	sll	a1,a4,a1
	if (func == SIFIVE_PINMUX_IOF1)
20402848:	02e61263          	bne	a2,a4,2040286c <pinmux_sifive_set+0x44>
		pinmux->iof_sel |= (SIFIVE_PINMUX_IOF1 << pin);
2040284c:	0047a703          	lw	a4,4(a5)
20402850:	00b76733          	or	a4,a4,a1
	else
		pinmux->iof_sel &= ~(SIFIVE_PINMUX_IOF1 << pin);
20402854:	00e7a223          	sw	a4,4(a5)

	/* Enable IO function for this pin */
	pinmux->iof_en |= (1 << pin);
20402858:	0007a703          	lw	a4,0(a5)

	return 0;
2040285c:	00000513          	li	a0,0
	pinmux->iof_en |= (1 << pin);
20402860:	00b765b3          	or	a1,a4,a1
20402864:	00b7a023          	sw	a1,0(a5)
	return 0;
20402868:	00008067          	ret
		pinmux->iof_sel &= ~(SIFIVE_PINMUX_IOF1 << pin);
2040286c:	0047a683          	lw	a3,4(a5)
20402870:	fff5c713          	not	a4,a1
20402874:	00d77733          	and	a4,a4,a3
20402878:	fddff06f          	j	20402854 <pinmux_sifive_set+0x2c>
		return -EINVAL;
2040287c:	fea00513          	li	a0,-22
}
20402880:	00008067          	ret

20402884 <pinmux_sifive_get>:

static int pinmux_sifive_get(const struct device *dev, uint32_t pin,
			     uint32_t *func)
{
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
20402884:	00452783          	lw	a5,4(a0)

	if (pin >= SIFIVE_PINMUX_PINS ||
20402888:	01f00713          	li	a4,31
	    func == NULL)
		return -EINVAL;
2040288c:	fea00513          	li	a0,-22
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
20402890:	0007a783          	lw	a5,0(a5)
	if (pin >= SIFIVE_PINMUX_PINS ||
20402894:	02b76463          	bltu	a4,a1,204028bc <pinmux_sifive_get+0x38>
20402898:	02060263          	beqz	a2,204028bc <pinmux_sifive_get+0x38>

	*func = (pinmux->iof_sel & (SIFIVE_PINMUX_IOF1 << pin)) ?
2040289c:	0047a703          	lw	a4,4(a5)
204028a0:	00100793          	li	a5,1
204028a4:	00b797b3          	sll	a5,a5,a1
204028a8:	00e7f7b3          	and	a5,a5,a4
		SIFIVE_PINMUX_IOF1 : SIFIVE_PINMUX_IOF0;
204028ac:	00f037b3          	snez	a5,a5
	*func = (pinmux->iof_sel & (SIFIVE_PINMUX_IOF1 << pin)) ?
204028b0:	00f62023          	sw	a5,0(a2) # 4000 <__kernel_ram_size+0x2070>

	return 0;
204028b4:	00000513          	li	a0,0
204028b8:	00008067          	ret
}
204028bc:	00008067          	ret

204028c0 <pinmux_sifive_pullup>:

static int pinmux_sifive_pullup(const struct device *dev, uint32_t pin,
				uint8_t func)
{
	return -ENOTSUP;
}
204028c0:	f7a00513          	li	a0,-134
204028c4:	00008067          	ret

204028c8 <pinmux_sifive_init>:
	return -ENOTSUP;
}

static int pinmux_sifive_init(const struct device *dev)
{
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
204028c8:	00452783          	lw	a5,4(a0)

	/* Ensure that all pins are disabled initially */
	pinmux->iof_en = 0x0;

	return 0;
}
204028cc:	00000513          	li	a0,0
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
204028d0:	0007a783          	lw	a5,0(a5)
	pinmux->iof_en = 0x0;
204028d4:	0007a023          	sw	zero,0(a5)
}
204028d8:	00008067          	ret

204028dc <pinmux_sifive_input>:
204028dc:	f7a00513          	li	a0,-134
204028e0:	00008067          	ret

204028e4 <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
204028e4:	ff010113          	addi	sp,sp,-16
204028e8:	00112623          	sw	ra,12(sp)
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
		LOG_ERR("");
	}

	z_fatal_error(reason, esf);
204028ec:	471010ef          	jal	ra,2040455c <z_fatal_error>

204028f0 <_Fault>:
		return "unknown";
	}
}

void _Fault(z_arch_esf_t *esf)
{
204028f0:	ff010113          	addi	sp,sp,-16
204028f4:	00112623          	sw	ra,12(sp)
204028f8:	00050593          	mv	a1,a0
		}
	}
#endif /* CONFIG_USERSPACE */
	ulong_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
204028fc:	342027f3          	csrr	a5,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	ulong_t mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
20402900:	343027f3          	csrr	a5,mtval
#endif

	unsigned int reason = K_ERR_CPU_EXCEPTION;

#if !defined(CONFIG_USERSPACE)
	if (esf->t5 == ARCH_EXCEPT_MARKER) {
20402904:	01c52703          	lw	a4,28(a0)
20402908:	00deb7b7          	lui	a5,0xdeb
2040290c:	d0078793          	addi	a5,a5,-768 # dead00 <__rom_region_size+0xde1a44>
20402910:	00000513          	li	a0,0
20402914:	00f71463          	bne	a4,a5,2040291c <_Fault+0x2c>
		reason = esf->t6;
20402918:	0205a503          	lw	a0,32(a1)
	z_fatal_error(reason, esf);
2040291c:	441010ef          	jal	ra,2040455c <z_fatal_error>

20402920 <z_irq_spurious>:
#include <kernel_internal.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
20402920:	ff010113          	addi	sp,sp,-16
20402924:	00112623          	sw	ra,12(sp)
	ulong_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
20402928:	342027f3          	csrr	a5,mcause
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
2040292c:	00000593          	li	a1,0
20402930:	00100513          	li	a0,1
20402934:	fb1ff0ef          	jal	ra,204028e4 <z_riscv_fatal_error>

20402938 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
20402938:	ff010113          	addi	sp,sp,-16
2040293c:	00112623          	sw	ra,12(sp)
	z_bss_zero();
20402940:	591010ef          	jal	ra,204046d0 <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
20402944:	530040ef          	jal	ra,20406e74 <z_data_copy>
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
20402948:	ec9ff0ef          	jal	ra,20402810 <soc_interrupt_init>
#endif
#ifdef CONFIG_PMP_STACK_GUARD
	z_riscv_configure_interrupt_stack_guard();
#endif
	z_cstart();
2040294c:	5a5010ef          	jal	ra,204046f0 <z_cstart>

20402950 <__initialize>:
SECTION_FUNC(TEXT, __initialize)
	/*
	 * This will boot master core, just halt other cores.
	 * Note: need to be updated for complete SMP support
	 */
	csrr a0, mhartid
20402950:	f1402573          	csrr	a0,mhartid
	beqz a0, boot_master_core
20402954:	00050663          	beqz	a0,20402960 <boot_master_core>

20402958 <loop_slave_core>:

loop_slave_core:
	wfi
20402958:	10500073          	wfi
	j loop_slave_core
2040295c:	ffdff06f          	j	20402958 <loop_slave_core>

20402960 <boot_master_core>:

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + CONFIG_ISR_STACK_SIZE
	 */
	la sp, z_interrupt_stacks
20402960:	5fbff117          	auipc	sp,0x5fbff
20402964:	b9010113          	addi	sp,sp,-1136 # 800014f0 <z_interrupt_stacks>
	li t0, CONFIG_ISR_STACK_SIZE
20402968:	000012b7          	lui	t0,0x1
2040296c:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
20402970:	00510133          	add	sp,sp,t0

	csrw mscratch, sp
20402974:	34011073          	csrw	mscratch,sp

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
20402978:	fc1ff0ef          	jal	ra,20402938 <_PrepC>

2040297c <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
2040297c:	ee8fe06f          	j	20401064 <z_thread_entry>

20402980 <arch_new_thread>:
#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	const struct soc_esf soc_esf_init = {SOC_ESF_INIT};
#endif

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)Z_STACK_PTR_ALIGN(
20402980:	fb460613          	addi	a2,a2,-76
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
20402984:	ff067613          	andi	a2,a2,-16
				);

	/* Setup the initial stack frame */
	stack_init->a0 = (ulong_t)entry;
	stack_init->a1 = (ulong_t)p1;
	stack_init->a2 = (ulong_t)p2;
20402988:	02f62623          	sw	a5,44(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
2040298c:	000027b7          	lui	a5,0x2
20402990:	88078793          	addi	a5,a5,-1920 # 1880 <CONFIG_ISR_STACK_SIZE+0x1080>
20402994:	04f62423          	sw	a5,72(a2)
#elif defined(CONFIG_FPU)
	/* Unshared FP mode: enable FPU of each thread. */
	stack_init->mstatus |= MSTATUS_FS_INIT;
#endif

	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
20402998:	204037b7          	lui	a5,0x20403
2040299c:	97c78793          	addi	a5,a5,-1668 # 2040297c <z_thread_entry_wrapper>
	stack_init->a0 = (ulong_t)entry;
204029a0:	02d62223          	sw	a3,36(a2)
	stack_init->a1 = (ulong_t)p1;
204029a4:	02e62423          	sw	a4,40(a2)
	stack_init->a3 = (ulong_t)p3;
204029a8:	03062823          	sw	a6,48(a2)
	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
204029ac:	04f62223          	sw	a5,68(a2)

#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	stack_init->soc_context = soc_esf_init;
#endif

	thread->callee_saved.sp = (ulong_t)stack_init;
204029b0:	02c52823          	sw	a2,48(a0)
}
204029b4:	00008067          	ret

204029b8 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
204029b8:	00050793          	mv	a5,a0
	size_t n = 0;
204029bc:	00000513          	li	a0,0

	while (*s != '\0') {
204029c0:	00a78733          	add	a4,a5,a0
204029c4:	00074703          	lbu	a4,0(a4)
204029c8:	00071463          	bnez	a4,204029d0 <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
204029cc:	00008067          	ret
		n++;
204029d0:	00150513          	addi	a0,a0,1
204029d4:	fedff06f          	j	204029c0 <strlen+0x8>

204029d8 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
204029d8:	00050793          	mv	a5,a0
	size_t n = 0;
204029dc:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
204029e0:	00a78733          	add	a4,a5,a0
204029e4:	00074703          	lbu	a4,0(a4)
204029e8:	00070463          	beqz	a4,204029f0 <strnlen+0x18>
204029ec:	00b51463          	bne	a0,a1,204029f4 <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
204029f0:	00008067          	ret
		n++;
204029f4:	00150513          	addi	a0,a0,1
204029f8:	fe9ff06f          	j	204029e0 <strnlen+0x8>

204029fc <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
204029fc:	00000793          	li	a5,0
20402a00:	00f61463          	bne	a2,a5,20402a08 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
20402a04:	00008067          	ret
		*(d_byte++) = *(s_byte++);
20402a08:	00f586b3          	add	a3,a1,a5
20402a0c:	0006c683          	lbu	a3,0(a3)
20402a10:	00f50733          	add	a4,a0,a5
20402a14:	00178793          	addi	a5,a5,1
20402a18:	00d70023          	sb	a3,0(a4)
		n--;
20402a1c:	fe5ff06f          	j	20402a00 <memcpy+0x4>

20402a20 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
20402a20:	0ff5f593          	andi	a1,a1,255
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
20402a24:	00c50633          	add	a2,a0,a2
	unsigned char *d_byte = (unsigned char *)buf;
20402a28:	00050793          	mv	a5,a0
	while (n > 0) {
20402a2c:	00c79463          	bne	a5,a2,20402a34 <memset+0x14>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
20402a30:	00008067          	ret
		*(d_byte++) = c_byte;
20402a34:	00178793          	addi	a5,a5,1
20402a38:	feb78fa3          	sb	a1,-1(a5)
		n--;
20402a3c:	ff1ff06f          	j	20402a2c <memset+0xc>

20402a40 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
20402a40:	fff00513          	li	a0,-1
20402a44:	00008067          	ret

20402a48 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
20402a48:	80a1a223          	sw	a0,-2044(gp) # 80001e9c <_stdout_hook>
}
20402a4c:	00008067          	ret

20402a50 <pinmux_pin_set.constprop.0.isra.0>:
	pmux_get get;
	pmux_pullup pullup;
	pmux_input input;
};

static inline int pinmux_pin_set(const struct device *dev, uint32_t pin,
20402a50:	00050593          	mv	a1,a0
				 uint32_t func)
{
	const struct pinmux_driver_api *api =
20402a54:	20408537          	lui	a0,0x20408
20402a58:	f9450713          	addi	a4,a0,-108 # 20407f94 <__device_dts_ord_33>
		(const struct pinmux_driver_api *)dev->api;

	return api->set(dev, pin, func);
20402a5c:	00872703          	lw	a4,8(a4)
20402a60:	00000613          	li	a2,0
20402a64:	f9450513          	addi	a0,a0,-108
20402a68:	00072703          	lw	a4,0(a4)
20402a6c:	00070067          	jr	a4

20402a70 <artyA7_pinmux_init>:
#include <init.h>
#include <drivers/pinmux.h>
#include <soc.h>

static int artyA7_pinmux_init(const struct device *dev)
{
20402a70:	ff010113          	addi	sp,sp,-16
20402a74:	00112623          	sw	ra,12(sp)
20402a78:	00812423          	sw	s0,8(sp)
20402a7c:	20408537          	lui	a0,0x20408
20402a80:	f9450513          	addi	a0,a0,-108 # 20407f94 <__device_dts_ord_33>
20402a84:	29d010ef          	jal	ra,20404520 <z_device_ready>
20402a88:	02051863          	bnez	a0,20402ab8 <artyA7_pinmux_init+0x48>
	ARG_UNUSED(dev);

	const struct device *p = DEVICE_DT_GET(DT_NODELABEL(pinctrl));

	__ASSERT_NO_MSG(device_is_ready(p));
20402a8c:	20409437          	lui	s0,0x20409
20402a90:	204095b7          	lui	a1,0x20409
20402a94:	20408537          	lui	a0,0x20408
20402a98:	8d058593          	addi	a1,a1,-1840 # 204088d0 <pinmux_sifive_driver_api+0x40>
20402a9c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20402aa0:	01100693          	li	a3,17
20402aa4:	8a040613          	addi	a2,s0,-1888 # 204088a0 <pinmux_sifive_driver_api+0x10>
20402aa8:	d80fe0ef          	jal	ra,20401028 <printk>
20402aac:	01100593          	li	a1,17
20402ab0:	8a040513          	addi	a0,s0,-1888
20402ab4:	cb9ff0ef          	jal	ra,2040276c <assert_post_action>

	/* UART0 RX */
	pinmux_pin_set(p, 16, SIFIVE_PINMUX_IOF0);
20402ab8:	01000513          	li	a0,16
20402abc:	f95ff0ef          	jal	ra,20402a50 <pinmux_pin_set.constprop.0.isra.0>

	/* UART0 TX */
	pinmux_pin_set(p, 17, SIFIVE_PINMUX_IOF0);
20402ac0:	01100513          	li	a0,17
20402ac4:	f8dff0ef          	jal	ra,20402a50 <pinmux_pin_set.constprop.0.isra.0>

	/* SPI1 */
	pinmux_pin_set(p, 2, SIFIVE_PINMUX_IOF0);  /* CS0 */
20402ac8:	00200513          	li	a0,2
20402acc:	f85ff0ef          	jal	ra,20402a50 <pinmux_pin_set.constprop.0.isra.0>
	pinmux_pin_set(p, 3, SIFIVE_PINMUX_IOF0);  /* MOSI */
20402ad0:	00300513          	li	a0,3
20402ad4:	f7dff0ef          	jal	ra,20402a50 <pinmux_pin_set.constprop.0.isra.0>
	pinmux_pin_set(p, 4, SIFIVE_PINMUX_IOF0);  /* MISO */
20402ad8:	00400513          	li	a0,4
20402adc:	f75ff0ef          	jal	ra,20402a50 <pinmux_pin_set.constprop.0.isra.0>
	pinmux_pin_set(p, 5, SIFIVE_PINMUX_IOF0);  /* SCK */
20402ae0:	00500513          	li	a0,5
20402ae4:	f6dff0ef          	jal	ra,20402a50 <pinmux_pin_set.constprop.0.isra.0>
	pinmux_pin_set(p, 9, SIFIVE_PINMUX_IOF0);  /* CS2 */
20402ae8:	00900513          	li	a0,9
20402aec:	f65ff0ef          	jal	ra,20402a50 <pinmux_pin_set.constprop.0.isra.0>
	pinmux_pin_set(p, 10, SIFIVE_PINMUX_IOF0); /* CS3 */
20402af0:	00a00513          	li	a0,10
20402af4:	f5dff0ef          	jal	ra,20402a50 <pinmux_pin_set.constprop.0.isra.0>
	pinmux_pin_set(p, 13, SIFIVE_PINMUX_IOF1); /* PWM2_3 */

#endif /* CONFIG_PWM */

	return 0;
}
20402af8:	00c12083          	lw	ra,12(sp)
20402afc:	00812403          	lw	s0,8(sp)
20402b00:	00000513          	li	a0,0
20402b04:	01010113          	addi	sp,sp,16
20402b08:	00008067          	ret

20402b0c <plic_init>:
 *
 * @brief Initialize the Platform Level Interrupt Controller
 * @return N/A
 */
static int plic_init(const struct device *dev)
{
20402b0c:	ff010113          	addi	sp,sp,-16
	    (volatile struct plic_regs_t *)PLIC_REG;
	int i;

	/* Ensure that all interrupts are disabled initially */
	for (i = 0; i < PLIC_EN_SIZE; i++) {
		*en = 0U;
20402b10:	0c0027b7          	lui	a5,0xc002
{
20402b14:	00112623          	sw	ra,12(sp)
		*en = 0U;
20402b18:	0007a023          	sw	zero,0(a5) # c002000 <__rom_region_size+0xbff8d44>
20402b1c:	0007a223          	sw	zero,4(a5)
	volatile uint32_t *prio = (volatile uint32_t *)PLIC_PRIO;
20402b20:	0c0007b7          	lui	a5,0xc000
		en++;
	}

	/* Set priority of each interrupt line to 0 initially */
	for (i = 0; i < PLIC_IRQS; i++) {
20402b24:	0d078713          	addi	a4,a5,208 # c0000d0 <__rom_region_size+0xbff6e14>
		*prio = 0U;
20402b28:	0007a023          	sw	zero,0(a5)
		prio++;
20402b2c:	00478793          	addi	a5,a5,4
	for (i = 0; i < PLIC_IRQS; i++) {
20402b30:	fee79ce3          	bne	a5,a4,20402b28 <plic_init+0x1c>
	}

	/* Set threshold priority to 0 */
	regs->threshold_prio = 0U;
20402b34:	0c2007b7          	lui	a5,0xc200
20402b38:	0007a023          	sw	zero,0(a5) # c200000 <__rom_region_size+0xc1f6d44>

	/* Setup IRQ handler for PLIC driver */
	IRQ_CONNECT(RISCV_MACHINE_EXT_IRQ,
20402b3c:	00000593          	li	a1,0
20402b40:	00b00513          	li	a0,11
20402b44:	cb5ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
		    plic_irq_handler,
		    NULL,
		    0);

	/* Enable IRQ for PLIC driver */
	irq_enable(RISCV_MACHINE_EXT_IRQ);
20402b48:	00b00513          	li	a0,11
20402b4c:	c65ff0ef          	jal	ra,204027b0 <arch_irq_enable>

	return 0;
}
20402b50:	00c12083          	lw	ra,12(sp)
20402b54:	00000513          	li	a0,0
20402b58:	01010113          	addi	sp,sp,16
20402b5c:	00008067          	ret

20402b60 <plic_irq_handler>:
{
20402b60:	ff010113          	addi	sp,sp,-16
	irq = regs->claim_complete;
20402b64:	0c2007b7          	lui	a5,0xc200
{
20402b68:	00812423          	sw	s0,8(sp)
	irq = regs->claim_complete;
20402b6c:	0047a403          	lw	s0,4(a5) # c200004 <__rom_region_size+0xc1f6d48>
	save_irq = irq;
20402b70:	800007b7          	lui	a5,0x80000
{
20402b74:	00912223          	sw	s1,4(sp)
20402b78:	00112623          	sw	ra,12(sp)
	save_irq = irq;
20402b7c:	0087a823          	sw	s0,16(a5) # 80000010 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000011>
	if (irq == 0U || irq >= PLIC_IRQS)
20402b80:	fff40693          	addi	a3,s0,-1
20402b84:	03200713          	li	a4,50
20402b88:	01078493          	addi	s1,a5,16
20402b8c:	00d77663          	bgeu	a4,a3,20402b98 <plic_irq_handler+0x38>
		z_irq_spurious(NULL);
20402b90:	00000513          	li	a0,0
20402b94:	d8dff0ef          	jal	ra,20402920 <z_irq_spurious>
	irq += CONFIG_2ND_LVL_ISR_TBL_OFFSET;
20402b98:	00c40413          	addi	s0,s0,12
	ite->isr(ite->arg);
20402b9c:	204087b7          	lui	a5,0x20408
20402ba0:	00c78793          	addi	a5,a5,12 # 2040800c <_sw_isr_table>
20402ba4:	00341413          	slli	s0,s0,0x3
20402ba8:	00878433          	add	s0,a5,s0
20402bac:	00442783          	lw	a5,4(s0)
20402bb0:	00042503          	lw	a0,0(s0)
20402bb4:	000780e7          	jalr	a5
	regs->claim_complete = save_irq;
20402bb8:	0004a703          	lw	a4,0(s1)
}
20402bbc:	00c12083          	lw	ra,12(sp)
20402bc0:	00812403          	lw	s0,8(sp)
	regs->claim_complete = save_irq;
20402bc4:	0c2007b7          	lui	a5,0xc200
20402bc8:	00e7a223          	sw	a4,4(a5) # c200004 <__rom_region_size+0xc1f6d48>
}
20402bcc:	00412483          	lw	s1,4(sp)
20402bd0:	01010113          	addi	sp,sp,16
20402bd4:	00008067          	ret

20402bd8 <riscv_plic_irq_enable>:
20402bd8:	00800793          	li	a5,8
20402bdc:	3007b7f3          	csrrc	a5,mstatus,a5
	en += (irq >> 5);
20402be0:	00555693          	srli	a3,a0,0x5
20402be4:	00269713          	slli	a4,a3,0x2
20402be8:	0c0026b7          	lui	a3,0xc002
20402bec:	00e686b3          	add	a3,a3,a4
	*en |= (1 << (irq & 31));
20402bf0:	0006a603          	lw	a2,0(a3) # c002000 <__rom_region_size+0xbff8d44>
20402bf4:	00100713          	li	a4,1
20402bf8:	00a71533          	sll	a0,a4,a0
20402bfc:	00c56533          	or	a0,a0,a2
20402c00:	00a6a023          	sw	a0,0(a3)
	key = (mstatus & MSTATUS_IEN);
20402c04:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20402c08:	3007a7f3          	csrrs	a5,mstatus,a5
}
20402c0c:	00008067          	ret

20402c10 <riscv_plic_irq_disable>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20402c10:	00800713          	li	a4,8
20402c14:	30073773          	csrrc	a4,mstatus,a4
	en += (irq >> 5);
20402c18:	00555693          	srli	a3,a0,0x5
20402c1c:	00269793          	slli	a5,a3,0x2
20402c20:	0c0026b7          	lui	a3,0xc002
20402c24:	00f686b3          	add	a3,a3,a5
	*en &= ~(1 << (irq & 31));
20402c28:	0006a603          	lw	a2,0(a3) # c002000 <__rom_region_size+0xbff8d44>
20402c2c:	00100793          	li	a5,1
20402c30:	00a797b3          	sll	a5,a5,a0
20402c34:	fff7c793          	not	a5,a5
20402c38:	00c7f7b3          	and	a5,a5,a2
20402c3c:	00f6a023          	sw	a5,0(a3)
	key = (mstatus & MSTATUS_IEN);
20402c40:	00877793          	andi	a5,a4,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20402c44:	3007a7f3          	csrrs	a5,mstatus,a5
}
20402c48:	00008067          	ret

20402c4c <riscv_plic_set_priority>:
	if (priority > PLIC_MAX_PRIO)
20402c4c:	00700793          	li	a5,7
20402c50:	00b7f463          	bgeu	a5,a1,20402c58 <riscv_plic_set_priority+0xc>
20402c54:	00700593          	li	a1,7
	prio += irq;
20402c58:	00251513          	slli	a0,a0,0x2
20402c5c:	0c0007b7          	lui	a5,0xc000
20402c60:	00a78533          	add	a0,a5,a0
	*prio = priority;
20402c64:	00b52023          	sw	a1,0(a0)
}
20402c68:	00008067          	ret

20402c6c <riscv_plic_get_irq>:
}
20402c6c:	800007b7          	lui	a5,0x80000
20402c70:	0107a503          	lw	a0,16(a5) # 80000010 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000011>
20402c74:	00008067          	ret

20402c78 <uart_console_init>:
{

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
20402c78:	20408537          	lui	a0,0x20408
{
20402c7c:	ff010113          	addi	sp,sp,-16
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
20402c80:	fc450713          	addi	a4,a0,-60 # 20407fc4 <__device_dts_ord_27>
20402c84:	800007b7          	lui	a5,0x80000
{
20402c88:	00112623          	sw	ra,12(sp)
20402c8c:	00812423          	sw	s0,8(sp)
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
20402c90:	00e7aa23          	sw	a4,20(a5) # 80000014 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000015>
20402c94:	fc450513          	addi	a0,a0,-60
20402c98:	089010ef          	jal	ra,20404520 <z_device_ready>
20402c9c:	fed00793          	li	a5,-19
20402ca0:	00050e63          	beqz	a0,20402cbc <uart_console_init+0x44>
	__stdout_hook_install(console_out);
20402ca4:	20403437          	lui	s0,0x20403
20402ca8:	cd040513          	addi	a0,s0,-816 # 20402cd0 <console_out>
20402cac:	d9dff0ef          	jal	ra,20402a48 <__stdout_hook_install>
	__printk_hook_install(console_out);
20402cb0:	cd040513          	addi	a0,s0,-816
20402cb4:	b38fe0ef          	jal	ra,20400fec <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
20402cb8:	00000793          	li	a5,0
}
20402cbc:	00c12083          	lw	ra,12(sp)
20402cc0:	00812403          	lw	s0,8(sp)
20402cc4:	00078513          	mv	a0,a5
20402cc8:	01010113          	addi	sp,sp,16
20402ccc:	00008067          	ret

20402cd0 <console_out>:
{
20402cd0:	ff010113          	addi	sp,sp,-16
20402cd4:	00812423          	sw	s0,8(sp)
20402cd8:	00912223          	sw	s1,4(sp)
20402cdc:	00112623          	sw	ra,12(sp)
20402ce0:	800004b7          	lui	s1,0x80000
	if ('\n' == c) {
20402ce4:	00a00793          	li	a5,10
{
20402ce8:	00050413          	mv	s0,a0
20402cec:	01448493          	addi	s1,s1,20 # 80000014 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000015>
	if ('\n' == c) {
20402cf0:	00f51c63          	bne	a0,a5,20402d08 <console_out+0x38>
		uart_poll_out(uart_console_dev, '\r');
20402cf4:	0004a503          	lw	a0,0(s1)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
20402cf8:	00852783          	lw	a5,8(a0)
20402cfc:	00d00593          	li	a1,13
20402d00:	0047a783          	lw	a5,4(a5)
20402d04:	000780e7          	jalr	a5
	uart_poll_out(uart_console_dev, c);
20402d08:	0004a503          	lw	a0,0(s1)
20402d0c:	00852783          	lw	a5,8(a0)
20402d10:	0ff47593          	andi	a1,s0,255
20402d14:	0047a783          	lw	a5,4(a5)
20402d18:	000780e7          	jalr	a5
}
20402d1c:	00c12083          	lw	ra,12(sp)
20402d20:	00040513          	mv	a0,s0
20402d24:	00812403          	lw	s0,8(sp)
20402d28:	00412483          	lw	s1,4(sp)
20402d2c:	01010113          	addi	sp,sp,16
20402d30:	00008067          	ret

20402d34 <gpio_sifive_config>:
 */
static int gpio_sifive_config(const struct device *dev,
			      gpio_pin_t pin,
			      gpio_flags_t flags)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402d34:	00452783          	lw	a5,4(a0)
20402d38:	0047a703          	lw	a4,4(a5)

	if (pin >= SIFIVE_PINMUX_PINS) {
20402d3c:	01f00793          	li	a5,31
20402d40:	0ab7ec63          	bltu	a5,a1,20402df8 <gpio_sifive_config+0xc4>
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
		return -ENOTSUP;
	}

	/* We only support pull-ups, not pull-downs */
	if ((flags & GPIO_PULL_DOWN) != 0) {
20402d44:	02267793          	andi	a5,a2,34
		return -ENOTSUP;
20402d48:	f7a00513          	li	a0,-134
	if ((flags & GPIO_PULL_DOWN) != 0) {
20402d4c:	0a079863          	bnez	a5,20402dfc <gpio_sifive_config+0xc8>
	}

	/* Set pull-up if requested */
	WRITE_BIT(gpio->pue, pin, flags & GPIO_PULL_UP);
20402d50:	00100793          	li	a5,1
20402d54:	00b795b3          	sll	a1,a5,a1
20402d58:	01067793          	andi	a5,a2,16
20402d5c:	06078863          	beqz	a5,20402dcc <gpio_sifive_config+0x98>
20402d60:	01072783          	lw	a5,16(a4)
20402d64:	00b7e7b3          	or	a5,a5,a1
20402d68:	00f72823          	sw	a5,16(a4)

	/* Set the initial output value before enabling output to avoid
	 * glitches
	 */
	if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
20402d6c:	00b65793          	srli	a5,a2,0xb
20402d70:	0017f793          	andi	a5,a5,1
20402d74:	00078863          	beqz	a5,20402d84 <gpio_sifive_config+0x50>
		gpio->out_val |= BIT(pin);
20402d78:	00c72783          	lw	a5,12(a4)
20402d7c:	00b7e7b3          	or	a5,a5,a1
20402d80:	00f72623          	sw	a5,12(a4)
	}
	if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
20402d84:	40067793          	andi	a5,a2,1024
20402d88:	00078a63          	beqz	a5,20402d9c <gpio_sifive_config+0x68>
		gpio->out_val &= ~BIT(pin);
20402d8c:	00c72683          	lw	a3,12(a4)
20402d90:	fff5c793          	not	a5,a1
20402d94:	00d7f7b3          	and	a5,a5,a3
20402d98:	00f72623          	sw	a5,12(a4)
	}

	/* Enable input/output */
	WRITE_BIT(gpio->out_en, pin, flags & GPIO_OUTPUT);
20402d9c:	20067793          	andi	a5,a2,512
20402da0:	02078e63          	beqz	a5,20402ddc <gpio_sifive_config+0xa8>
20402da4:	00872783          	lw	a5,8(a4)
20402da8:	00b7e7b3          	or	a5,a5,a1
20402dac:	00f72423          	sw	a5,8(a4)
	WRITE_BIT(gpio->in_en, pin, flags & GPIO_INPUT);
20402db0:	00472783          	lw	a5,4(a4)
20402db4:	10067613          	andi	a2,a2,256
20402db8:	02060a63          	beqz	a2,20402dec <gpio_sifive_config+0xb8>
20402dbc:	00b7e5b3          	or	a1,a5,a1
20402dc0:	00b72223          	sw	a1,4(a4)

	return 0;
20402dc4:	00000513          	li	a0,0
20402dc8:	00008067          	ret
	WRITE_BIT(gpio->pue, pin, flags & GPIO_PULL_UP);
20402dcc:	01072683          	lw	a3,16(a4)
20402dd0:	fff5c793          	not	a5,a1
20402dd4:	00d7f7b3          	and	a5,a5,a3
20402dd8:	f91ff06f          	j	20402d68 <gpio_sifive_config+0x34>
	WRITE_BIT(gpio->out_en, pin, flags & GPIO_OUTPUT);
20402ddc:	00872683          	lw	a3,8(a4)
20402de0:	fff5c793          	not	a5,a1
20402de4:	00d7f7b3          	and	a5,a5,a3
20402de8:	fc5ff06f          	j	20402dac <gpio_sifive_config+0x78>
	WRITE_BIT(gpio->in_en, pin, flags & GPIO_INPUT);
20402dec:	fff5c593          	not	a1,a1
20402df0:	00f5f5b3          	and	a1,a1,a5
20402df4:	fcdff06f          	j	20402dc0 <gpio_sifive_config+0x8c>
		return -EINVAL;
20402df8:	fea00513          	li	a0,-22
}
20402dfc:	00008067          	ret

20402e00 <gpio_sifive_port_get_raw>:

static int gpio_sifive_port_get_raw(const struct device *dev,
				    gpio_port_value_t *value)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e00:	00452783          	lw	a5,4(a0)

	*value = gpio->in_val;

	return 0;
}
20402e04:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e08:	0047a783          	lw	a5,4(a5)
	*value = gpio->in_val;
20402e0c:	0007a783          	lw	a5,0(a5)
20402e10:	00f5a023          	sw	a5,0(a1)
}
20402e14:	00008067          	ret

20402e18 <gpio_sifive_port_set_masked_raw>:

static int gpio_sifive_port_set_masked_raw(const struct device *dev,
					   gpio_port_pins_t mask,
					   gpio_port_value_t value)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e18:	00452783          	lw	a5,4(a0)

	gpio->out_val = (gpio->out_val & ~mask) | (value & mask);

	return 0;
}
20402e1c:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e20:	0047a783          	lw	a5,4(a5)
	gpio->out_val = (gpio->out_val & ~mask) | (value & mask);
20402e24:	00c7a703          	lw	a4,12(a5)
20402e28:	00c74633          	xor	a2,a4,a2
20402e2c:	00b67633          	and	a2,a2,a1
20402e30:	00e64633          	xor	a2,a2,a4
20402e34:	00c7a623          	sw	a2,12(a5)
}
20402e38:	00008067          	ret

20402e3c <gpio_sifive_port_set_bits_raw>:

static int gpio_sifive_port_set_bits_raw(const struct device *dev,
					 gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e3c:	00452783          	lw	a5,4(a0)

	gpio->out_val |= mask;

	return 0;
}
20402e40:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e44:	0047a703          	lw	a4,4(a5)
	gpio->out_val |= mask;
20402e48:	00c72783          	lw	a5,12(a4)
20402e4c:	00b7e7b3          	or	a5,a5,a1
20402e50:	00f72623          	sw	a5,12(a4)
}
20402e54:	00008067          	ret

20402e58 <gpio_sifive_port_clear_bits_raw>:

static int gpio_sifive_port_clear_bits_raw(const struct device *dev,
					   gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e58:	00452783          	lw	a5,4(a0)

	gpio->out_val &= ~mask;
20402e5c:	fff5c593          	not	a1,a1

	return 0;
}
20402e60:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e64:	0047a783          	lw	a5,4(a5)
	gpio->out_val &= ~mask;
20402e68:	00c7a703          	lw	a4,12(a5)
20402e6c:	00e5f5b3          	and	a1,a1,a4
20402e70:	00b7a623          	sw	a1,12(a5)
}
20402e74:	00008067          	ret

20402e78 <gpio_sifive_port_toggle_bits>:

static int gpio_sifive_port_toggle_bits(const struct device *dev,
					gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e78:	00452783          	lw	a5,4(a0)

	gpio->out_val ^= mask;

	return 0;
}
20402e7c:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e80:	0047a703          	lw	a4,4(a5)
	gpio->out_val ^= mask;
20402e84:	00c72783          	lw	a5,12(a4)
20402e88:	00b7c7b3          	xor	a5,a5,a1
20402e8c:	00f72623          	sw	a5,12(a4)
}
20402e90:	00008067          	ret

20402e94 <gpio_sifive_init>:
 *
 * @return 0
 */
static int gpio_sifive_init(const struct device *dev)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402e94:	00452703          	lw	a4,4(a0)
{
20402e98:	ff010113          	addi	sp,sp,-16
20402e9c:	00112623          	sw	ra,12(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20402ea0:	00472783          	lw	a5,4(a4)
	const struct gpio_sifive_config *cfg = DEV_GPIO_CFG(dev);

	/* Ensure that all gpio registers are reset to 0 initially */
	gpio->in_en   = 0U;
20402ea4:	0007a223          	sw	zero,4(a5)
	gpio->out_en  = 0U;
20402ea8:	0007a423          	sw	zero,8(a5)
	gpio->pue     = 0U;
20402eac:	0007a823          	sw	zero,16(a5)
	gpio->rise_ie = 0U;
20402eb0:	0007ac23          	sw	zero,24(a5)
	gpio->fall_ie = 0U;
20402eb4:	0207a023          	sw	zero,32(a5)
	gpio->high_ie = 0U;
20402eb8:	0207a423          	sw	zero,40(a5)
	gpio->low_ie  = 0U;
20402ebc:	0207a823          	sw	zero,48(a5)
	gpio->invert  = 0U;
20402ec0:	0407a023          	sw	zero,64(a5)

	/* Setup IRQ handler for each gpio pin */
	cfg->gpio_cfg_func();
20402ec4:	00c72783          	lw	a5,12(a4)
20402ec8:	000780e7          	jalr	a5

	return 0;
}
20402ecc:	00c12083          	lw	ra,12(sp)
20402ed0:	00000513          	li	a0,0
20402ed4:	01010113          	addi	sp,sp,16
20402ed8:	00008067          	ret

20402edc <gpio_sifive_manage_callback>:
{
20402edc:	fe010113          	addi	sp,sp,-32
20402ee0:	00812c23          	sw	s0,24(sp)
20402ee4:	00912a23          	sw	s1,20(sp)
20402ee8:	01212823          	sw	s2,16(sp)
20402eec:	00112e23          	sw	ra,28(sp)
20402ef0:	01312623          	sw	s3,12(sp)
	struct gpio_sifive_data *data = DEV_GPIO_DATA(dev);
20402ef4:	01052483          	lw	s1,16(a0)
{
20402ef8:	00058413          	mv	s0,a1
20402efc:	00060913          	mv	s2,a2
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
20402f00:	02059e63          	bnez	a1,20402f3c <gpio_sifive_manage_callback+0x60>
20402f04:	204099b7          	lui	s3,0x20409
20402f08:	204095b7          	lui	a1,0x20409
20402f0c:	20408537          	lui	a0,0x20408
20402f10:	91458593          	addi	a1,a1,-1772 # 20408914 <pinmux_sifive_driver_api+0x84>
20402f14:	02400693          	li	a3,36
20402f18:	8e498613          	addi	a2,s3,-1820 # 204088e4 <pinmux_sifive_driver_api+0x54>
20402f1c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20402f20:	908fe0ef          	jal	ra,20401028 <printk>
20402f24:	20409537          	lui	a0,0x20409
20402f28:	92050513          	addi	a0,a0,-1760 # 20408920 <pinmux_sifive_driver_api+0x90>
20402f2c:	8fcfe0ef          	jal	ra,20401028 <printk>
20402f30:	02400593          	li	a1,36
20402f34:	8e498513          	addi	a0,s3,-1820
20402f38:	835ff0ef          	jal	ra,2040276c <assert_post_action>
	__ASSERT(callback->handler, "No callback handler!");
20402f3c:	00442783          	lw	a5,4(s0)
20402f40:	02079e63          	bnez	a5,20402f7c <gpio_sifive_manage_callback+0xa0>
20402f44:	204099b7          	lui	s3,0x20409
20402f48:	204095b7          	lui	a1,0x20409
20402f4c:	20408537          	lui	a0,0x20408
20402f50:	93058593          	addi	a1,a1,-1744 # 20408930 <pinmux_sifive_driver_api+0xa0>
20402f54:	02500693          	li	a3,37
20402f58:	8e498613          	addi	a2,s3,-1820 # 204088e4 <pinmux_sifive_driver_api+0x54>
20402f5c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20402f60:	8c8fe0ef          	jal	ra,20401028 <printk>
20402f64:	20409537          	lui	a0,0x20409
20402f68:	94450513          	addi	a0,a0,-1724 # 20408944 <pinmux_sifive_driver_api+0xb4>
20402f6c:	8bcfe0ef          	jal	ra,20401028 <printk>
20402f70:	02500593          	li	a1,37
20402f74:	8e498513          	addi	a0,s3,-1820
20402f78:	ff4ff0ef          	jal	ra,2040276c <assert_post_action>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
20402f7c:	0044a783          	lw	a5,4(s1)
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
20402f80:	00000713          	li	a4,0

	if (!sys_slist_is_empty(callbacks)) {
20402f84:	02079663          	bnez	a5,20402fb0 <gpio_sifive_manage_callback+0xd4>
				return -EINVAL;
			}
		}
	}

	if (set) {
20402f88:	06091863          	bnez	s2,20402ff8 <gpio_sifive_manage_callback+0x11c>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
20402f8c:	00000513          	li	a0,0
}
20402f90:	01c12083          	lw	ra,28(sp)
20402f94:	01812403          	lw	s0,24(sp)
20402f98:	01412483          	lw	s1,20(sp)
20402f9c:	01012903          	lw	s2,16(sp)
20402fa0:	00c12983          	lw	s3,12(sp)
20402fa4:	02010113          	addi	sp,sp,32
20402fa8:	00008067          	ret
20402fac:	00068793          	mv	a5,a3
20402fb0:	02f41a63          	bne	s0,a5,20402fe4 <gpio_sifive_manage_callback+0x108>
	return node->next;
20402fb4:	00042783          	lw	a5,0(s0)
	return list->tail;
20402fb8:	0084a683          	lw	a3,8(s1)
Z_GENLIST_REMOVE(slist, snode)
20402fbc:	00071c63          	bnez	a4,20402fd4 <gpio_sifive_manage_callback+0xf8>
	list->head = node;
20402fc0:	00f4a223          	sw	a5,4(s1)
Z_GENLIST_REMOVE(slist, snode)
20402fc4:	00869463          	bne	a3,s0,20402fcc <gpio_sifive_manage_callback+0xf0>
	list->tail = node;
20402fc8:	00f4a423          	sw	a5,8(s1)
	parent->next = child;
20402fcc:	00042023          	sw	zero,0(s0)
20402fd0:	fb9ff06f          	j	20402f88 <gpio_sifive_manage_callback+0xac>
20402fd4:	00f72023          	sw	a5,0(a4)
Z_GENLIST_REMOVE(slist, snode)
20402fd8:	fe869ae3          	bne	a3,s0,20402fcc <gpio_sifive_manage_callback+0xf0>
	list->tail = node;
20402fdc:	00e4a423          	sw	a4,8(s1)
}
20402fe0:	fedff06f          	j	20402fcc <gpio_sifive_manage_callback+0xf0>
	return node->next;
20402fe4:	0007a683          	lw	a3,0(a5)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
20402fe8:	00078713          	mv	a4,a5
20402fec:	fc0690e3          	bnez	a3,20402fac <gpio_sifive_manage_callback+0xd0>
				return -EINVAL;
20402ff0:	fea00513          	li	a0,-22
			if (!set) {
20402ff4:	f8090ee3          	beqz	s2,20402f90 <gpio_sifive_manage_callback+0xb4>
	parent->next = child;
20402ff8:	0044a783          	lw	a5,4(s1)
20402ffc:	00f42023          	sw	a5,0(s0)
Z_GENLIST_PREPEND(slist, snode)
20403000:	0084a783          	lw	a5,8(s1)
	list->head = node;
20403004:	0084a223          	sw	s0,4(s1)
Z_GENLIST_PREPEND(slist, snode)
20403008:	f80792e3          	bnez	a5,20402f8c <gpio_sifive_manage_callback+0xb0>
	list->tail = node;
2040300c:	0084a423          	sw	s0,8(s1)
20403010:	f7dff06f          	j	20402f8c <gpio_sifive_manage_callback+0xb0>

20403014 <gpio_sifive_cfg_0>:
		gpio_sifive_irq_handler,			\
		DEVICE_DT_INST_GET(0),				\
		0);

static void gpio_sifive_cfg_0(void)
{
20403014:	ff010113          	addi	sp,sp,-16
20403018:	00812423          	sw	s0,8(sp)
#if DT_INST_IRQ_HAS_IDX(0, 0)
	IRQ_INIT(0);
2040301c:	00001437          	lui	s0,0x1
20403020:	90b40513          	addi	a0,s0,-1781 # 90b <CONFIG_ISR_STACK_SIZE+0x10b>
20403024:	00100593          	li	a1,1
{
20403028:	00112623          	sw	ra,12(sp)
	IRQ_INIT(0);
2040302c:	fccff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 1)
	IRQ_INIT(1);
20403030:	a0b40513          	addi	a0,s0,-1525
20403034:	00100593          	li	a1,1
20403038:	fc0ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 2)
	IRQ_INIT(2);
2040303c:	b0b40513          	addi	a0,s0,-1269
20403040:	00100593          	li	a1,1
20403044:	fb4ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 3)
	IRQ_INIT(3);
20403048:	c0b40513          	addi	a0,s0,-1013
2040304c:	00100593          	li	a1,1
20403050:	fa8ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 4)
	IRQ_INIT(4);
20403054:	d0b40513          	addi	a0,s0,-757
20403058:	00100593          	li	a1,1
2040305c:	f9cff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 5)
	IRQ_INIT(5);
20403060:	e0b40513          	addi	a0,s0,-501
20403064:	00100593          	li	a1,1
20403068:	f90ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 6)
	IRQ_INIT(6);
2040306c:	f0b40513          	addi	a0,s0,-245
20403070:	00100593          	li	a1,1
20403074:	f84ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 7)
	IRQ_INIT(7);
20403078:	00b40513          	addi	a0,s0,11
2040307c:	00100593          	li	a1,1
20403080:	f78ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 8)
	IRQ_INIT(8);
20403084:	10b40513          	addi	a0,s0,267
20403088:	00100593          	li	a1,1
2040308c:	f6cff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 9)
	IRQ_INIT(9);
20403090:	20b40513          	addi	a0,s0,523
20403094:	00100593          	li	a1,1
20403098:	f60ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 10)
	IRQ_INIT(10);
2040309c:	30b40513          	addi	a0,s0,779
204030a0:	00100593          	li	a1,1
204030a4:	f54ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 11)
	IRQ_INIT(11);
204030a8:	40b40513          	addi	a0,s0,1035
204030ac:	00100593          	li	a1,1
204030b0:	f48ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 12)
	IRQ_INIT(12);
204030b4:	50b40513          	addi	a0,s0,1291
204030b8:	00100593          	li	a1,1
204030bc:	f3cff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 13)
	IRQ_INIT(13);
204030c0:	60b40513          	addi	a0,s0,1547
204030c4:	00100593          	li	a1,1
204030c8:	f30ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 14)
	IRQ_INIT(14);
204030cc:	70b40513          	addi	a0,s0,1803
204030d0:	00100593          	li	a1,1
#endif
#if DT_INST_IRQ_HAS_IDX(0, 15)
	IRQ_INIT(15);
204030d4:	00002437          	lui	s0,0x2
	IRQ_INIT(14);
204030d8:	f20ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
	IRQ_INIT(15);
204030dc:	80b40513          	addi	a0,s0,-2037 # 180b <CONFIG_ISR_STACK_SIZE+0x100b>
204030e0:	00100593          	li	a1,1
204030e4:	f14ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 16)
	IRQ_INIT(16);
204030e8:	90b40513          	addi	a0,s0,-1781
204030ec:	00100593          	li	a1,1
204030f0:	f08ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 17)
	IRQ_INIT(17);
204030f4:	a0b40513          	addi	a0,s0,-1525
204030f8:	00100593          	li	a1,1
204030fc:	efcff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 18)
	IRQ_INIT(18);
20403100:	b0b40513          	addi	a0,s0,-1269
20403104:	00100593          	li	a1,1
20403108:	ef0ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 19)
	IRQ_INIT(19);
2040310c:	c0b40513          	addi	a0,s0,-1013
20403110:	00100593          	li	a1,1
20403114:	ee4ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 20)
	IRQ_INIT(20);
20403118:	d0b40513          	addi	a0,s0,-757
2040311c:	00100593          	li	a1,1
20403120:	ed8ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 21)
	IRQ_INIT(21);
20403124:	e0b40513          	addi	a0,s0,-501
20403128:	00100593          	li	a1,1
2040312c:	eccff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 22)
	IRQ_INIT(22);
20403130:	f0b40513          	addi	a0,s0,-245
20403134:	00100593          	li	a1,1
20403138:	ec0ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 23)
	IRQ_INIT(23);
2040313c:	00b40513          	addi	a0,s0,11
20403140:	00100593          	li	a1,1
20403144:	eb4ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 24)
	IRQ_INIT(24);
20403148:	10b40513          	addi	a0,s0,267
2040314c:	00100593          	li	a1,1
20403150:	ea8ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 25)
	IRQ_INIT(25);
20403154:	20b40513          	addi	a0,s0,523
20403158:	00100593          	li	a1,1
2040315c:	e9cff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 26)
	IRQ_INIT(26);
20403160:	30b40513          	addi	a0,s0,779
20403164:	00100593          	li	a1,1
20403168:	e90ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 27)
	IRQ_INIT(27);
2040316c:	40b40513          	addi	a0,s0,1035
20403170:	00100593          	li	a1,1
20403174:	e84ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 28)
	IRQ_INIT(28);
20403178:	50b40513          	addi	a0,s0,1291
2040317c:	00100593          	li	a1,1
20403180:	e78ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 29)
	IRQ_INIT(29);
20403184:	60b40513          	addi	a0,s0,1547
20403188:	00100593          	li	a1,1
2040318c:	e6cff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 30)
	IRQ_INIT(30);
20403190:	70b40513          	addi	a0,s0,1803
20403194:	00100593          	li	a1,1
20403198:	e60ff0ef          	jal	ra,204027f8 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 31)
	IRQ_INIT(31);
#endif
}
2040319c:	00812403          	lw	s0,8(sp)
204031a0:	00c12083          	lw	ra,12(sp)
	IRQ_INIT(31);
204031a4:	00003537          	lui	a0,0x3
204031a8:	00100593          	li	a1,1
204031ac:	80b50513          	addi	a0,a0,-2037 # 280b <__kernel_ram_size+0x87b>
}
204031b0:	01010113          	addi	sp,sp,16
	IRQ_INIT(31);
204031b4:	e44ff06f          	j	204027f8 <arch_irq_priority_set>

204031b8 <gpio_sifive_irq_handler>:
{
204031b8:	fd010113          	addi	sp,sp,-48
204031bc:	02912223          	sw	s1,36(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
204031c0:	00452483          	lw	s1,4(a0)
{
204031c4:	02812423          	sw	s0,40(sp)
204031c8:	03212023          	sw	s2,32(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
204031cc:	0044a403          	lw	s0,4(s1)
{
204031d0:	01312e23          	sw	s3,28(sp)
204031d4:	02112623          	sw	ra,44(sp)
	struct gpio_sifive_data *data = DEV_GPIO_DATA(dev);
204031d8:	01052983          	lw	s3,16(a0)
{
204031dc:	01412c23          	sw	s4,24(sp)
204031e0:	01512a23          	sw	s5,20(sp)
204031e4:	01612823          	sw	s6,16(sp)
204031e8:	01712623          	sw	s7,12(sp)
204031ec:	00050913          	mv	s2,a0
	uint8_t pin = 1 + (riscv_plic_get_irq() - (uint8_t)(cfg->gpio_irq_base >> 8));
204031f0:	a7dff0ef          	jal	ra,20402c6c <riscv_plic_get_irq>
204031f4:	0084a483          	lw	s1,8(s1)
204031f8:	0084d493          	srli	s1,s1,0x8
204031fc:	40950533          	sub	a0,a0,s1
20403200:	00150513          	addi	a0,a0,1
	gpio->rise_ip = BIT(pin);
20403204:	00100493          	li	s1,1
20403208:	00a494b3          	sll	s1,s1,a0
2040320c:	00942e23          	sw	s1,28(s0)
	gpio->fall_ip = BIT(pin);
20403210:	02942223          	sw	s1,36(s0)
	gpio->high_ip = BIT(pin);
20403214:	02942623          	sw	s1,44(s0)
	gpio->low_ip = BIT(pin);
20403218:	02942a23          	sw	s1,52(s0)
	gpio_fire_callbacks(&data->cb, dev, BIT(pin));
2040321c:	0049a403          	lw	s0,4(s3)
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
20403220:	06040e63          	beqz	s0,2040329c <gpio_sifive_irq_handler+0xe4>
	return node->next;
20403224:	00042983          	lw	s3,0(s0)
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
20403228:	20409a37          	lui	s4,0x20409
2040322c:	20409ab7          	lui	s5,0x20409
20403230:	20408b37          	lui	s6,0x20408
20403234:	20409bb7          	lui	s7,0x20409
		if (cb->pin_mask & pins) {
20403238:	00842783          	lw	a5,8(s0)
2040323c:	00f4f7b3          	and	a5,s1,a5
20403240:	04078663          	beqz	a5,2040328c <gpio_sifive_irq_handler+0xd4>
			__ASSERT(cb->handler, "No callback handler!");
20403244:	00442783          	lw	a5,4(s0)
20403248:	02079663          	bnez	a5,20403274 <gpio_sifive_irq_handler+0xbc>
2040324c:	95ca8593          	addi	a1,s5,-1700 # 2040895c <pinmux_sifive_driver_api+0xcc>
20403250:	04500693          	li	a3,69
20403254:	8e4a0613          	addi	a2,s4,-1820 # 204088e4 <pinmux_sifive_driver_api+0x54>
20403258:	3ecb0513          	addi	a0,s6,1004 # 204083ec <__clz_tab+0x1a4>
2040325c:	dcdfd0ef          	jal	ra,20401028 <printk>
20403260:	944b8513          	addi	a0,s7,-1724 # 20408944 <pinmux_sifive_driver_api+0xb4>
20403264:	dc5fd0ef          	jal	ra,20401028 <printk>
20403268:	04500593          	li	a1,69
2040326c:	8e4a0513          	addi	a0,s4,-1820
20403270:	cfcff0ef          	jal	ra,2040276c <assert_post_action>
			cb->handler(port, cb, cb->pin_mask & pins);
20403274:	00842603          	lw	a2,8(s0)
20403278:	00442783          	lw	a5,4(s0)
2040327c:	00040593          	mv	a1,s0
20403280:	00c4f633          	and	a2,s1,a2
20403284:	00090513          	mv	a0,s2
20403288:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
2040328c:	00098863          	beqz	s3,2040329c <gpio_sifive_irq_handler+0xe4>
20403290:	00098413          	mv	s0,s3
20403294:	0009a983          	lw	s3,0(s3)
20403298:	fa1ff06f          	j	20403238 <gpio_sifive_irq_handler+0x80>
}
2040329c:	02c12083          	lw	ra,44(sp)
204032a0:	02812403          	lw	s0,40(sp)
204032a4:	02412483          	lw	s1,36(sp)
204032a8:	02012903          	lw	s2,32(sp)
204032ac:	01c12983          	lw	s3,28(sp)
204032b0:	01812a03          	lw	s4,24(sp)
204032b4:	01412a83          	lw	s5,20(sp)
204032b8:	01012b03          	lw	s6,16(sp)
204032bc:	00c12b83          	lw	s7,12(sp)
204032c0:	03010113          	addi	sp,sp,48
204032c4:	00008067          	ret

204032c8 <gpio_sifive_pin_interrupt_configure>:
{
204032c8:	fe010113          	addi	sp,sp,-32
204032cc:	01412423          	sw	s4,8(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
204032d0:	00452a03          	lw	s4,4(a0)
{
204032d4:	00812c23          	sw	s0,24(sp)
204032d8:	01212823          	sw	s2,16(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
204032dc:	004a2403          	lw	s0,4(s4)
	gpio->rise_ie &= ~BIT(pin);
204032e0:	00100913          	li	s2,1
204032e4:	00b91933          	sll	s2,s2,a1
204032e8:	01842703          	lw	a4,24(s0)
204032ec:	fff94793          	not	a5,s2
{
204032f0:	00912a23          	sw	s1,20(sp)
204032f4:	00112e23          	sw	ra,28(sp)
204032f8:	01312623          	sw	s3,12(sp)
	gpio->rise_ie &= ~BIT(pin);
204032fc:	00f77733          	and	a4,a4,a5
20403300:	00e42c23          	sw	a4,24(s0)
	gpio->fall_ie &= ~BIT(pin);
20403304:	02042703          	lw	a4,32(s0)
{
20403308:	00058493          	mv	s1,a1
	gpio->fall_ie &= ~BIT(pin);
2040330c:	00e7f733          	and	a4,a5,a4
20403310:	02e42023          	sw	a4,32(s0)
	gpio->high_ie &= ~BIT(pin);
20403314:	02842703          	lw	a4,40(s0)
20403318:	00e7f733          	and	a4,a5,a4
2040331c:	02e42423          	sw	a4,40(s0)
	gpio->low_ie  &= ~BIT(pin);
20403320:	03042703          	lw	a4,48(s0)
20403324:	00e7f7b3          	and	a5,a5,a4
20403328:	02f42823          	sw	a5,48(s0)
	switch (mode) {
2040332c:	000047b7          	lui	a5,0x4
20403330:	04f60c63          	beq	a2,a5,20403388 <gpio_sifive_pin_interrupt_configure+0xc0>
20403334:	000147b7          	lui	a5,0x14
20403338:	00060993          	mv	s3,a2
2040333c:	0cf60663          	beq	a2,a5,20403408 <gpio_sifive_pin_interrupt_configure+0x140>
20403340:	000027b7          	lui	a5,0x2
20403344:	10f61c63          	bne	a2,a5,2040345c <gpio_sifive_pin_interrupt_configure+0x194>
		irq_disable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
20403348:	008a2783          	lw	a5,8(s4)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
2040334c:	0087d713          	srli	a4,a5,0x8
		pin_irq = base_irq + pin;
20403350:	00f58533          	add	a0,a1,a5
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
20403354:	00070663          	beqz	a4,20403360 <gpio_sifive_pin_interrupt_configure+0x98>
		pin_irq = base_irq + (pin << 8);
20403358:	00859513          	slli	a0,a1,0x8
2040335c:	00f50533          	add	a0,a0,a5
		irq_disable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
20403360:	c74ff0ef          	jal	ra,204027d4 <arch_irq_disable>
	return 0;
20403364:	00000513          	li	a0,0
}
20403368:	01c12083          	lw	ra,28(sp)
2040336c:	01812403          	lw	s0,24(sp)
20403370:	01412483          	lw	s1,20(sp)
20403374:	01012903          	lw	s2,16(sp)
20403378:	00c12983          	lw	s3,12(sp)
2040337c:	00812a03          	lw	s4,8(sp)
20403380:	02010113          	addi	sp,sp,32
20403384:	00008067          	ret
		if (trig == GPIO_INT_TRIG_HIGH) {
20403388:	000407b7          	lui	a5,0x40
2040338c:	02f69a63          	bne	a3,a5,204033c0 <gpio_sifive_pin_interrupt_configure+0xf8>
			gpio->high_ip = BIT(pin);
20403390:	03242623          	sw	s2,44(s0)
			gpio->high_ie |= BIT(pin);
20403394:	02842783          	lw	a5,40(s0)
20403398:	00f96933          	or	s2,s2,a5
2040339c:	03242423          	sw	s2,40(s0)
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
204033a0:	008a2783          	lw	a5,8(s4)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
204033a4:	0087d713          	srli	a4,a5,0x8
		pin_irq = base_irq + pin;
204033a8:	00f48533          	add	a0,s1,a5
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
204033ac:	00070663          	beqz	a4,204033b8 <gpio_sifive_pin_interrupt_configure+0xf0>
		pin_irq = base_irq + (pin << 8);
204033b0:	00849513          	slli	a0,s1,0x8
204033b4:	00f50533          	add	a0,a0,a5
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
204033b8:	bf8ff0ef          	jal	ra,204027b0 <arch_irq_enable>
204033bc:	fa9ff06f          	j	20403364 <gpio_sifive_pin_interrupt_configure+0x9c>
			__ASSERT_NO_MSG(trig == GPIO_INT_TRIG_LOW);
204033c0:	000207b7          	lui	a5,0x20
204033c4:	02f68863          	beq	a3,a5,204033f4 <gpio_sifive_pin_interrupt_configure+0x12c>
204033c8:	204099b7          	lui	s3,0x20409
204033cc:	204095b7          	lui	a1,0x20409
204033d0:	20408537          	lui	a0,0x20408
204033d4:	99858593          	addi	a1,a1,-1640 # 20408998 <pinmux_sifive_driver_api+0x108>
204033d8:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204033dc:	10d00693          	li	a3,269
204033e0:	96898613          	addi	a2,s3,-1688 # 20408968 <pinmux_sifive_driver_api+0xd8>
204033e4:	c45fd0ef          	jal	ra,20401028 <printk>
204033e8:	10d00593          	li	a1,269
204033ec:	96898513          	addi	a0,s3,-1688
204033f0:	b7cff0ef          	jal	ra,2040276c <assert_post_action>
			gpio->low_ip = BIT(pin);
204033f4:	03242a23          	sw	s2,52(s0)
			gpio->low_ie  |= BIT(pin);
204033f8:	03042783          	lw	a5,48(s0)
204033fc:	00f96933          	or	s2,s2,a5
20403400:	03242823          	sw	s2,48(s0)
20403404:	f9dff06f          	j	204033a0 <gpio_sifive_pin_interrupt_configure+0xd8>
		if ((trig & GPIO_INT_HIGH_1) != 0) {
20403408:	000407b7          	lui	a5,0x40
2040340c:	00f6f7b3          	and	a5,a3,a5
20403410:	00078a63          	beqz	a5,20403424 <gpio_sifive_pin_interrupt_configure+0x15c>
			gpio->rise_ip = BIT(pin);
20403414:	01242e23          	sw	s2,28(s0)
			gpio->rise_ie |= BIT(pin);
20403418:	01842783          	lw	a5,24(s0)
2040341c:	00f967b3          	or	a5,s2,a5
20403420:	00f42c23          	sw	a5,24(s0)
		if ((trig & GPIO_INT_LOW_0) != 0) {
20403424:	000207b7          	lui	a5,0x20
20403428:	00f6f6b3          	and	a3,a3,a5
2040342c:	00068a63          	beqz	a3,20403440 <gpio_sifive_pin_interrupt_configure+0x178>
			gpio->fall_ip = BIT(pin);
20403430:	03242223          	sw	s2,36(s0)
			gpio->fall_ie |= BIT(pin);
20403434:	02042783          	lw	a5,32(s0)
20403438:	00f96933          	or	s2,s2,a5
2040343c:	03242023          	sw	s2,32(s0)
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
20403440:	008a2503          	lw	a0,8(s4)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
20403444:	00855793          	srli	a5,a0,0x8
20403448:	00079663          	bnez	a5,20403454 <gpio_sifive_pin_interrupt_configure+0x18c>
		pin_irq = base_irq + (pin << 8);
2040344c:	00a48533          	add	a0,s1,a0
20403450:	f69ff06f          	j	204033b8 <gpio_sifive_pin_interrupt_configure+0xf0>
20403454:	00849493          	slli	s1,s1,0x8
20403458:	ff5ff06f          	j	2040344c <gpio_sifive_pin_interrupt_configure+0x184>
		__ASSERT(false, "Invalid MODE %d passed to driver", mode);
2040345c:	20409437          	lui	s0,0x20409
20403460:	204095b7          	lui	a1,0x20409
20403464:	20408537          	lui	a0,0x20408
20403468:	12200693          	li	a3,290
2040346c:	96840613          	addi	a2,s0,-1688 # 20408968 <pinmux_sifive_driver_api+0xd8>
20403470:	fc458593          	addi	a1,a1,-60 # 20408fc4 <levels.0+0x4ac>
20403474:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20403478:	bb1fd0ef          	jal	ra,20401028 <printk>
2040347c:	20409537          	lui	a0,0x20409
20403480:	00098593          	mv	a1,s3
20403484:	9b450513          	addi	a0,a0,-1612 # 204089b4 <pinmux_sifive_driver_api+0x124>
20403488:	ba1fd0ef          	jal	ra,20401028 <printk>
2040348c:	96840513          	addi	a0,s0,-1688
20403490:	12200593          	li	a1,290
20403494:	ad8ff0ef          	jal	ra,2040276c <assert_post_action>
		return -ENOTSUP;
20403498:	f7a00513          	li	a0,-134
2040349c:	ecdff06f          	j	20403368 <gpio_sifive_pin_interrupt_configure+0xa0>

204034a0 <spi_context_get_next_buf.constprop.0>:
					     size_t *count,
					     size_t *buf_len,
					     uint8_t dfs)
{
	/* This loop skips zero-length buffers in the set, if any. */
	while (*count) {
204034a0:	0005a703          	lw	a4,0(a1)
204034a4:	00071863          	bnez	a4,204034b4 <spi_context_get_next_buf.constprop.0+0x14>
		}
		++(*current);
		--(*count);
	}

	*buf_len = 0;
204034a8:	00062023          	sw	zero,0(a2)
	return NULL;
204034ac:	00000513          	li	a0,0
}
204034b0:	00008067          	ret
		if (((*current)->len / dfs) != 0) {
204034b4:	00052783          	lw	a5,0(a0)
204034b8:	0047a683          	lw	a3,4(a5) # 20004 <__rom_region_size+0x16d48>
204034bc:	00068863          	beqz	a3,204034cc <spi_context_get_next_buf.constprop.0+0x2c>
			return (*current)->buf;
204034c0:	0007a503          	lw	a0,0(a5)
			*buf_len = (*current)->len / dfs;
204034c4:	00d62023          	sw	a3,0(a2)
			return (*current)->buf;
204034c8:	00008067          	ret
		++(*current);
204034cc:	00878793          	addi	a5,a5,8
204034d0:	00f52023          	sw	a5,0(a0)
		--(*count);
204034d4:	fff70713          	addi	a4,a4,-1
204034d8:	00e5a023          	sw	a4,0(a1)
204034dc:	fc5ff06f          	j	204034a0 <spi_context_get_next_buf.constprop.0>

204034e0 <gpio_pin_set_dt.isra.0>:
 *
 * @param spec GPIO specification from devicetree
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
204034e0:	fe010113          	addi	sp,sp,-32
204034e4:	00812c23          	sw	s0,24(sp)
204034e8:	00912a23          	sw	s1,20(sp)
204034ec:	01212823          	sw	s2,16(sp)
204034f0:	01412423          	sw	s4,8(sp)
204034f4:	00112e23          	sw	ra,28(sp)
204034f8:	01312623          	sw	s3,12(sp)
{
	return gpio_pin_set(spec->port, spec->pin, value);
204034fc:	00052403          	lw	s0,0(a0)
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
20403500:	00454783          	lbu	a5,4(a0)
20403504:	00100493          	li	s1,1
	const struct gpio_driver_data *const data =
20403508:	01042a03          	lw	s4,16(s0)
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
2040350c:	00f494b3          	sll	s1,s1,a5
20403510:	00442783          	lw	a5,4(s0)
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
20403514:	00058913          	mv	s2,a1
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
20403518:	0007a783          	lw	a5,0(a5)
2040351c:	00f4f7b3          	and	a5,s1,a5
20403520:	02079e63          	bnez	a5,2040355c <gpio_pin_set_dt.isra.0+0x7c>
20403524:	204089b7          	lui	s3,0x20408
20403528:	204085b7          	lui	a1,0x20408
2040352c:	20408537          	lui	a0,0x20408
20403530:	48058593          	addi	a1,a1,1152 # 20408480 <__clz_tab+0x238>
20403534:	4bb00693          	li	a3,1211
20403538:	38498613          	addi	a2,s3,900 # 20408384 <__clz_tab+0x13c>
2040353c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20403540:	ae9fd0ef          	jal	ra,20401028 <printk>
20403544:	20408537          	lui	a0,0x20408
20403548:	4c050513          	addi	a0,a0,1216 # 204084c0 <__clz_tab+0x278>
2040354c:	addfd0ef          	jal	ra,20401028 <printk>
20403550:	4bb00593          	li	a1,1211
20403554:	38498513          	addi	a0,s3,900
20403558:	a14ff0ef          	jal	ra,2040276c <assert_post_action>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
2040355c:	000a2783          	lw	a5,0(s4)
20403560:	00f4f7b3          	and	a5,s1,a5
20403564:	00078463          	beqz	a5,2040356c <gpio_pin_set_dt.isra.0+0x8c>
		value = (value != 0) ? 0 : 1;
20403568:	00194913          	xori	s2,s2,1
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
2040356c:	00442783          	lw	a5,4(s0)
20403570:	0007a783          	lw	a5,0(a5)
20403574:	00f4f7b3          	and	a5,s1,a5
20403578:	02079e63          	bnez	a5,204035b4 <gpio_pin_set_dt.isra.0+0xd4>
2040357c:	204089b7          	lui	s3,0x20408
20403580:	204085b7          	lui	a1,0x20408
20403584:	20408537          	lui	a0,0x20408
20403588:	48058593          	addi	a1,a1,1152 # 20408480 <__clz_tab+0x238>
2040358c:	49100693          	li	a3,1169
20403590:	38498613          	addi	a2,s3,900 # 20408384 <__clz_tab+0x13c>
20403594:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20403598:	a91fd0ef          	jal	ra,20401028 <printk>
2040359c:	20408537          	lui	a0,0x20408
204035a0:	4c050513          	addi	a0,a0,1216 # 204084c0 <__clz_tab+0x278>
204035a4:	a85fd0ef          	jal	ra,20401028 <printk>
204035a8:	49100593          	li	a1,1169
204035ac:	38498513          	addi	a0,s3,900
204035b0:	9bcff0ef          	jal	ra,2040276c <assert_post_action>
	if (value != 0)	{
204035b4:	02090a63          	beqz	s2,204035e8 <gpio_pin_set_dt.isra.0+0x108>
	return api->port_set_bits_raw(port, pins);
204035b8:	00842783          	lw	a5,8(s0)
204035bc:	00c7a783          	lw	a5,12(a5)
	return api->port_clear_bits_raw(port, pins);
204035c0:	00040513          	mv	a0,s0
}
204035c4:	01812403          	lw	s0,24(sp)
204035c8:	01c12083          	lw	ra,28(sp)
204035cc:	01012903          	lw	s2,16(sp)
204035d0:	00c12983          	lw	s3,12(sp)
204035d4:	00812a03          	lw	s4,8(sp)
	return api->port_clear_bits_raw(port, pins);
204035d8:	00048593          	mv	a1,s1
}
204035dc:	01412483          	lw	s1,20(sp)
204035e0:	02010113          	addi	sp,sp,32
	return api->port_clear_bits_raw(port, pins);
204035e4:	00078067          	jr	a5
204035e8:	00842783          	lw	a5,8(s0)
204035ec:	0107a783          	lw	a5,16(a5)
204035f0:	fd1ff06f          	j	204035c0 <gpio_pin_set_dt.isra.0+0xe0>

204035f4 <_spi_context_cs_control>:
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
204035f4:	00052783          	lw	a5,0(a0)
204035f8:	08078a63          	beqz	a5,2040368c <_spi_context_cs_control+0x98>
{
204035fc:	ff010113          	addi	sp,sp,-16
20403600:	00812423          	sw	s0,8(sp)
20403604:	00050413          	mv	s0,a0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
20403608:	0087a503          	lw	a0,8(a5)
{
2040360c:	00112623          	sw	ra,12(sp)
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
20403610:	06050663          	beqz	a0,2040367c <_spi_context_cs_control+0x88>
20403614:	00052703          	lw	a4,0(a0)
20403618:	06070263          	beqz	a4,2040367c <_spi_context_cs_control+0x88>
		if (on) {
2040361c:	02058463          	beqz	a1,20403644 <_spi_context_cs_control+0x50>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 1);
20403620:	00100593          	li	a1,1
20403624:	ebdff0ef          	jal	ra,204034e0 <gpio_pin_set_dt.isra.0>
			k_busy_wait(ctx->config->cs->delay);
20403628:	00042783          	lw	a5,0(s0)
2040362c:	0087a783          	lw	a5,8(a5)
20403630:	0087a503          	lw	a0,8(a5)
}
20403634:	00812403          	lw	s0,8(sp)
20403638:	00c12083          	lw	ra,12(sp)
2040363c:	01010113          	addi	sp,sp,16
	z_impl_k_busy_wait(usec_to_wait);
20403640:	1b00406f          	j	204077f0 <z_impl_k_busy_wait>
			if (!force_off &&
20403644:	00061a63          	bnez	a2,20403658 <_spi_context_cs_control+0x64>
20403648:	0047d783          	lhu	a5,4(a5)
2040364c:	00001737          	lui	a4,0x1
20403650:	00e7f7b3          	and	a5,a5,a4
20403654:	02079463          	bnez	a5,2040367c <_spi_context_cs_control+0x88>
			k_busy_wait(ctx->config->cs->delay);
20403658:	00852503          	lw	a0,8(a0)
2040365c:	194040ef          	jal	ra,204077f0 <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
20403660:	00042783          	lw	a5,0(s0)
}
20403664:	00812403          	lw	s0,8(sp)
20403668:	00c12083          	lw	ra,12(sp)
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
2040366c:	0087a503          	lw	a0,8(a5)
20403670:	00000593          	li	a1,0
}
20403674:	01010113          	addi	sp,sp,16
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
20403678:	e69ff06f          	j	204034e0 <gpio_pin_set_dt.isra.0>
}
2040367c:	00c12083          	lw	ra,12(sp)
20403680:	00812403          	lw	s0,8(sp)
20403684:	01010113          	addi	sp,sp,16
20403688:	00008067          	ret
2040368c:	00008067          	ret

20403690 <spi_context_unlock_unconditionally>:
{
20403690:	ff010113          	addi	sp,sp,-16
	_spi_context_cs_control(ctx, false, true);
20403694:	00100613          	li	a2,1
20403698:	00000593          	li	a1,0
{
2040369c:	00812423          	sw	s0,8(sp)
204036a0:	00112623          	sw	ra,12(sp)
204036a4:	00050413          	mv	s0,a0
	_spi_context_cs_control(ctx, false, true);
204036a8:	f4dff0ef          	jal	ra,204035f4 <_spi_context_cs_control>
	if (!k_sem_count_get(&ctx->lock)) {
204036ac:	01842783          	lw	a5,24(s0)
204036b0:	00079e63          	bnez	a5,204036cc <spi_context_unlock_unconditionally+0x3c>
		ctx->owner = NULL;
204036b4:	00042223          	sw	zero,4(s0)
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
204036b8:	01040513          	addi	a0,s0,16
}
204036bc:	00812403          	lw	s0,8(sp)
204036c0:	00c12083          	lw	ra,12(sp)
204036c4:	01010113          	addi	sp,sp,16
204036c8:	07d0106f          	j	20404f44 <z_impl_k_sem_give>
204036cc:	00c12083          	lw	ra,12(sp)
204036d0:	00812403          	lw	s0,8(sp)
204036d4:	01010113          	addi	sp,sp,16
204036d8:	00008067          	ret

204036dc <spi_sifive_release>:
}

int spi_sifive_release(const struct device *dev,
		       const struct spi_config *config)
{
	spi_context_unlock_unconditionally(&SPI_DATA(dev)->ctx);
204036dc:	01052503          	lw	a0,16(a0)
{
204036e0:	ff010113          	addi	sp,sp,-16
204036e4:	00112623          	sw	ra,12(sp)
	spi_context_unlock_unconditionally(&SPI_DATA(dev)->ctx);
204036e8:	fa9ff0ef          	jal	ra,20403690 <spi_context_unlock_unconditionally>
	return 0;
}
204036ec:	00c12083          	lw	ra,12(sp)
204036f0:	00000513          	li	a0,0
204036f4:	01010113          	addi	sp,sp,16
204036f8:	00008067          	ret

204036fc <spi_sifive_init>:
	sys_clear_bit(SPI_REG(dev, REG_FCTRL), SF_FCTRL_EN);
204036fc:	00452783          	lw	a5,4(a0)
{
20403700:	fb010113          	addi	sp,sp,-80
20403704:	03412c23          	sw	s4,56(sp)
	sys_clear_bit(SPI_REG(dev, REG_FCTRL), SF_FCTRL_EN);
20403708:	0007a703          	lw	a4,0(a5)
	err = spi_context_cs_configure_all(&SPI_DATA(dev)->ctx);
2040370c:	01052a03          	lw	s4,16(a0)
{
20403710:	04812423          	sw	s0,72(sp)
	*(volatile uint32_t *)addr = temp | (1 << bit);
}

static ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
20403714:	06072783          	lw	a5,96(a4) # 1060 <CONFIG_ISR_STACK_SIZE+0x860>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
20403718:	008a2403          	lw	s0,8(s4)
2040371c:	04912223          	sw	s1,68(sp)
20403720:	05212023          	sw	s2,64(sp)
20403724:	03512a23          	sw	s5,52(sp)
20403728:	03612823          	sw	s6,48(sp)
2040372c:	04112623          	sw	ra,76(sp)
20403730:	03312e23          	sw	s3,60(sp)
20403734:	03712623          	sw	s7,44(sp)
20403738:	03812423          	sw	s8,40(sp)
2040373c:	03912223          	sw	s9,36(sp)
20403740:	03a12023          	sw	s10,32(sp)
20403744:	01b12e23          	sw	s11,28(sp)

	*(volatile uint32_t *)addr = temp & ~(1 << bit);
20403748:	ffe7f793          	andi	a5,a5,-2
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
2040374c:	00002b37          	lui	s6,0x2
20403750:	00050913          	mv	s2,a0
20403754:	06f72023          	sw	a5,96(a4)
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
20403758:	204084b7          	lui	s1,0x20408
2040375c:	20408ab7          	lui	s5,0x20408
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
20403760:	a00b0b13          	addi	s6,s6,-1536 # 1a00 <CONFIG_ISR_STACK_SIZE+0x1200>
20403764:	00ca2783          	lw	a5,12(s4)
20403768:	00379713          	slli	a4,a5,0x3
2040376c:	008a2783          	lw	a5,8(s4)
20403770:	00e787b3          	add	a5,a5,a4
20403774:	00f46a63          	bltu	s0,a5,20403788 <spi_sifive_init+0x8c>
	spi_context_unlock_unconditionally(&SPI_DATA(dev)->ctx);
20403778:	01092503          	lw	a0,16(s2)
2040377c:	f15ff0ef          	jal	ra,20403690 <spi_context_unlock_unconditionally>
	return 0;
20403780:	00000513          	li	a0,0
20403784:	1580006f          	j	204038dc <spi_sifive_init+0x1e0>
		if (!device_is_ready(cs_gpio->port)) {
20403788:	00042503          	lw	a0,0(s0)
2040378c:	595000ef          	jal	ra,20404520 <z_device_ready>
20403790:	14050463          	beqz	a0,204038d8 <spi_sifive_init+0x1dc>
	return gpio_pin_configure(spec->port,
20403794:	00042983          	lw	s3,0(s0)
20403798:	00444b83          	lbu	s7,4(s0)
				  spec->dt_flags | extra_flags);
2040379c:	00544c83          	lbu	s9,5(s0)
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
204037a0:	03000793          	li	a5,48
204037a4:	030cf693          	andi	a3,s9,48
	const struct gpio_driver_api *api =
204037a8:	0089ad03          	lw	s10,8(s3)
	const struct gpio_driver_config *const cfg =
204037ac:	0049ad83          	lw	s11,4(s3)
	struct gpio_driver_data *data =
204037b0:	0109ac03          	lw	s8,16(s3)
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
204037b4:	02f69a63          	bne	a3,a5,204037e8 <spi_sifive_init+0xec>
204037b8:	204087b7          	lui	a5,0x20408
204037bc:	3b078593          	addi	a1,a5,944 # 204083b0 <__clz_tab+0x168>
204037c0:	2e100693          	li	a3,737
204037c4:	38448613          	addi	a2,s1,900 # 20408384 <__clz_tab+0x13c>
204037c8:	3eca8513          	addi	a0,s5,1004 # 204083ec <__clz_tab+0x1a4>
204037cc:	85dfd0ef          	jal	ra,20401028 <printk>
204037d0:	204087b7          	lui	a5,0x20408
204037d4:	40c78513          	addi	a0,a5,1036 # 2040840c <__clz_tab+0x1c4>
204037d8:	851fd0ef          	jal	ra,20401028 <printk>
204037dc:	2e100593          	li	a1,737
204037e0:	38448513          	addi	a0,s1,900
204037e4:	f89fe0ef          	jal	ra,2040276c <assert_post_action>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
204037e8:	006cf793          	andi	a5,s9,6
204037ec:	00400693          	li	a3,4
204037f0:	02d79463          	bne	a5,a3,20403818 <spi_sifive_init+0x11c>
204037f4:	204087b7          	lui	a5,0x20408
204037f8:	44c78593          	addi	a1,a5,1100 # 2040844c <__clz_tab+0x204>
204037fc:	3eca8513          	addi	a0,s5,1004
20403800:	2e900693          	li	a3,745
20403804:	38448613          	addi	a2,s1,900
20403808:	821fd0ef          	jal	ra,20401028 <printk>
2040380c:	2e900593          	li	a1,745
20403810:	38448513          	addi	a0,s1,900
20403814:	f59fe0ef          	jal	ra,2040276c <assert_post_action>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
20403818:	001cf693          	andi	a3,s9,1
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
2040381c:	016cc7b3          	xor	a5,s9,s6
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
20403820:	00069863          	bnez	a3,20403830 <spi_sifive_init+0x134>
	return gpio_pin_configure(spec->port,
20403824:	000017b7          	lui	a5,0x1
20403828:	60078793          	addi	a5,a5,1536 # 1600 <CONFIG_ISR_STACK_SIZE+0xe00>
2040382c:	00fce7b3          	or	a5,s9,a5
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
20403830:	000da683          	lw	a3,0(s11)
20403834:	00100713          	li	a4,1
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
20403838:	fffff837          	lui	a6,0xfffff
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
2040383c:	01771733          	sll	a4,a4,s7
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
20403840:	fff80813          	addi	a6,a6,-1 # ffffefff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffff000>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
20403844:	00d776b3          	and	a3,a4,a3
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
20403848:	0107f833          	and	a6,a5,a6
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
2040384c:	04069663          	bnez	a3,20403898 <spi_sifive_init+0x19c>
20403850:	00f12223          	sw	a5,4(sp)
20403854:	204087b7          	lui	a5,0x20408
20403858:	48078593          	addi	a1,a5,1152 # 20408480 <__clz_tab+0x238>
2040385c:	2fd00693          	li	a3,765
20403860:	38448613          	addi	a2,s1,900
20403864:	3eca8513          	addi	a0,s5,1004
20403868:	00e12623          	sw	a4,12(sp)
2040386c:	01012423          	sw	a6,8(sp)
20403870:	fb8fd0ef          	jal	ra,20401028 <printk>
20403874:	20408537          	lui	a0,0x20408
20403878:	4c050513          	addi	a0,a0,1216 # 204084c0 <__clz_tab+0x278>
2040387c:	facfd0ef          	jal	ra,20401028 <printk>
20403880:	2fd00593          	li	a1,765
20403884:	38448513          	addi	a0,s1,900
20403888:	ee5fe0ef          	jal	ra,2040276c <assert_post_action>
2040388c:	00c12703          	lw	a4,12(sp)
20403890:	00812803          	lw	a6,8(sp)
20403894:	00412783          	lw	a5,4(sp)
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
20403898:	0017f793          	andi	a5,a5,1
		data->invert |= (gpio_port_pins_t)BIT(pin);
2040389c:	000c2683          	lw	a3,0(s8)
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
204038a0:	02078663          	beqz	a5,204038cc <spi_sifive_init+0x1d0>
		data->invert |= (gpio_port_pins_t)BIT(pin);
204038a4:	00d76733          	or	a4,a4,a3
	return api->pin_configure(port, pin, flags);
204038a8:	000d2783          	lw	a5,0(s10)
204038ac:	00ec2023          	sw	a4,0(s8)
204038b0:	00080613          	mv	a2,a6
204038b4:	000b8593          	mv	a1,s7
204038b8:	00098513          	mv	a0,s3
204038bc:	000780e7          	jalr	a5
		if (ret < 0) {
204038c0:	00054e63          	bltz	a0,204038dc <spi_sifive_init+0x1e0>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
204038c4:	00840413          	addi	s0,s0,8
204038c8:	e9dff06f          	j	20403764 <spi_sifive_init+0x68>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
204038cc:	fff74713          	not	a4,a4
204038d0:	00d77733          	and	a4,a4,a3
204038d4:	fd5ff06f          	j	204038a8 <spi_sifive_init+0x1ac>
			return -ENODEV;
204038d8:	fed00513          	li	a0,-19
}
204038dc:	04c12083          	lw	ra,76(sp)
204038e0:	04812403          	lw	s0,72(sp)
204038e4:	04412483          	lw	s1,68(sp)
204038e8:	04012903          	lw	s2,64(sp)
204038ec:	03c12983          	lw	s3,60(sp)
204038f0:	03812a03          	lw	s4,56(sp)
204038f4:	03412a83          	lw	s5,52(sp)
204038f8:	03012b03          	lw	s6,48(sp)
204038fc:	02c12b83          	lw	s7,44(sp)
20403900:	02812c03          	lw	s8,40(sp)
20403904:	02412c83          	lw	s9,36(sp)
20403908:	02012d03          	lw	s10,32(sp)
2040390c:	01c12d83          	lw	s11,28(sp)
20403910:	05010113          	addi	sp,sp,80
20403914:	00008067          	ret

20403918 <spi_config>:
	if (operation & SPI_MODE_LOOP) {
20403918:	000016b7          	lui	a3,0x1
2040391c:	80968793          	addi	a5,a3,-2039 # 809 <CONFIG_ISR_STACK_SIZE+0x9>
20403920:	00f677b3          	and	a5,a2,a5
20403924:	0c079863          	bnez	a5,204039f4 <spi_config+0xdc>
	div = (SPI_CFG(dev)->f_sys / (frequency * 2U)) - 1;
20403928:	00452783          	lw	a5,4(a0)
2040392c:	00159593          	slli	a1,a1,0x1
	sys_write32((SF_SCKDIV_DIV_MASK & div), SPI_REG(dev, REG_SCKDIV));
20403930:	fff68693          	addi	a3,a3,-1
	div = (SPI_CFG(dev)->f_sys / (frequency * 2U)) - 1;
20403934:	0047a703          	lw	a4,4(a5)
20403938:	02b75733          	divu	a4,a4,a1
2040393c:	fff70713          	addi	a4,a4,-1
	sys_write32((SF_SCKDIV_DIV_MASK & div), SPI_REG(dev, REG_SCKDIV));
20403940:	00d77733          	and	a4,a4,a3
	return *(volatile uint32_t *)addr;
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
20403944:	0007a683          	lw	a3,0(a5)
20403948:	00e6a023          	sw	a4,0(a3)
	if (operation & SPI_MODE_CPOL) {
2040394c:	00267693          	andi	a3,a2,2
20403950:	0007a703          	lw	a4,0(a5)
20403954:	08068063          	beqz	a3,204039d4 <spi_config+0xbc>
	uint32_t temp = *(volatile uint32_t *)addr;
20403958:	00472683          	lw	a3,4(a4)
	*(volatile uint32_t *)addr = temp | (1 << bit);
2040395c:	0026e693          	ori	a3,a3,2
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
20403960:	00d72223          	sw	a3,4(a4)
	if (operation & SPI_MODE_CPHA) {
20403964:	00467693          	andi	a3,a2,4
		sys_set_bit(SPI_REG(dev, REG_SCKMODE), SF_SCKMODE_PHA);
20403968:	0007a703          	lw	a4,0(a5)
	if (operation & SPI_MODE_CPHA) {
2040396c:	06068a63          	beqz	a3,204039e0 <spi_config+0xc8>
	uint32_t temp = *(volatile uint32_t *)addr;
20403970:	00472683          	lw	a3,4(a4)
	*(volatile uint32_t *)addr = temp | (1 << bit);
20403974:	0016e693          	ori	a3,a3,1
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
20403978:	00d72223          	sw	a3,4(a4)
	sys_set_mask(SPI_REG(dev, REG_FMT), SF_FMT_LEN_MASK, fmt_len);
2040397c:	0007a583          	lw	a1,0(a5)
	temp &= ~(mask);
20403980:	fff106b7          	lui	a3,0xfff10
20403984:	fff68693          	addi	a3,a3,-1 # fff0ffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfff10000>
	return *(volatile uint32_t *)addr;
20403988:	0405a703          	lw	a4,64(a1)
	fmt_len &= SF_FMT_LEN_MASK;
2040398c:	000f0537          	lui	a0,0xf0
	temp &= ~(mask);
20403990:	00d776b3          	and	a3,a4,a3
	fmt_len &= SF_FMT_LEN_MASK;
20403994:	00b61713          	slli	a4,a2,0xb
20403998:	00a77733          	and	a4,a4,a0
	temp |= value;
2040399c:	00d76733          	or	a4,a4,a3
	*(volatile uint32_t *)addr = data;
204039a0:	04e5a023          	sw	a4,64(a1)
	sys_set_mask(SPI_REG(dev, REG_FMT),
204039a4:	0007a683          	lw	a3,0(a5)
	if (operation & SPI_TRANSFER_LSB) {
204039a8:	01067613          	andi	a2,a2,16
	return *(volatile uint32_t *)addr;
204039ac:	0406a703          	lw	a4,64(a3)
	temp &= ~(mask);
204039b0:	ffc77713          	andi	a4,a4,-4
	*(volatile uint32_t *)addr = data;
204039b4:	04e6a023          	sw	a4,64(a3)
	if (operation & SPI_TRANSFER_LSB) {
204039b8:	0007a783          	lw	a5,0(a5)
	uint32_t temp = *(volatile uint32_t *)addr;
204039bc:	0407a703          	lw	a4,64(a5)
204039c0:	02060663          	beqz	a2,204039ec <spi_config+0xd4>
	*(volatile uint32_t *)addr = temp | (1 << bit);
204039c4:	00476713          	ori	a4,a4,4
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
204039c8:	04e7a023          	sw	a4,64(a5)
	return 0;
204039cc:	00000513          	li	a0,0
}
204039d0:	00008067          	ret
	uint32_t temp = *(volatile uint32_t *)addr;
204039d4:	00472683          	lw	a3,4(a4)
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
204039d8:	ffd6f693          	andi	a3,a3,-3
204039dc:	f85ff06f          	j	20403960 <spi_config+0x48>
	uint32_t temp = *(volatile uint32_t *)addr;
204039e0:	00472683          	lw	a3,4(a4)
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
204039e4:	ffe6f693          	andi	a3,a3,-2
204039e8:	f91ff06f          	j	20403978 <spi_config+0x60>
204039ec:	ffb77713          	andi	a4,a4,-5
204039f0:	fd9ff06f          	j	204039c8 <spi_config+0xb0>
		return -ENOTSUP;
204039f4:	f7a00513          	li	a0,-134
}
204039f8:	00008067          	ret

204039fc <spi_sifive_send>:
	while (sys_read32(SPI_REG(dev, REG_TXDATA)) & SF_TXDATA_FULL) {
204039fc:	00452783          	lw	a5,4(a0) # f0004 <__rom_region_size+0xe6d48>
20403a00:	0007a783          	lw	a5,0(a5)
20403a04:	04878693          	addi	a3,a5,72
	return *(volatile uint32_t *)addr;
20403a08:	0006a703          	lw	a4,0(a3)
20403a0c:	fe074ee3          	bltz	a4,20403a08 <spi_sifive_send+0xc>
	*(volatile uint32_t *)addr = data;
20403a10:	04b7a423          	sw	a1,72(a5)
}
20403a14:	00008067          	ret

20403a18 <spi_sifive_recv>:
	while ((val = sys_read32(SPI_REG(dev, REG_RXDATA))) & SF_RXDATA_EMPTY) {
20403a18:	00452783          	lw	a5,4(a0)
20403a1c:	0007a783          	lw	a5,0(a5)
20403a20:	04c78793          	addi	a5,a5,76
	return *(volatile uint32_t *)addr;
20403a24:	0007a503          	lw	a0,0(a5)
20403a28:	fe054ee3          	bltz	a0,20403a24 <spi_sifive_recv+0xc>
}
20403a2c:	01051513          	slli	a0,a0,0x10
20403a30:	01055513          	srli	a0,a0,0x10
20403a34:	00008067          	ret

20403a38 <spi_sifive_xfer>:
{
20403a38:	fd010113          	addi	sp,sp,-48
20403a3c:	02812423          	sw	s0,40(sp)
	struct spi_context *ctx = &SPI_DATA(dev)->ctx;
20403a40:	01052403          	lw	s0,16(a0)
{
20403a44:	02912223          	sw	s1,36(sp)
20403a48:	03212023          	sw	s2,32(sp)
20403a4c:	01312e23          	sw	s3,28(sp)
20403a50:	01412c23          	sw	s4,24(sp)
20403a54:	01512a23          	sw	s5,20(sp)
20403a58:	01612823          	sw	s6,16(sp)
20403a5c:	01712623          	sw	s7,12(sp)
20403a60:	01812423          	sw	s8,8(sp)
20403a64:	02112623          	sw	ra,44(sp)
20403a68:	00050493          	mv	s1,a0
20403a6c:	00058913          	mv	s2,a1
	if (!ctx->tx_len) {
		/* Current buffer is done. Get the next one to be processed. */
		++ctx->current_tx;
		--ctx->tx_count;
		ctx->tx_buf = (const uint8_t *)
			spi_context_get_next_buf(&ctx->current_tx,
20403a70:	04840993          	addi	s3,s0,72
20403a74:	03840a13          	addi	s4,s0,56
20403a78:	03440a93          	addi	s5,s0,52
	if (!ctx->rx_len) {
		/* Current buffer is done. Get the next one to be processed. */
		++ctx->current_rx;
		--ctx->rx_count;
		ctx->rx_buf = (uint8_t *)
			spi_context_get_next_buf(&ctx->current_rx,
20403a7c:	05040b13          	addi	s6,s0,80
20403a80:	04040b93          	addi	s7,s0,64
20403a84:	03c40c13          	addi	s8,s0,60
	return !!(ctx->tx_buf && ctx->tx_len);
20403a88:	04442783          	lw	a5,68(s0)
			txd = 0U;
20403a8c:	00000593          	li	a1,0
20403a90:	00078863          	beqz	a5,20403aa0 <spi_sifive_xfer+0x68>
20403a94:	04842703          	lw	a4,72(s0)
20403a98:	00070463          	beqz	a4,20403aa0 <spi_sifive_xfer+0x68>
			txd = *ctx->tx_buf;
20403a9c:	0007c583          	lbu	a1,0(a5)
		spi_sifive_send(dev, txd);
20403aa0:	00048513          	mv	a0,s1
20403aa4:	f59ff0ef          	jal	ra,204039fc <spi_sifive_send>
	if (!ctx->tx_len) {
20403aa8:	04842783          	lw	a5,72(s0)
20403aac:	02078e63          	beqz	a5,20403ae8 <spi_sifive_xfer+0xb0>
	ctx->tx_len -= len;
20403ab0:	fff78793          	addi	a5,a5,-1
20403ab4:	04f42423          	sw	a5,72(s0)
	if (!ctx->tx_len) {
20403ab8:	0e079463          	bnez	a5,20403ba0 <spi_sifive_xfer+0x168>
		++ctx->current_tx;
20403abc:	03442783          	lw	a5,52(s0)
			spi_context_get_next_buf(&ctx->current_tx,
20403ac0:	00098613          	mv	a2,s3
20403ac4:	000a0593          	mv	a1,s4
		++ctx->current_tx;
20403ac8:	00878793          	addi	a5,a5,8
20403acc:	02f42a23          	sw	a5,52(s0)
		--ctx->tx_count;
20403ad0:	03842783          	lw	a5,56(s0)
			spi_context_get_next_buf(&ctx->current_tx,
20403ad4:	000a8513          	mv	a0,s5
		--ctx->tx_count;
20403ad8:	fff78793          	addi	a5,a5,-1
20403adc:	02f42c23          	sw	a5,56(s0)
			spi_context_get_next_buf(&ctx->current_tx,
20403ae0:	9c1ff0ef          	jal	ra,204034a0 <spi_context_get_next_buf.constprop.0>
		ctx->tx_buf = (const uint8_t *)
20403ae4:	04a42223          	sw	a0,68(s0)
		rxd = spi_sifive_recv(dev);
20403ae8:	00048513          	mv	a0,s1
20403aec:	f2dff0ef          	jal	ra,20403a18 <spi_sifive_recv>
}

static ALWAYS_INLINE
bool spi_context_rx_buf_on(struct spi_context *ctx)
{
	return !!(ctx->rx_buf && ctx->rx_len);
20403af0:	04c42783          	lw	a5,76(s0)
20403af4:	00078863          	beqz	a5,20403b04 <spi_sifive_xfer+0xcc>
20403af8:	05042703          	lw	a4,80(s0)
20403afc:	00070463          	beqz	a4,20403b04 <spi_sifive_xfer+0xcc>
			*ctx->rx_buf = rxd;
20403b00:	00a78023          	sb	a0,0(a5)
	if (!ctx->rx_len) {
20403b04:	05042783          	lw	a5,80(s0)
20403b08:	02078e63          	beqz	a5,20403b44 <spi_sifive_xfer+0x10c>
	ctx->rx_len -= len;
20403b0c:	fff78793          	addi	a5,a5,-1
20403b10:	04f42823          	sw	a5,80(s0)
	if (!ctx->rx_len) {
20403b14:	0a079063          	bnez	a5,20403bb4 <spi_sifive_xfer+0x17c>
		++ctx->current_rx;
20403b18:	03c42783          	lw	a5,60(s0)
			spi_context_get_next_buf(&ctx->current_rx,
20403b1c:	000b0613          	mv	a2,s6
20403b20:	000b8593          	mv	a1,s7
		++ctx->current_rx;
20403b24:	00878793          	addi	a5,a5,8
20403b28:	02f42e23          	sw	a5,60(s0)
		--ctx->rx_count;
20403b2c:	04042783          	lw	a5,64(s0)
			spi_context_get_next_buf(&ctx->current_rx,
20403b30:	000c0513          	mv	a0,s8
		--ctx->rx_count;
20403b34:	fff78793          	addi	a5,a5,-1
20403b38:	04f42023          	sw	a5,64(s0)
			spi_context_get_next_buf(&ctx->current_rx,
20403b3c:	965ff0ef          	jal	ra,204034a0 <spi_context_get_next_buf.constprop.0>
		ctx->rx_buf = (uint8_t *)
20403b40:	04a42623          	sw	a0,76(s0)
	} while (spi_context_tx_on(ctx) || spi_context_rx_on(ctx));
20403b44:	04842783          	lw	a5,72(s0)
20403b48:	f40790e3          	bnez	a5,20403a88 <spi_sifive_xfer+0x50>
20403b4c:	05042783          	lw	a5,80(s0)
20403b50:	f2079ce3          	bnez	a5,20403a88 <spi_sifive_xfer+0x50>
	if (!hw_cs_control) {
20403b54:	06091a63          	bnez	s2,20403bc8 <spi_sifive_xfer+0x190>
	_spi_context_cs_control(ctx, on, false);
20403b58:	0104a503          	lw	a0,16(s1)
20403b5c:	00000613          	li	a2,0
20403b60:	00000593          	li	a1,0
20403b64:	a91ff0ef          	jal	ra,204035f4 <_spi_context_cs_control>
	ctx->sync_status = status;
20403b68:	02042823          	sw	zero,48(s0)
20403b6c:	02040513          	addi	a0,s0,32
}
20403b70:	02812403          	lw	s0,40(sp)
20403b74:	02c12083          	lw	ra,44(sp)
20403b78:	02412483          	lw	s1,36(sp)
20403b7c:	02012903          	lw	s2,32(sp)
20403b80:	01c12983          	lw	s3,28(sp)
20403b84:	01812a03          	lw	s4,24(sp)
20403b88:	01412a83          	lw	s5,20(sp)
20403b8c:	01012b03          	lw	s6,16(sp)
20403b90:	00c12b83          	lw	s7,12(sp)
20403b94:	00812c03          	lw	s8,8(sp)
20403b98:	03010113          	addi	sp,sp,48
20403b9c:	3a80106f          	j	20404f44 <z_impl_k_sem_give>
	} else if (ctx->tx_buf) {
20403ba0:	04442783          	lw	a5,68(s0)
20403ba4:	f40782e3          	beqz	a5,20403ae8 <spi_sifive_xfer+0xb0>
		ctx->tx_buf += dfs * len;
20403ba8:	00178793          	addi	a5,a5,1
20403bac:	04f42223          	sw	a5,68(s0)
20403bb0:	f39ff06f          	j	20403ae8 <spi_sifive_xfer+0xb0>
	} else if (ctx->rx_buf) {
20403bb4:	04c42783          	lw	a5,76(s0)
20403bb8:	f80786e3          	beqz	a5,20403b44 <spi_sifive_xfer+0x10c>
		ctx->rx_buf += dfs * len;
20403bbc:	00178793          	addi	a5,a5,1
20403bc0:	04f42623          	sw	a5,76(s0)
20403bc4:	f81ff06f          	j	20403b44 <spi_sifive_xfer+0x10c>
		sys_write32(SF_CSMODE_OFF, SPI_REG(dev, REG_CSMODE));
20403bc8:	0044a783          	lw	a5,4(s1)
	*(volatile uint32_t *)addr = data;
20403bcc:	00300713          	li	a4,3
20403bd0:	0007a783          	lw	a5,0(a5)
20403bd4:	00e7ac23          	sw	a4,24(a5)
}
20403bd8:	f91ff06f          	j	20403b68 <spi_sifive_xfer+0x130>

20403bdc <spi_sifive_transceive>:
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
20403bdc:	0045d783          	lhu	a5,4(a1)
{
20403be0:	fe010113          	addi	sp,sp,-32
20403be4:	00002737          	lui	a4,0x2
20403be8:	00812c23          	sw	s0,24(sp)
20403bec:	00912a23          	sw	s1,20(sp)
20403bf0:	01212823          	sw	s2,16(sp)
20403bf4:	01312623          	sw	s3,12(sp)
20403bf8:	01412423          	sw	s4,8(sp)
20403bfc:	00112e23          	sw	ra,28(sp)
20403c00:	01512223          	sw	s5,4(sp)
20403c04:	00e7f7b3          	and	a5,a5,a4
	spi_context_lock(&SPI_DATA(dev)->ctx, false, NULL, config);
20403c08:	01052903          	lw	s2,16(a0)
{
20403c0c:	00050493          	mv	s1,a0
20403c10:	00058413          	mv	s0,a1
20403c14:	00060a13          	mv	s4,a2
20403c18:	00068993          	mv	s3,a3
20403c1c:	0a079063          	bnez	a5,20403cbc <spi_sifive_transceive+0xe0>
	return z_impl_k_sem_take(sem, timeout);
20403c20:	fff00593          	li	a1,-1
20403c24:	fff00613          	li	a2,-1
20403c28:	01090513          	addi	a0,s2,16
20403c2c:	3e8010ef          	jal	ra,20405014 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
20403c30:	00892223          	sw	s0,4(s2)
	SPI_DATA(dev)->ctx.config = config;
20403c34:	0104a783          	lw	a5,16(s1)
	if (config->cs == NULL) {
20403c38:	00842683          	lw	a3,8(s0)
	SPI_DATA(dev)->ctx.config = config;
20403c3c:	0087a023          	sw	s0,0(a5)
		sys_write32(SF_CSMODE_OFF, SPI_REG(dev, REG_CSMODE));
20403c40:	0044a783          	lw	a5,4(s1)
20403c44:	0007a703          	lw	a4,0(a5)
	if (config->cs == NULL) {
20403c48:	08068463          	beqz	a3,20403cd0 <spi_sifive_transceive+0xf4>
	*(volatile uint32_t *)addr = data;
20403c4c:	00300793          	li	a5,3
20403c50:	00f72c23          	sw	a5,24(a4) # 2018 <__kernel_ram_size+0x88>
	bool hw_cs_control = false;
20403c54:	00000a93          	li	s5,0
	rc = spi_config(dev, config->frequency, config->operation);
20403c58:	00445603          	lhu	a2,4(s0)
20403c5c:	00042583          	lw	a1,0(s0)
20403c60:	00048513          	mv	a0,s1
20403c64:	cb5ff0ef          	jal	ra,20403918 <spi_config>
20403c68:	00050913          	mv	s2,a0
	if (rc < 0) {
20403c6c:	0104a403          	lw	s0,16(s1)
20403c70:	06055e63          	bgez	a0,20403cec <spi_sifive_transceive+0x110>
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
20403c74:	00042783          	lw	a5,0(s0)
20403c78:	00002737          	lui	a4,0x2
20403c7c:	0047d783          	lhu	a5,4(a5)
20403c80:	00e7f7b3          	and	a5,a5,a4
20403c84:	00079863          	bnez	a5,20403c94 <spi_sifive_transceive+0xb8>
		ctx->owner = NULL;
20403c88:	00042223          	sw	zero,4(s0)
	z_impl_k_sem_give(sem);
20403c8c:	01040513          	addi	a0,s0,16
20403c90:	2b4010ef          	jal	ra,20404f44 <z_impl_k_sem_give>
}
20403c94:	01c12083          	lw	ra,28(sp)
20403c98:	01812403          	lw	s0,24(sp)
20403c9c:	01412483          	lw	s1,20(sp)
20403ca0:	00c12983          	lw	s3,12(sp)
20403ca4:	00812a03          	lw	s4,8(sp)
20403ca8:	00412a83          	lw	s5,4(sp)
20403cac:	00090513          	mv	a0,s2
20403cb0:	01012903          	lw	s2,16(sp)
20403cb4:	02010113          	addi	sp,sp,32
20403cb8:	00008067          	ret
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
20403cbc:	01892783          	lw	a5,24(s2)
20403cc0:	f60790e3          	bnez	a5,20403c20 <spi_sifive_transceive+0x44>
		(k_sem_count_get(&ctx->lock) == 0) &&
20403cc4:	00492783          	lw	a5,4(s2)
20403cc8:	f4f59ce3          	bne	a1,a5,20403c20 <spi_sifive_transceive+0x44>
20403ccc:	f69ff06f          	j	20403c34 <spi_sifive_transceive+0x58>
		sys_write32(config->slave, SPI_REG(dev, REG_CSID));
20403cd0:	00645683          	lhu	a3,6(s0)
		hw_cs_control = true;
20403cd4:	00100a93          	li	s5,1
20403cd8:	00d72823          	sw	a3,16(a4) # 2010 <__kernel_ram_size+0x80>
		sys_write32(SF_CSMODE_OFF, SPI_REG(dev, REG_CSMODE));
20403cdc:	0007a783          	lw	a5,0(a5)
20403ce0:	00300713          	li	a4,3
20403ce4:	00e7ac23          	sw	a4,24(a5)
}
20403ce8:	f71ff06f          	j	20403c58 <spi_sifive_transceive+0x7c>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
20403cec:	0e0a1e63          	bnez	s4,20403de8 <spi_sifive_transceive+0x20c>
20403cf0:	02042a23          	sw	zero,52(s0)
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
20403cf4:	00000793          	li	a5,0
20403cf8:	02f42c23          	sw	a5,56(s0)
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
20403cfc:	04840613          	addi	a2,s0,72
20403d00:	03840593          	addi	a1,s0,56
20403d04:	03440513          	addi	a0,s0,52
20403d08:	f98ff0ef          	jal	ra,204034a0 <spi_context_get_next_buf.constprop.0>
	ctx->tx_buf = (const uint8_t *)
20403d0c:	04a42223          	sw	a0,68(s0)
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
20403d10:	0e099863          	bnez	s3,20403e00 <spi_sifive_transceive+0x224>
20403d14:	02042e23          	sw	zero,60(s0)
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
20403d18:	00000793          	li	a5,0
20403d1c:	04f42023          	sw	a5,64(s0)
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
20403d20:	05040613          	addi	a2,s0,80
20403d24:	04040593          	addi	a1,s0,64
20403d28:	03c40513          	addi	a0,s0,60
20403d2c:	f74ff0ef          	jal	ra,204034a0 <spi_context_get_next_buf.constprop.0>
	ctx->rx_buf = (uint8_t *)
20403d30:	04a42623          	sw	a0,76(s0)
	ctx->sync_status = 0;
20403d34:	02042823          	sw	zero,48(s0)
	if (!hw_cs_control) {
20403d38:	0e0a9063          	bnez	s5,20403e18 <spi_sifive_transceive+0x23c>
	_spi_context_cs_control(ctx, on, false);
20403d3c:	0104a503          	lw	a0,16(s1)
20403d40:	00000613          	li	a2,0
20403d44:	00100593          	li	a1,1
20403d48:	8adff0ef          	jal	ra,204035f4 <_spi_context_cs_control>
	spi_sifive_xfer(dev, hw_cs_control);
20403d4c:	000a8593          	mv	a1,s5
20403d50:	00048513          	mv	a0,s1
20403d54:	ce5ff0ef          	jal	ra,20403a38 <spi_sifive_xfer>
	rc = spi_context_wait_for_completion(&SPI_DATA(dev)->ctx);
20403d58:	0104a403          	lw	s0,16(s1)
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
20403d5c:	04842703          	lw	a4,72(s0)
20403d60:	05042783          	lw	a5,80(s0)
20403d64:	00e7f463          	bgeu	a5,a4,20403d6c <spi_sifive_transceive+0x190>
20403d68:	00070793          	mv	a5,a4
20403d6c:	00002737          	lui	a4,0x2
20403d70:	f4070713          	addi	a4,a4,-192 # 1f40 <CONFIG_ISR_STACK_SIZE+0x1740>
20403d74:	02e787b3          	mul	a5,a5,a4
			     ctx->config->frequency;
20403d78:	00042703          	lw	a4,0(s0)
20403d7c:	3e800613          	li	a2,1000
20403d80:	00000693          	li	a3,0
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
20403d84:	00072583          	lw	a1,0(a4)
20403d88:	02b7d7b3          	divu	a5,a5,a1
		timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
20403d8c:	0c878793          	addi	a5,a5,200
20403d90:	0197d593          	srli	a1,a5,0x19
20403d94:	00779793          	slli	a5,a5,0x7
20403d98:	3e778513          	addi	a0,a5,999
20403d9c:	00f537b3          	sltu	a5,a0,a5
20403da0:	00b785b3          	add	a1,a5,a1
20403da4:	ddcfc0ef          	jal	ra,20400380 <__udivdi3>
20403da8:	00058613          	mv	a2,a1
20403dac:	00050593          	mv	a1,a0
	return z_impl_k_sem_take(sem, timeout);
20403db0:	02040513          	addi	a0,s0,32
20403db4:	260010ef          	jal	ra,20405014 <z_impl_k_sem_take>
		return -ETIMEDOUT;
20403db8:	f8c00913          	li	s2,-116
	if (k_sem_take(&ctx->sync, timeout)) {
20403dbc:	00051463          	bnez	a0,20403dc4 <spi_sifive_transceive+0x1e8>
	status = ctx->sync_status;
20403dc0:	03042903          	lw	s2,48(s0)
	spi_context_release(&SPI_DATA(dev)->ctx, rc);
20403dc4:	0104a503          	lw	a0,16(s1)
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
20403dc8:	00002737          	lui	a4,0x2
20403dcc:	00052783          	lw	a5,0(a0)
20403dd0:	0047d783          	lhu	a5,4(a5)
20403dd4:	00e7f7b3          	and	a5,a5,a4
20403dd8:	ea079ee3          	bnez	a5,20403c94 <spi_sifive_transceive+0xb8>
		ctx->owner = NULL;
20403ddc:	00052223          	sw	zero,4(a0)
	z_impl_k_sem_give(sem);
20403de0:	01050513          	addi	a0,a0,16
20403de4:	eadff06f          	j	20403c90 <spi_sifive_transceive+0xb4>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
20403de8:	000a2703          	lw	a4,0(s4)
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
20403dec:	00000793          	li	a5,0
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
20403df0:	02e42a23          	sw	a4,52(s0)
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
20403df4:	f00702e3          	beqz	a4,20403cf8 <spi_sifive_transceive+0x11c>
20403df8:	004a2783          	lw	a5,4(s4)
20403dfc:	efdff06f          	j	20403cf8 <spi_sifive_transceive+0x11c>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
20403e00:	0009a703          	lw	a4,0(s3)
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
20403e04:	00000793          	li	a5,0
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
20403e08:	02e42e23          	sw	a4,60(s0)
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
20403e0c:	f00708e3          	beqz	a4,20403d1c <spi_sifive_transceive+0x140>
20403e10:	0049a783          	lw	a5,4(s3)
20403e14:	f09ff06f          	j	20403d1c <spi_sifive_transceive+0x140>
		sys_write32(SF_CSMODE_HOLD, SPI_REG(dev, REG_CSMODE));
20403e18:	0044a783          	lw	a5,4(s1)
	*(volatile uint32_t *)addr = data;
20403e1c:	00200713          	li	a4,2
20403e20:	0007a783          	lw	a5,0(a5)
20403e24:	00e7ac23          	sw	a4,24(a5)
}
20403e28:	f25ff06f          	j	20403d4c <spi_sifive_transceive+0x170>

20403e2c <uart_sifive_poll_out>:
 * @param c Character to send
 */
static void uart_sifive_poll_out(const struct device *dev,
					 unsigned char c)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403e2c:	00452783          	lw	a5,4(a0)
20403e30:	0007a783          	lw	a5,0(a5)

	/* Wait while TX FIFO is full */
	while (uart->tx & TXDATA_FULL) {
20403e34:	0007a703          	lw	a4,0(a5)
20403e38:	fe074ee3          	bltz	a4,20403e34 <uart_sifive_poll_out+0x8>
	}

	uart->tx = (int)c;
20403e3c:	00b7a023          	sw	a1,0(a5)
}
20403e40:	00008067          	ret

20403e44 <uart_sifive_poll_in>:
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_sifive_poll_in(const struct device *dev, unsigned char *c)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403e44:	00452783          	lw	a5,4(a0)
20403e48:	0007a783          	lw	a5,0(a5)
	uint32_t val = uart->rx;
20403e4c:	0047a783          	lw	a5,4(a5)

	if (val & RXDATA_EMPTY) {
20403e50:	0007c863          	bltz	a5,20403e60 <uart_sifive_poll_in+0x1c>
		return -1;
	}

	*c = (unsigned char)(val & RXDATA_MASK);
20403e54:	00f58023          	sb	a5,0(a1)

	return 0;
20403e58:	00000513          	li	a0,0
20403e5c:	00008067          	ret
		return -1;
20403e60:	fff00513          	li	a0,-1
}
20403e64:	00008067          	ret

20403e68 <uart_sifive_fifo_fill>:
 */
static int uart_sifive_fifo_fill(const struct device *dev,
				 const uint8_t *tx_data,
				 int size)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403e68:	00452783          	lw	a5,4(a0)
	int i;

	for (i = 0; i < size && !(uart->tx & TXDATA_FULL); i++)
20403e6c:	00000513          	li	a0,0
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403e70:	0007a783          	lw	a5,0(a5)
	for (i = 0; i < size && !(uart->tx & TXDATA_FULL); i++)
20403e74:	00c55663          	bge	a0,a2,20403e80 <uart_sifive_fifo_fill+0x18>
20403e78:	0007a703          	lw	a4,0(a5)
20403e7c:	00075463          	bgez	a4,20403e84 <uart_sifive_fifo_fill+0x1c>
		uart->tx = (int)tx_data[i];

	return i;
}
20403e80:	00008067          	ret
		uart->tx = (int)tx_data[i];
20403e84:	00a58733          	add	a4,a1,a0
20403e88:	00074703          	lbu	a4,0(a4) # 2000 <__kernel_ram_size+0x70>
	for (i = 0; i < size && !(uart->tx & TXDATA_FULL); i++)
20403e8c:	00150513          	addi	a0,a0,1
		uart->tx = (int)tx_data[i];
20403e90:	00e7a023          	sw	a4,0(a5)
	for (i = 0; i < size && !(uart->tx & TXDATA_FULL); i++)
20403e94:	fe1ff06f          	j	20403e74 <uart_sifive_fifo_fill+0xc>

20403e98 <uart_sifive_fifo_read>:
 */
static int uart_sifive_fifo_read(const struct device *dev,
				 uint8_t *rx_data,
				 const int size)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403e98:	00452783          	lw	a5,4(a0)
	int i;
	uint32_t val;

	for (i = 0; i < size; i++) {
20403e9c:	00000513          	li	a0,0
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403ea0:	0007a703          	lw	a4,0(a5)
	for (i = 0; i < size; i++) {
20403ea4:	00c54463          	blt	a0,a2,20403eac <uart_sifive_fifo_read+0x14>

		rx_data[i] = (uint8_t)(val & RXDATA_MASK);
	}

	return i;
}
20403ea8:	00008067          	ret
		val = uart->rx;
20403eac:	00472783          	lw	a5,4(a4)
		if (val & RXDATA_EMPTY)
20403eb0:	fe07cce3          	bltz	a5,20403ea8 <uart_sifive_fifo_read+0x10>
		rx_data[i] = (uint8_t)(val & RXDATA_MASK);
20403eb4:	00a586b3          	add	a3,a1,a0
20403eb8:	00f68023          	sb	a5,0(a3)
	for (i = 0; i < size; i++) {
20403ebc:	00150513          	addi	a0,a0,1
20403ec0:	fe5ff06f          	j	20403ea4 <uart_sifive_fifo_read+0xc>

20403ec4 <uart_sifive_irq_tx_enable>:
 *
 * @return N/A
 */
static void uart_sifive_irq_tx_enable(const struct device *dev)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403ec4:	00452783          	lw	a5,4(a0)
20403ec8:	0007a703          	lw	a4,0(a5)

	uart->ie |= IE_TXWM;
20403ecc:	01072783          	lw	a5,16(a4)
20403ed0:	0017e793          	ori	a5,a5,1
20403ed4:	00f72823          	sw	a5,16(a4)
}
20403ed8:	00008067          	ret

20403edc <uart_sifive_irq_tx_disable>:
 *
 * @return N/A
 */
static void uart_sifive_irq_tx_disable(const struct device *dev)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403edc:	00452783          	lw	a5,4(a0)
20403ee0:	0007a703          	lw	a4,0(a5)

	uart->ie &= ~IE_TXWM;
20403ee4:	01072783          	lw	a5,16(a4)
20403ee8:	ffe7f793          	andi	a5,a5,-2
20403eec:	00f72823          	sw	a5,16(a4)
}
20403ef0:	00008067          	ret

20403ef4 <uart_sifive_irq_tx_ready>:
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_sifive_irq_tx_ready(const struct device *dev)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403ef4:	00452783          	lw	a5,4(a0)
20403ef8:	0007a783          	lw	a5,0(a5)

	return !!(uart->ip & IE_TXWM);
20403efc:	0147a503          	lw	a0,20(a5)
}
20403f00:	00157513          	andi	a0,a0,1
20403f04:	00008067          	ret

20403f08 <uart_sifive_irq_tx_complete>:
 *
 * @return 1 if nothing remains to be transmitted, 0 otherwise
 */
static int uart_sifive_irq_tx_complete(const struct device *dev)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403f08:	00452783          	lw	a5,4(a0)
20403f0c:	0007a783          	lw	a5,0(a5)

	/*
	 * No TX EMPTY flag for this controller,
	 * just check if TX FIFO is not full
	 */
	return !(uart->tx & TXDATA_FULL);
20403f10:	0007a503          	lw	a0,0(a5)
20403f14:	fff54513          	not	a0,a0
}
20403f18:	01f55513          	srli	a0,a0,0x1f
20403f1c:	00008067          	ret

20403f20 <uart_sifive_irq_rx_enable>:
 *
 * @return N/A
 */
static void uart_sifive_irq_rx_enable(const struct device *dev)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403f20:	00452783          	lw	a5,4(a0)
20403f24:	0007a703          	lw	a4,0(a5)

	uart->ie |= IE_RXWM;
20403f28:	01072783          	lw	a5,16(a4)
20403f2c:	0027e793          	ori	a5,a5,2
20403f30:	00f72823          	sw	a5,16(a4)
}
20403f34:	00008067          	ret

20403f38 <uart_sifive_irq_rx_disable>:
 *
 * @return N/A
 */
static void uart_sifive_irq_rx_disable(const struct device *dev)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403f38:	00452783          	lw	a5,4(a0)
20403f3c:	0007a703          	lw	a4,0(a5)

	uart->ie &= ~IE_RXWM;
20403f40:	01072783          	lw	a5,16(a4)
20403f44:	ffd7f793          	andi	a5,a5,-3
20403f48:	00f72823          	sw	a5,16(a4)
}
20403f4c:	00008067          	ret

20403f50 <uart_sifive_irq_rx_ready>:
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_sifive_irq_rx_ready(const struct device *dev)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403f50:	00452783          	lw	a5,4(a0)
20403f54:	0007a783          	lw	a5,0(a5)

	return !!(uart->ip & IE_RXWM);
20403f58:	0147a503          	lw	a0,20(a5)
20403f5c:	00155513          	srli	a0,a0,0x1
}
20403f60:	00157513          	andi	a0,a0,1
20403f64:	00008067          	ret

20403f68 <uart_sifive_irq_err_enable>:

/* No error interrupt for this controller */
static void uart_sifive_irq_err_enable(const struct device *dev)
{
	ARG_UNUSED(dev);
}
20403f68:	00008067          	ret

20403f6c <uart_sifive_irq_is_pending>:
 *
 * @return 1 if an IRQ is pending, 0 otherwise
 */
static int uart_sifive_irq_is_pending(const struct device *dev)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403f6c:	00452783          	lw	a5,4(a0)
20403f70:	0007a783          	lw	a5,0(a5)

	return !!(uart->ip & (IE_RXWM | IE_TXWM));
20403f74:	0147a503          	lw	a0,20(a5)
20403f78:	00357513          	andi	a0,a0,3
}
20403f7c:	00a03533          	snez	a0,a0
20403f80:	00008067          	ret

20403f84 <uart_sifive_irq_update>:

static int uart_sifive_irq_update(const struct device *dev)
{
	return 1;
}
20403f84:	00100513          	li	a0,1
20403f88:	00008067          	ret

20403f8c <uart_sifive_irq_callback_set>:
 */
static void uart_sifive_irq_callback_set(const struct device *dev,
					 uart_irq_callback_user_data_t cb,
					 void *cb_data)
{
	struct uart_sifive_data *data = DEV_DATA(dev);
20403f8c:	01052783          	lw	a5,16(a0)

	data->callback = cb;
20403f90:	00b7a023          	sw	a1,0(a5)
	data->cb_data = cb_data;
20403f94:	00c7a223          	sw	a2,4(a5)
}
20403f98:	00008067          	ret

20403f9c <uart_sifive_irq_handler>:

static void uart_sifive_irq_handler(const struct device *dev)
{
	struct uart_sifive_data *data = DEV_DATA(dev);
20403f9c:	01052703          	lw	a4,16(a0)

	if (data->callback)
20403fa0:	00072783          	lw	a5,0(a4)
20403fa4:	00078663          	beqz	a5,20403fb0 <uart_sifive_irq_handler+0x14>
		data->callback(dev, data->cb_data);
20403fa8:	00472583          	lw	a1,4(a4)
20403fac:	00078067          	jr	a5
}
20403fb0:	00008067          	ret

20403fb4 <uart_sifive_init>:
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */


static int uart_sifive_init(const struct device *dev)
{
	const struct uart_sifive_device_config * const cfg = DEV_CFG(dev);
20403fb4:	00452683          	lw	a3,4(a0)
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);

	/* Enable TX and RX channels */
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20403fb8:	000705b7          	lui	a1,0x70
{
20403fbc:	ff010113          	addi	sp,sp,-16
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20403fc0:	0106a703          	lw	a4,16(a3)
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20403fc4:	00c6a783          	lw	a5,12(a3)
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20403fc8:	0006a603          	lw	a2,0(a3)
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20403fcc:	01071713          	slli	a4,a4,0x10
20403fd0:	00b77733          	and	a4,a4,a1
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20403fd4:	01079793          	slli	a5,a5,0x10
{
20403fd8:	00112623          	sw	ra,12(sp)
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20403fdc:	00176713          	ori	a4,a4,1
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20403fe0:	00b7f7b3          	and	a5,a5,a1
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20403fe4:	00e62423          	sw	a4,8(a2)
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20403fe8:	0017e793          	ori	a5,a5,1

	/* Set baud rate */
	uart->div = cfg->sys_clk_freq / cfg->baud_rate - 1;
20403fec:	0086a703          	lw	a4,8(a3)
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20403ff0:	00f62623          	sw	a5,12(a2)
	uart->div = cfg->sys_clk_freq / cfg->baud_rate - 1;
20403ff4:	0046a783          	lw	a5,4(a3)
20403ff8:	02e7d7b3          	divu	a5,a5,a4
20403ffc:	fff78793          	addi	a5,a5,-1
20404000:	00f62c23          	sw	a5,24(a2)
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	/* Ensure that uart IRQ is disabled initially */
	uart->ie = 0U;

	/* Setup IRQ handler */
	cfg->cfg_func();
20404004:	0146a783          	lw	a5,20(a3)
	uart->ie = 0U;
20404008:	00062823          	sw	zero,16(a2)
	cfg->cfg_func();
2040400c:	000780e7          	jalr	a5
#endif

	return 0;
}
20404010:	00c12083          	lw	ra,12(sp)
20404014:	00000513          	li	a0,0
20404018:	01010113          	addi	sp,sp,16
2040401c:	00008067          	ret

20404020 <uart_sifive_irq_cfg_func_0>:
		    PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,
		    (void *)&uart_sifive_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void uart_sifive_irq_cfg_func_0(void)
{
20404020:	ff010113          	addi	sp,sp,-16
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
20404024:	40b00513          	li	a0,1035
20404028:	00100593          	li	a1,1
{
2040402c:	00112623          	sw	ra,12(sp)
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
20404030:	fc8fe0ef          	jal	ra,204027f8 <arch_irq_priority_set>
		    uart_sifive_irq_handler, DEVICE_DT_INST_GET(0),
		    0);

	irq_enable(DT_INST_IRQN(0));
}
20404034:	00c12083          	lw	ra,12(sp)
	irq_enable(DT_INST_IRQN(0));
20404038:	40b00513          	li	a0,1035
}
2040403c:	01010113          	addi	sp,sp,16
	irq_enable(DT_INST_IRQN(0));
20404040:	f70fe06f          	j	204027b0 <arch_irq_enable>

20404044 <uart_sifive_irq_err_disable>:
20404044:	00008067          	ret

20404048 <mtime>:
	volatile uint32_t *r = (uint32_t *)RISCV_MTIME_BASE;
	uint32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
20404048:	0200c7b7          	lui	a5,0x200c
2040404c:	ffc7a703          	lw	a4,-4(a5) # 200bffc <__rom_region_size+0x2002d40>
		lo = r[0];
20404050:	ff87a503          	lw	a0,-8(a5)
	} while (r[1] != hi);
20404054:	ffc7a583          	lw	a1,-4(a5)
20404058:	fee59ae3          	bne	a1,a4,2040404c <mtime+0x4>

	return (((uint64_t)hi) << 32) | lo;
#endif
}
2040405c:	00008067          	ret

20404060 <timer_isr>:

static void timer_isr(const void *arg)
{
20404060:	fe010113          	addi	sp,sp,-32
20404064:	01212823          	sw	s2,16(sp)
20404068:	00112e23          	sw	ra,28(sp)
2040406c:	00812c23          	sw	s0,24(sp)
20404070:	00912a23          	sw	s1,20(sp)
20404074:	01312623          	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20404078:	00800913          	li	s2,8
2040407c:	30093973          	csrrc	s2,mstatus,s2
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20404080:	800004b7          	lui	s1,0x80000
20404084:	02048513          	addi	a0,s1,32 # 80000020 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000021>
	key = (mstatus & MSTATUS_IEN);
20404088:	00897913          	andi	s2,s2,8
2040408c:	241000ef          	jal	ra,20404acc <z_spin_lock_valid>
20404090:	04051063          	bnez	a0,204040d0 <timer_isr+0x70>
20404094:	20409437          	lui	s0,0x20409
20404098:	204095b7          	lui	a1,0x20409
2040409c:	20408537          	lui	a0,0x20408
204040a0:	08100693          	li	a3,129
204040a4:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204040a8:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
204040ac:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204040b0:	f79fc0ef          	jal	ra,20401028 <printk>
204040b4:	20409537          	lui	a0,0x20409
204040b8:	02048593          	addi	a1,s1,32
204040bc:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204040c0:	f69fc0ef          	jal	ra,20401028 <printk>
204040c4:	08100593          	li	a1,129
204040c8:	a9040513          	addi	a0,s0,-1392
204040cc:	ea0fe0ef          	jal	ra,2040276c <assert_post_action>
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
204040d0:	02048513          	addi	a0,s1,32
204040d4:	251000ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
204040d8:	f71ff0ef          	jal	ra,20404048 <mtime>
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
204040dc:	80000737          	lui	a4,0x80000
204040e0:	00070713          	mv	a4,a4
204040e4:	00072403          	lw	s0,0(a4) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
204040e8:	00472783          	lw	a5,4(a4)

	last_count = now;
204040ec:	00a72023          	sw	a0,0(a4)
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
204040f0:	40850433          	sub	s0,a0,s0
204040f4:	008536b3          	sltu	a3,a0,s0
204040f8:	40f587b3          	sub	a5,a1,a5
204040fc:	40d787b3          	sub	a5,a5,a3
20404100:	01879793          	slli	a5,a5,0x18
20404104:	00845413          	srli	s0,s0,0x8
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20404108:	02048513          	addi	a0,s1,32
2040410c:	0087e433          	or	s0,a5,s0
	last_count = now;
20404110:	00b72223          	sw	a1,4(a4)
20404114:	1e1000ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20404118:	04051063          	bnez	a0,20404158 <timer_isr+0xf8>
2040411c:	204099b7          	lui	s3,0x20409
20404120:	204095b7          	lui	a1,0x20409
20404124:	20408537          	lui	a0,0x20408
20404128:	0ac00693          	li	a3,172
2040412c:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404130:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20404134:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404138:	ef1fc0ef          	jal	ra,20401028 <printk>
2040413c:	20409537          	lui	a0,0x20409
20404140:	02048593          	addi	a1,s1,32
20404144:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20404148:	ee1fc0ef          	jal	ra,20401028 <printk>
2040414c:	0ac00593          	li	a1,172
20404150:	a9098513          	addi	a0,s3,-1392
20404154:	e18fe0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20404158:	30092973          	csrrs	s2,mstatus,s2
		}
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
2040415c:	00040513          	mv	a0,s0
}
20404160:	01812403          	lw	s0,24(sp)
20404164:	01c12083          	lw	ra,28(sp)
20404168:	01412483          	lw	s1,20(sp)
2040416c:	01012903          	lw	s2,16(sp)
20404170:	00c12983          	lw	s3,12(sp)
20404174:	02010113          	addi	sp,sp,32
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
20404178:	2bc0306f          	j	20407434 <sys_clock_announce>

2040417c <sys_clock_driver_init>:
{
	return (mtime() << CONFIG_RISCV_MACHINE_TIMER_SYSTEM_CLOCK_DIVIDER);
}

static int sys_clock_driver_init(const struct device *dev)
{
2040417c:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(dev);

	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
20404180:	00000593          	li	a1,0
20404184:	00700513          	li	a0,7
{
20404188:	00112623          	sw	ra,12(sp)
	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
2040418c:	e6cfe0ef          	jal	ra,204027f8 <arch_irq_priority_set>
	last_count = mtime();
20404190:	eb9ff0ef          	jal	ra,20404048 <mtime>
20404194:	800007b7          	lui	a5,0x80000
20404198:	00078793          	mv	a5,a5
2040419c:	00a7a023          	sw	a0,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
204041a0:	00b7a223          	sw	a1,4(a5)
	set_mtimecmp(last_count + CYC_PER_TICK);
204041a4:	10050713          	addi	a4,a0,256
	r[1] = 0xffffffff;
204041a8:	020047b7          	lui	a5,0x2004
204041ac:	fff00693          	li	a3,-1
204041b0:	00d7a223          	sw	a3,4(a5) # 2004004 <__rom_region_size+0x1ffad48>
	set_mtimecmp(last_count + CYC_PER_TICK);
204041b4:	00a73533          	sltu	a0,a4,a0
204041b8:	00b50533          	add	a0,a0,a1
	r[0] = (uint32_t)time;
204041bc:	00e7a023          	sw	a4,0(a5)
	r[1] = (uint32_t)(time >> 32);
204041c0:	00a7a223          	sw	a0,4(a5)
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
204041c4:	00700513          	li	a0,7
204041c8:	de8fe0ef          	jal	ra,204027b0 <arch_irq_enable>
	return 0;
}
204041cc:	00c12083          	lw	ra,12(sp)
204041d0:	00000513          	li	a0,0
204041d4:	01010113          	addi	sp,sp,16
204041d8:	00008067          	ret

204041dc <sys_clock_set_timeout>:
	if (idle) {
204041dc:	18059263          	bnez	a1,20404360 <sys_clock_set_timeout+0x184>
{
204041e0:	fe010113          	addi	sp,sp,-32
204041e4:	00112e23          	sw	ra,28(sp)
204041e8:	00812c23          	sw	s0,24(sp)
204041ec:	00912a23          	sw	s1,20(sp)
204041f0:	01212823          	sw	s2,16(sp)
204041f4:	01312623          	sw	s3,12(sp)
	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
204041f8:	fff00793          	li	a5,-1
204041fc:	14f51663          	bne	a0,a5,20404348 <sys_clock_set_timeout+0x16c>
20404200:	00800437          	lui	s0,0x800
20404204:	ffd40413          	addi	s0,s0,-3 # 7ffffd <__rom_region_size+0x7f6d41>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
20404208:	008007b7          	lui	a5,0x800
2040420c:	ffd78713          	addi	a4,a5,-3 # 7ffffd <__rom_region_size+0x7f6d41>
20404210:	14874463          	blt	a4,s0,20404358 <sys_clock_set_timeout+0x17c>
	__asm__ volatile ("csrrc %0, mstatus, %1"
20404214:	00800913          	li	s2,8
20404218:	30093973          	csrrc	s2,mstatus,s2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
2040421c:	800004b7          	lui	s1,0x80000
20404220:	02048513          	addi	a0,s1,32 # 80000020 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000021>
	key = (mstatus & MSTATUS_IEN);
20404224:	00897913          	andi	s2,s2,8
20404228:	0a5000ef          	jal	ra,20404acc <z_spin_lock_valid>
2040422c:	04051063          	bnez	a0,2040426c <sys_clock_set_timeout+0x90>
20404230:	204099b7          	lui	s3,0x20409
20404234:	204095b7          	lui	a1,0x20409
20404238:	20408537          	lui	a0,0x20408
2040423c:	08100693          	li	a3,129
20404240:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404244:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20404248:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040424c:	dddfc0ef          	jal	ra,20401028 <printk>
20404250:	20409537          	lui	a0,0x20409
20404254:	02048593          	addi	a1,s1,32
20404258:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
2040425c:	dcdfc0ef          	jal	ra,20401028 <printk>
20404260:	08100593          	li	a1,129
20404264:	a9098513          	addi	a0,s3,-1392
20404268:	d04fe0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
2040426c:	02048513          	addi	a0,s1,32
20404270:	0b5000ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	uint64_t now = mtime();
20404274:	dd5ff0ef          	jal	ra,20404048 <mtime>
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
20404278:	800007b7          	lui	a5,0x80000
2040427c:	00078793          	mv	a5,a5
20404280:	0007a703          	lw	a4,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
20404284:	0047a603          	lw	a2,4(a5)
	if (cyc <= MAX_CYC - adj) {
20404288:	800007b7          	lui	a5,0x80000
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
2040428c:	40e506b3          	sub	a3,a0,a4
20404290:	0ff68693          	addi	a3,a3,255
	if (cyc <= MAX_CYC - adj) {
20404294:	fff7c793          	not	a5,a5
	uint32_t adj, cyc = ticks * CYC_PER_TICK;
20404298:	00841413          	slli	s0,s0,0x8
	if (cyc <= MAX_CYC - adj) {
2040429c:	40d785b3          	sub	a1,a5,a3
204042a0:	0085e463          	bltu	a1,s0,204042a8 <sys_clock_set_timeout+0xcc>
		cyc += adj;
204042a4:	00d407b3          	add	a5,s0,a3
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
204042a8:	f007f793          	andi	a5,a5,-256
	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
204042ac:	40a70533          	sub	a0,a4,a0
204042b0:	00f50533          	add	a0,a0,a5
204042b4:	3e700693          	li	a3,999
204042b8:	00a6c463          	blt	a3,a0,204042c0 <sys_clock_set_timeout+0xe4>
		cyc += CYC_PER_TICK;
204042bc:	10078793          	addi	a5,a5,256 # 80000100 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000101>
	set_mtimecmp(cyc + last_count);
204042c0:	00e78733          	add	a4,a5,a4
204042c4:	00f737b3          	sltu	a5,a4,a5
	r[1] = 0xffffffff;
204042c8:	020046b7          	lui	a3,0x2004
	set_mtimecmp(cyc + last_count);
204042cc:	00c787b3          	add	a5,a5,a2
	r[1] = 0xffffffff;
204042d0:	fff00613          	li	a2,-1
204042d4:	00c6a223          	sw	a2,4(a3) # 2004004 <__rom_region_size+0x1ffad48>
	r[0] = (uint32_t)time;
204042d8:	00e6a023          	sw	a4,0(a3)
	r[1] = (uint32_t)(time >> 32);
204042dc:	00f6a223          	sw	a5,4(a3)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204042e0:	02048513          	addi	a0,s1,32
204042e4:	011000ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204042e8:	04051063          	bnez	a0,20404328 <sys_clock_set_timeout+0x14c>
204042ec:	20409437          	lui	s0,0x20409
204042f0:	204095b7          	lui	a1,0x20409
204042f4:	20408537          	lui	a0,0x20408
204042f8:	0ac00693          	li	a3,172
204042fc:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404300:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20404304:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404308:	d21fc0ef          	jal	ra,20401028 <printk>
2040430c:	20409537          	lui	a0,0x20409
20404310:	02048593          	addi	a1,s1,32
20404314:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20404318:	d11fc0ef          	jal	ra,20401028 <printk>
2040431c:	0ac00593          	li	a1,172
20404320:	a9040513          	addi	a0,s0,-1392
20404324:	c48fe0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20404328:	30092973          	csrrs	s2,mstatus,s2
}
2040432c:	01c12083          	lw	ra,28(sp)
20404330:	01812403          	lw	s0,24(sp)
20404334:	01412483          	lw	s1,20(sp)
20404338:	01012903          	lw	s2,16(sp)
2040433c:	00c12983          	lw	s3,12(sp)
20404340:	02010113          	addi	sp,sp,32
20404344:	00008067          	ret
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
20404348:	fff50413          	addi	s0,a0,-1
2040434c:	ea804ee3          	bgtz	s0,20404208 <sys_clock_set_timeout+0x2c>
20404350:	00000413          	li	s0,0
20404354:	ec1ff06f          	j	20404214 <sys_clock_set_timeout+0x38>
20404358:	ffe78413          	addi	s0,a5,-2
2040435c:	eb9ff06f          	j	20404214 <sys_clock_set_timeout+0x38>
20404360:	00008067          	ret

20404364 <sys_clock_elapsed>:
{
20404364:	fe010113          	addi	sp,sp,-32
20404368:	00112e23          	sw	ra,28(sp)
2040436c:	00812c23          	sw	s0,24(sp)
20404370:	00912a23          	sw	s1,20(sp)
20404374:	01212823          	sw	s2,16(sp)
20404378:	01312623          	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
2040437c:	00800793          	li	a5,8
20404380:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20404384:	80000437          	lui	s0,0x80000
20404388:	02040513          	addi	a0,s0,32 # 80000020 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000021>
	key = (mstatus & MSTATUS_IEN);
2040438c:	0087f993          	andi	s3,a5,8
20404390:	73c000ef          	jal	ra,20404acc <z_spin_lock_valid>
20404394:	04051063          	bnez	a0,204043d4 <sys_clock_elapsed+0x70>
20404398:	204094b7          	lui	s1,0x20409
2040439c:	204095b7          	lui	a1,0x20409
204043a0:	20408537          	lui	a0,0x20408
204043a4:	08100693          	li	a3,129
204043a8:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204043ac:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
204043b0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204043b4:	c75fc0ef          	jal	ra,20401028 <printk>
204043b8:	20409537          	lui	a0,0x20409
204043bc:	02040593          	addi	a1,s0,32
204043c0:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204043c4:	c65fc0ef          	jal	ra,20401028 <printk>
204043c8:	08100593          	li	a1,129
204043cc:	a9048513          	addi	a0,s1,-1392
204043d0:	b9cfe0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
204043d4:	02040513          	addi	a0,s0,32
204043d8:	74c000ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	uint32_t ret = ((uint32_t)mtime() - (uint32_t)last_count) / CYC_PER_TICK;
204043dc:	c6dff0ef          	jal	ra,20404048 <mtime>
204043e0:	800007b7          	lui	a5,0x80000
204043e4:	0007a483          	lw	s1,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
204043e8:	409504b3          	sub	s1,a0,s1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204043ec:	02040513          	addi	a0,s0,32
204043f0:	0084d493          	srli	s1,s1,0x8
204043f4:	700000ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204043f8:	04051063          	bnez	a0,20404438 <sys_clock_elapsed+0xd4>
204043fc:	20409937          	lui	s2,0x20409
20404400:	204095b7          	lui	a1,0x20409
20404404:	20408537          	lui	a0,0x20408
20404408:	0ac00693          	li	a3,172
2040440c:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404410:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20404414:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404418:	c11fc0ef          	jal	ra,20401028 <printk>
2040441c:	20409537          	lui	a0,0x20409
20404420:	02040593          	addi	a1,s0,32
20404424:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20404428:	c01fc0ef          	jal	ra,20401028 <printk>
2040442c:	0ac00593          	li	a1,172
20404430:	a9090513          	addi	a0,s2,-1392
20404434:	b38fe0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20404438:	3009a7f3          	csrrs	a5,mstatus,s3
}
2040443c:	01c12083          	lw	ra,28(sp)
20404440:	01812403          	lw	s0,24(sp)
20404444:	01012903          	lw	s2,16(sp)
20404448:	00c12983          	lw	s3,12(sp)
2040444c:	00048513          	mv	a0,s1
20404450:	01412483          	lw	s1,20(sp)
20404454:	02010113          	addi	sp,sp,32
20404458:	00008067          	ret

2040445c <sys_clock_cycle_get_32>:
{
2040445c:	ff010113          	addi	sp,sp,-16
20404460:	00112623          	sw	ra,12(sp)
	return (uint32_t)(mtime() << CONFIG_RISCV_MACHINE_TIMER_SYSTEM_CLOCK_DIVIDER);
20404464:	be5ff0ef          	jal	ra,20404048 <mtime>
}
20404468:	00c12083          	lw	ra,12(sp)
2040446c:	01010113          	addi	sp,sp,16
20404470:	00008067          	ret

20404474 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
20404474:	00008067          	ret

20404478 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20404478:	00251713          	slli	a4,a0,0x2
2040447c:	204097b7          	lui	a5,0x20409
20404480:	00150513          	addi	a0,a0,1
20404484:	b1878793          	addi	a5,a5,-1256 # 20408b18 <levels.0>
20404488:	00251513          	slli	a0,a0,0x2
{
2040448c:	fe010113          	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20404490:	00e78733          	add	a4,a5,a4
20404494:	00a78533          	add	a0,a5,a0
{
20404498:	00812c23          	sw	s0,24(sp)
2040449c:	01212823          	sw	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
204044a0:	00072403          	lw	s0,0(a4)
204044a4:	00052903          	lw	s2,0(a0)
{
204044a8:	01312623          	sw	s3,12(sp)
204044ac:	00112e23          	sw	ra,28(sp)
204044b0:	00912a23          	sw	s1,20(sp)
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
204044b4:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
204044b8:	03246063          	bltu	s0,s2,204044d8 <z_sys_init_run_level+0x60>
			}
			dev->state->initialized = true;
		}
	}
}
204044bc:	01c12083          	lw	ra,28(sp)
204044c0:	01812403          	lw	s0,24(sp)
204044c4:	01412483          	lw	s1,20(sp)
204044c8:	01012903          	lw	s2,16(sp)
204044cc:	00c12983          	lw	s3,12(sp)
204044d0:	02010113          	addi	sp,sp,32
204044d4:	00008067          	ret
		const struct device *dev = entry->dev;
204044d8:	00442483          	lw	s1,4(s0)
		int rc = entry->init(dev);
204044dc:	00042783          	lw	a5,0(s0)
204044e0:	00048513          	mv	a0,s1
204044e4:	000780e7          	jalr	a5
		if (dev != NULL) {
204044e8:	02048863          	beqz	s1,20404518 <z_sys_init_run_level+0xa0>
				dev->state->init_res = rc;
204044ec:	00c4a783          	lw	a5,12(s1)
			if (rc != 0) {
204044f0:	00050e63          	beqz	a0,2040450c <z_sys_init_run_level+0x94>
				if (rc < 0) {
204044f4:	41f55713          	srai	a4,a0,0x1f
204044f8:	00a74533          	xor	a0,a4,a0
204044fc:	40e50533          	sub	a0,a0,a4
				dev->state->init_res = rc;
20404500:	00a9d463          	bge	s3,a0,20404508 <z_sys_init_run_level+0x90>
20404504:	0ff00513          	li	a0,255
20404508:	00a78023          	sb	a0,0(a5)
			dev->state->initialized = true;
2040450c:	0007d703          	lhu	a4,0(a5)
20404510:	10076713          	ori	a4,a4,256
20404514:	00e79023          	sh	a4,0(a5)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20404518:	00840413          	addi	s0,s0,8
2040451c:	f9dff06f          	j	204044b8 <z_sys_init_run_level+0x40>

20404520 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
20404520:	00050e63          	beqz	a0,2040453c <z_device_ready+0x1c>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
20404524:	00c52783          	lw	a5,12(a0)
20404528:	0007a503          	lw	a0,0(a5)
2040452c:	1ff57513          	andi	a0,a0,511
20404530:	f0050513          	addi	a0,a0,-256
20404534:	00153513          	seqz	a0,a0
20404538:	00008067          	ret
		return false;
2040453c:	00000513          	li	a0,0
}
20404540:	00008067          	ret

20404544 <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20404544:	00800793          	li	a5,8
20404548:	3007b7f3          	csrrc	a5,mstatus,a5
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
2040454c:	0000006f          	j	2040454c <arch_system_halt+0x8>

20404550 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
20404550:	ff010113          	addi	sp,sp,-16
20404554:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
20404558:	fedff0ef          	jal	ra,20404544 <arch_system_halt>

2040455c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
2040455c:	fe010113          	addi	sp,sp,-32
20404560:	00812c23          	sw	s0,24(sp)
20404564:	00912a23          	sw	s1,20(sp)
20404568:	00112e23          	sw	ra,28(sp)
2040456c:	01212823          	sw	s2,16(sp)
20404570:	00050493          	mv	s1,a0
20404574:	00b12623          	sw	a1,12(sp)
20404578:	00800413          	li	s0,8
2040457c:	30043473          	csrrc	s0,mstatus,s0
	key = (mstatus & MSTATUS_IEN);
20404580:	00847413          	andi	s0,s0,8
	return z_impl_z_current_get();
20404584:	6c0020ef          	jal	ra,20406c44 <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
20404588:	00c12583          	lw	a1,12(sp)
2040458c:	00050913          	mv	s2,a0
20404590:	00048513          	mv	a0,s1
20404594:	fbdff0ef          	jal	ra,20404550 <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
20404598:	00400793          	li	a5,4
2040459c:	02f49e63          	bne	s1,a5,204045d8 <z_fatal_error+0x7c>
204045a0:	204094b7          	lui	s1,0x20409
204045a4:	204095b7          	lui	a1,0x20409
204045a8:	20408537          	lui	a0,0x20408
204045ac:	b5058593          	addi	a1,a1,-1200 # 20408b50 <levels.0+0x38>
204045b0:	08f00693          	li	a3,143
204045b4:	b2c48613          	addi	a2,s1,-1236 # 20408b2c <levels.0+0x14>
204045b8:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204045bc:	a6dfc0ef          	jal	ra,20401028 <printk>
204045c0:	20409537          	lui	a0,0x20409
204045c4:	b7050513          	addi	a0,a0,-1168 # 20408b70 <levels.0+0x58>
204045c8:	a61fc0ef          	jal	ra,20401028 <printk>
204045cc:	08f00593          	li	a1,143
204045d0:	b2c48513          	addi	a0,s1,-1236
204045d4:	998fe0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204045d8:	30042473          	csrrs	s0,mstatus,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
204045dc:	01812403          	lw	s0,24(sp)
204045e0:	01c12083          	lw	ra,28(sp)
204045e4:	01412483          	lw	s1,20(sp)
	z_impl_k_thread_abort(thread);
204045e8:	00090513          	mv	a0,s2
204045ec:	01012903          	lw	s2,16(sp)
204045f0:	02010113          	addi	sp,sp,32
204045f4:	07d0206f          	j	20406e70 <z_impl_k_thread_abort>

204045f8 <init_idle_thread>:
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
204045f8:	01800693          	li	a3,24
204045fc:	02d506b3          	mul	a3,a0,a3
{
20404600:	fe010113          	addi	sp,sp,-32
20404604:	00812c23          	sw	s0,24(sp)
	z_setup_new_thread(thread, stack,
20404608:	80000737          	lui	a4,0x80000
	struct k_thread *thread = &z_idle_threads[i];
2040460c:	80000437          	lui	s0,0x80000
	k_thread_stack_t *stack = z_idle_stacks[i];
20404610:	00951313          	slli	t1,a0,0x9
	struct k_thread *thread = &z_idle_threads[i];
20404614:	1c040413          	addi	s0,s0,448 # 800001c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800001c1>
20404618:	00751513          	slli	a0,a0,0x7
	z_setup_new_thread(thread, stack,
2040461c:	2cc70713          	addi	a4,a4,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20404620:	800015b7          	lui	a1,0x80001
	struct k_thread *thread = &z_idle_threads[i];
20404624:	00a40433          	add	s0,s0,a0
	z_setup_new_thread(thread, stack,
20404628:	00100793          	li	a5,1
2040462c:	00d70733          	add	a4,a4,a3
20404630:	2f058593          	addi	a1,a1,752 # 800012f0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800012f1>
20404634:	204056b7          	lui	a3,0x20405
20404638:	00f12023          	sw	a5,0(sp)
2040463c:	00012223          	sw	zero,4(sp)
20404640:	00000793          	li	a5,0
20404644:	00040513          	mv	a0,s0
20404648:	00f00893          	li	a7,15
2040464c:	00000813          	li	a6,0
20404650:	b4068693          	addi	a3,a3,-1216 # 20404b40 <idle>
20404654:	20000613          	li	a2,512
20404658:	006585b3          	add	a1,a1,t1
{
2040465c:	00112e23          	sw	ra,28(sp)
	z_setup_new_thread(thread, stack,
20404660:	178000ef          	jal	ra,204047d8 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
20404664:	00d44783          	lbu	a5,13(s0)
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
20404668:	01c12083          	lw	ra,28(sp)
2040466c:	ffb7f793          	andi	a5,a5,-5
20404670:	00f406a3          	sb	a5,13(s0)
20404674:	01812403          	lw	s0,24(sp)
20404678:	02010113          	addi	sp,sp,32
2040467c:	00008067          	ret

20404680 <bg_thread_main>:
{
20404680:	ff010113          	addi	sp,sp,-16
	z_sys_post_kernel = true;
20404684:	800007b7          	lui	a5,0x80000
20404688:	00100713          	li	a4,1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
2040468c:	00200513          	li	a0,2
{
20404690:	00112623          	sw	ra,12(sp)
	z_sys_post_kernel = true;
20404694:	02e78e23          	sb	a4,60(a5) # 8000003c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000003d>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
20404698:	de1ff0ef          	jal	ra,20404478 <z_sys_init_run_level>
	boot_banner();
2040469c:	460030ef          	jal	ra,20407afc <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
204046a0:	00300513          	li	a0,3
204046a4:	dd5ff0ef          	jal	ra,20404478 <z_sys_init_run_level>
	z_init_static_threads();
204046a8:	270000ef          	jal	ra,20404918 <z_init_static_threads>
	main();
204046ac:	448030ef          	jal	ra,20407af4 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
204046b0:	800007b7          	lui	a5,0x80000
204046b4:	24078793          	addi	a5,a5,576 # 80000240 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000241>
204046b8:	00c7c703          	lbu	a4,12(a5)
204046bc:	ffe77713          	andi	a4,a4,-2
204046c0:	00e78623          	sb	a4,12(a5)
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
204046c4:	00c12083          	lw	ra,12(sp)
204046c8:	01010113          	addi	sp,sp,16
204046cc:	00008067          	ret

204046d0 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
204046d0:	80000537          	lui	a0,0x80000
204046d4:	800007b7          	lui	a5,0x80000
204046d8:	00050613          	mv	a2,a0
204046dc:	2f078793          	addi	a5,a5,752 # 800002f0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002f1>
204046e0:	40c78633          	sub	a2,a5,a2
204046e4:	00000593          	li	a1,0
204046e8:	00050513          	mv	a0,a0
204046ec:	b34fe06f          	j	20402a20 <memset>

204046f0 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
204046f0:	f6010113          	addi	sp,sp,-160
204046f4:	08812c23          	sw	s0,152(sp)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
204046f8:	10100793          	li	a5,257
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
204046fc:	80000437          	lui	s0,0x80000
20404700:	2cc40413          	addi	s0,s0,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
	dummy_thread->base.user_options = K_ESSENTIAL;
20404704:	00f11e23          	sh	a5,28(sp)
	_current_cpu->current = dummy_thread;
20404708:	01010793          	addi	a5,sp,16
2040470c:	08112e23          	sw	ra,156(sp)
20404710:	00f42423          	sw	a5,8(s0)
20404714:	08912a23          	sw	s1,148(sp)
20404718:	09212823          	sw	s2,144(sp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
2040471c:	d59ff0ef          	jal	ra,20404474 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
20404720:	00000513          	li	a0,0
20404724:	d55ff0ef          	jal	ra,20404478 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
20404728:	00100513          	li	a0,1
2040472c:	d4dff0ef          	jal	ra,20404478 <z_sys_init_run_level>
	z_sched_init();
20404730:	7ed010ef          	jal	ra,2040671c <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20404734:	204097b7          	lui	a5,0x20409
20404738:	ba878793          	addi	a5,a5,-1112 # 20408ba8 <levels.0+0x90>
	_kernel.ready_q.cache = &z_main_thread;
2040473c:	800004b7          	lui	s1,0x80000
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20404740:	00f12223          	sw	a5,4(sp)
20404744:	204046b7          	lui	a3,0x20404
20404748:	00100793          	li	a5,1
2040474c:	800015b7          	lui	a1,0x80001
	_kernel.ready_q.cache = &z_main_thread;
20404750:	24048913          	addi	s2,s1,576 # 80000240 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000241>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20404754:	00000893          	li	a7,0
20404758:	00000813          	li	a6,0
2040475c:	00000713          	li	a4,0
20404760:	68068693          	addi	a3,a3,1664 # 20404680 <bg_thread_main>
20404764:	40000613          	li	a2,1024
20404768:	ef058593          	addi	a1,a1,-272 # 80000ef0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000ef1>
2040476c:	00f12023          	sw	a5,0(sp)
20404770:	24048513          	addi	a0,s1,576
20404774:	00000793          	li	a5,0
	_kernel.ready_q.cache = &z_main_thread;
20404778:	01242c23          	sw	s2,24(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
2040477c:	05c000ef          	jal	ra,204047d8 <z_setup_new_thread>
20404780:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
20404784:	24048513          	addi	a0,s1,576
20404788:	ffb7f793          	andi	a5,a5,-5
2040478c:	00f906a3          	sb	a5,13(s2)
20404790:	4f0010ef          	jal	ra,20405c80 <z_ready_thread>
		init_idle_thread(i);
20404794:	00000513          	li	a0,0
20404798:	e61ff0ef          	jal	ra,204045f8 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
2040479c:	800007b7          	lui	a5,0x80000
204047a0:	1c078793          	addi	a5,a5,448 # 800001c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800001c1>
204047a4:	00f42623          	sw	a5,12(s0)
		_kernel.cpus[i].irq_stack =
204047a8:	800027b7          	lui	a5,0x80002
204047ac:	cf078793          	addi	a5,a5,-784 # 80001cf0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001cf1>
		_kernel.cpus[i].id = i;
204047b0:	00040a23          	sb	zero,20(s0)
		_kernel.cpus[i].irq_stack =
204047b4:	00f42223          	sw	a5,4(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
204047b8:	00800513          	li	a0,8
204047bc:	30053573          	csrrc	a0,mstatus,a0
	ret = arch_swap(key);
204047c0:	00857513          	andi	a0,a0,8
204047c4:	afdfb0ef          	jal	ra,204002c0 <arch_swap>

204047c8 <k_is_in_isr>:
FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf);

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
204047c8:	800007b7          	lui	a5,0x80000
204047cc:	2cc7a503          	lw	a0,716(a5) # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
204047d0:	00a03533          	snez	a0,a0
204047d4:	00008067          	ret

204047d8 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
204047d8:	fd010113          	addi	sp,sp,-48
204047dc:	02812423          	sw	s0,40(sp)
204047e0:	02912223          	sw	s1,36(sp)
204047e4:	03212023          	sw	s2,32(sp)
204047e8:	01312e23          	sw	s3,28(sp)
204047ec:	01412c23          	sw	s4,24(sp)
204047f0:	02112623          	sw	ra,44(sp)
204047f4:	00068a13          	mv	s4,a3
204047f8:	01512a23          	sw	s5,20(sp)
	char *stack_ptr;

	Z_ASSERT_VALID_PRIO(prio, entry);
204047fc:	00f00693          	li	a3,15
{
20404800:	00050413          	mv	s0,a0
20404804:	00058993          	mv	s3,a1
20404808:	00060493          	mv	s1,a2
2040480c:	00088913          	mv	s2,a7
	Z_ASSERT_VALID_PRIO(prio, entry);
20404810:	08d89e63          	bne	a7,a3,204048ac <z_setup_new_thread+0xd4>
20404814:	204056b7          	lui	a3,0x20405
20404818:	b4068693          	addi	a3,a3,-1216 # 20404b40 <idle>
2040481c:	08da1e63          	bne	s4,a3,204048b8 <z_setup_new_thread+0xe0>
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
20404820:	06840693          	addi	a3,s0,104
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
20404824:	06d42423          	sw	a3,104(s0)
	list->tail = (sys_dnode_t *)list;
20404828:	06d42623          	sw	a3,108(s0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
2040482c:	03012683          	lw	a3,48(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
20404830:	00f48493          	addi	s1,s1,15
20404834:	ff04f493          	andi	s1,s1,-16
	stack_ptr = (char *)stack + stack_obj_size;
20404838:	009984b3          	add	s1,s3,s1
	thread_base->user_options = (uint8_t)options;
2040483c:	00d40623          	sb	a3,12(s0)
	thread_base->thread_state = (uint8_t)initial_state;
20404840:	00400693          	li	a3,4
20404844:	00d406a3          	sb	a3,13(s0)

	thread_base->prio = priority;
20404848:	01240723          	sb	s2,14(s0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
2040484c:	00040513          	mv	a0,s0
	thread_base->pended_on = NULL;
20404850:	00042423          	sw	zero,8(s0)

	thread_base->sched_locked = 0U;
20404854:	000407a3          	sb	zero,15(s0)
 * @return N/A
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
20404858:	00042c23          	sw	zero,24(s0)
	node->prev = NULL;
2040485c:	00042e23          	sw	zero,28(s0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
20404860:	000a0693          	mv	a3,s4
20404864:	00048613          	mv	a2,s1
20404868:	00098593          	mv	a1,s3
2040486c:	914fe0ef          	jal	ra,20402980 <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
20404870:	800007b7          	lui	a5,0x80000
20404874:	2d47a783          	lw	a5,724(a5) # 800002d4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002d5>
}
20404878:	02c12083          	lw	ra,44(sp)
	new_thread->init_data = NULL;
2040487c:	06042223          	sw	zero,100(s0)
	new_thread->resource_pool = _current->resource_pool;
20404880:	0747a783          	lw	a5,116(a5)
}
20404884:	02012903          	lw	s2,32(sp)
20404888:	01c12983          	lw	s3,28(sp)
	new_thread->resource_pool = _current->resource_pool;
2040488c:	06f42a23          	sw	a5,116(s0)
}
20404890:	02812403          	lw	s0,40(sp)
20404894:	01812a03          	lw	s4,24(sp)
20404898:	01412a83          	lw	s5,20(sp)
2040489c:	00048513          	mv	a0,s1
204048a0:	02412483          	lw	s1,36(sp)
204048a4:	03010113          	addi	sp,sp,48
204048a8:	00008067          	ret
	Z_ASSERT_VALID_PRIO(prio, entry);
204048ac:	01088693          	addi	a3,a7,16
204048b0:	01e00613          	li	a2,30
204048b4:	f6d676e3          	bgeu	a2,a3,20404820 <z_setup_new_thread+0x48>
204048b8:	20409ab7          	lui	s5,0x20409
204048bc:	204095b7          	lui	a1,0x20409
204048c0:	20408537          	lui	a0,0x20408
204048c4:	1ff00693          	li	a3,511
204048c8:	bb0a8613          	addi	a2,s5,-1104 # 20408bb0 <levels.0+0x98>
204048cc:	bd458593          	addi	a1,a1,-1068 # 20408bd4 <levels.0+0xbc>
204048d0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204048d4:	01012623          	sw	a6,12(sp)
204048d8:	00f12423          	sw	a5,8(sp)
204048dc:	00e12223          	sw	a4,4(sp)
204048e0:	f48fc0ef          	jal	ra,20401028 <printk>
204048e4:	20409537          	lui	a0,0x20409
204048e8:	ff000693          	li	a3,-16
204048ec:	00e00613          	li	a2,14
204048f0:	00090593          	mv	a1,s2
204048f4:	c5450513          	addi	a0,a0,-940 # 20408c54 <levels.0+0x13c>
204048f8:	f30fc0ef          	jal	ra,20401028 <printk>
204048fc:	1ff00593          	li	a1,511
20404900:	bb0a8513          	addi	a0,s5,-1104
20404904:	e69fd0ef          	jal	ra,2040276c <assert_post_action>
20404908:	00c12803          	lw	a6,12(sp)
2040490c:	00812783          	lw	a5,8(sp)
20404910:	00412703          	lw	a4,4(sp)
20404914:	f0dff06f          	j	20404820 <z_setup_new_thread+0x48>

20404918 <z_init_static_threads>:
{
20404918:	fc010113          	addi	sp,sp,-64
2040491c:	02812c23          	sw	s0,56(sp)
20404920:	01812c23          	sw	s8,24(sp)
20404924:	02912a23          	sw	s1,52(sp)
20404928:	03212823          	sw	s2,48(sp)
2040492c:	03312623          	sw	s3,44(sp)
20404930:	03412423          	sw	s4,40(sp)
20404934:	03512223          	sw	s5,36(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
20404938:	83c18493          	addi	s1,gp,-1988 # 80001ed4 <_k_thread_data_blink0_id>
{
2040493c:	02112e23          	sw	ra,60(sp)
20404940:	03612023          	sw	s6,32(sp)
20404944:	01712e23          	sw	s7,28(sp)
20404948:	01912a23          	sw	s9,20(sp)
2040494c:	83c18c13          	addi	s8,gp,-1988 # 80001ed4 <_k_thread_data_blink0_id>
20404950:	8cc18413          	addi	s0,gp,-1844 # 80001f64 <_system_heap>
	_FOREACH_STATIC_THREAD(thread_data) {
20404954:	20409937          	lui	s2,0x20409
20404958:	204099b7          	lui	s3,0x20409
2040495c:	20408a37          	lui	s4,0x20408
20404960:	20409ab7          	lui	s5,0x20409
20404964:	02947663          	bgeu	s0,s1,20404990 <z_init_static_threads+0x78>
20404968:	c8898593          	addi	a1,s3,-888 # 20408c88 <levels.0+0x170>
2040496c:	2cf00693          	li	a3,719
20404970:	bb090613          	addi	a2,s2,-1104 # 20408bb0 <levels.0+0x98>
20404974:	3eca0513          	addi	a0,s4,1004 # 204083ec <__clz_tab+0x1a4>
20404978:	eb0fc0ef          	jal	ra,20401028 <printk>
2040497c:	cb8a8513          	addi	a0,s5,-840 # 20408cb8 <levels.0+0x1a0>
20404980:	ea8fc0ef          	jal	ra,20401028 <printk>
20404984:	2cf00593          	li	a1,719
20404988:	bb090513          	addi	a0,s2,-1104
2040498c:	de1fd0ef          	jal	ra,2040276c <assert_post_action>
20404990:	0884e463          	bltu	s1,s0,20404a18 <z_init_static_threads+0x100>
	k_sched_lock();
20404994:	341000ef          	jal	ra,204054d4 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
20404998:	204094b7          	lui	s1,0x20409
2040499c:	20409937          	lui	s2,0x20409
204049a0:	204089b7          	lui	s3,0x20408
204049a4:	20409a37          	lui	s4,0x20409
		if (thread_data->init_delay != K_TICKS_FOREVER) {
204049a8:	fff00a93          	li	s5,-1
204049ac:	3e700b13          	li	s6,999

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
204049b0:	20406bb7          	lui	s7,0x20406
	_FOREACH_STATIC_THREAD(thread_data) {
204049b4:	03847663          	bgeu	s0,s8,204049e0 <z_init_static_threads+0xc8>
204049b8:	c8890593          	addi	a1,s2,-888 # 20408c88 <levels.0+0x170>
204049bc:	2ee00693          	li	a3,750
204049c0:	bb048613          	addi	a2,s1,-1104 # 20408bb0 <levels.0+0x98>
204049c4:	3ec98513          	addi	a0,s3,1004 # 204083ec <__clz_tab+0x1a4>
204049c8:	e60fc0ef          	jal	ra,20401028 <printk>
204049cc:	cb8a0513          	addi	a0,s4,-840 # 20408cb8 <levels.0+0x1a0>
204049d0:	e58fc0ef          	jal	ra,20401028 <printk>
204049d4:	2ee00593          	li	a1,750
204049d8:	bb048513          	addi	a0,s1,-1104
204049dc:	d91fd0ef          	jal	ra,2040276c <assert_post_action>
204049e0:	068c6e63          	bltu	s8,s0,20404a5c <z_init_static_threads+0x144>
}
204049e4:	03812403          	lw	s0,56(sp)
204049e8:	03c12083          	lw	ra,60(sp)
204049ec:	03412483          	lw	s1,52(sp)
204049f0:	03012903          	lw	s2,48(sp)
204049f4:	02c12983          	lw	s3,44(sp)
204049f8:	02812a03          	lw	s4,40(sp)
204049fc:	02412a83          	lw	s5,36(sp)
20404a00:	02012b03          	lw	s6,32(sp)
20404a04:	01c12b83          	lw	s7,28(sp)
20404a08:	01812c03          	lw	s8,24(sp)
20404a0c:	01412c83          	lw	s9,20(sp)
20404a10:	04010113          	addi	sp,sp,64
	k_sched_unlock();
20404a14:	22d0106f          	j	20406440 <k_sched_unlock>
		z_setup_new_thread(
20404a18:	02c4a783          	lw	a5,44(s1)
20404a1c:	00f12223          	sw	a5,4(sp)
20404a20:	0204a783          	lw	a5,32(s1)
20404a24:	00f12023          	sw	a5,0(sp)
20404a28:	0144a783          	lw	a5,20(s1)
20404a2c:	01c4a883          	lw	a7,28(s1)
20404a30:	0184a803          	lw	a6,24(s1)
20404a34:	0104a703          	lw	a4,16(s1)
20404a38:	00c4a683          	lw	a3,12(s1)
20404a3c:	0084a603          	lw	a2,8(s1)
20404a40:	0044a583          	lw	a1,4(s1)
20404a44:	0004a503          	lw	a0,0(s1)
20404a48:	d91ff0ef          	jal	ra,204047d8 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
20404a4c:	0004a783          	lw	a5,0(s1)
20404a50:	0697a223          	sw	s1,100(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
20404a54:	03048493          	addi	s1,s1,48
20404a58:	f0dff06f          	j	20404964 <z_init_static_threads+0x4c>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
20404a5c:	024c2783          	lw	a5,36(s8)
20404a60:	05578063          	beq	a5,s5,20404aa0 <z_init_static_threads+0x188>
			schedule_new_thread(thread_data->init_thread,
20404a64:	000c2c83          	lw	s9,0(s8)
					    K_MSEC(thread_data->init_delay));
20404a68:	0007d463          	bgez	a5,20404a70 <z_init_static_threads+0x158>
20404a6c:	00000793          	li	a5,0
20404a70:	41f7d593          	srai	a1,a5,0x1f
20404a74:	0197d713          	srli	a4,a5,0x19
20404a78:	00779793          	slli	a5,a5,0x7
20404a7c:	00759593          	slli	a1,a1,0x7
20404a80:	3e778513          	addi	a0,a5,999
20404a84:	00b765b3          	or	a1,a4,a1
20404a88:	00f537b3          	sltu	a5,a0,a5
20404a8c:	00b785b3          	add	a1,a5,a1
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
20404a90:	01651c63          	bne	a0,s6,20404aa8 <z_init_static_threads+0x190>
20404a94:	00059a63          	bnez	a1,20404aa8 <z_init_static_threads+0x190>
	z_sched_start(thread);
20404a98:	000c8513          	mv	a0,s9
20404a9c:	2d0010ef          	jal	ra,20405d6c <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
20404aa0:	030c0c13          	addi	s8,s8,48
20404aa4:	f11ff06f          	j	204049b4 <z_init_static_threads+0x9c>
20404aa8:	3e800613          	li	a2,1000
20404aac:	00000693          	li	a3,0
20404ab0:	8d1fb0ef          	jal	ra,20400380 <__udivdi3>
20404ab4:	00050613          	mv	a2,a0
20404ab8:	00058693          	mv	a3,a1
20404abc:	018c8513          	addi	a0,s9,24
20404ac0:	e90b8593          	addi	a1,s7,-368 # 20405e90 <z_thread_timeout>
20404ac4:	4c8020ef          	jal	ra,20406f8c <z_add_timeout>
20404ac8:	fd9ff06f          	j	20404aa0 <z_init_static_threads+0x188>

20404acc <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
20404acc:	00052503          	lw	a0,0(a0)

	if (thread_cpu != 0U) {
20404ad0:	00050e63          	beqz	a0,20404aec <z_spin_lock_valid+0x20>
		if ((thread_cpu & 3U) == _current_cpu->id) {
20404ad4:	800007b7          	lui	a5,0x80000
20404ad8:	2e07c783          	lbu	a5,736(a5) # 800002e0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e1>
20404adc:	00357513          	andi	a0,a0,3
20404ae0:	40f50533          	sub	a0,a0,a5
20404ae4:	00a03533          	snez	a0,a0
20404ae8:	00008067          	ret
			return false;
		}
	}
	return true;
20404aec:	00100513          	li	a0,1
}
20404af0:	00008067          	ret

20404af4 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
20404af4:	800007b7          	lui	a5,0x80000
20404af8:	2cc78793          	addi	a5,a5,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20404afc:	0147c703          	lbu	a4,20(a5)
20404b00:	0087a783          	lw	a5,8(a5)
20404b04:	00e7e7b3          	or	a5,a5,a4
20404b08:	00052703          	lw	a4,0(a0)
20404b0c:	00f71863          	bne	a4,a5,20404b1c <z_spin_unlock_valid+0x28>
		return false;
	}
	l->thread_cpu = 0;
20404b10:	00052023          	sw	zero,0(a0)
	return true;
20404b14:	00100513          	li	a0,1
20404b18:	00008067          	ret
		return false;
20404b1c:	00000513          	li	a0,0
}
20404b20:	00008067          	ret

20404b24 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
20404b24:	800007b7          	lui	a5,0x80000
20404b28:	2cc78793          	addi	a5,a5,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20404b2c:	0147c703          	lbu	a4,20(a5)
20404b30:	0087a783          	lw	a5,8(a5)
20404b34:	00e7e7b3          	or	a5,a5,a4
20404b38:	00f52023          	sw	a5,0(a0)
}
20404b3c:	00008067          	ret

20404b40 <idle>:
{
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
20404b40:	800007b7          	lui	a5,0x80000
20404b44:	2d47a783          	lw	a5,724(a5) # 800002d4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002d5>
{
20404b48:	ff010113          	addi	sp,sp,-16
20404b4c:	00112623          	sw	ra,12(sp)
	__ASSERT_NO_MSG(_current->base.prio >= 0);
20404b50:	00e78783          	lb	a5,14(a5)
{
20404b54:	00812423          	sw	s0,8(sp)
	__ASSERT_NO_MSG(_current->base.prio >= 0);
20404b58:	0207d863          	bgez	a5,20404b88 <idle+0x48>
20404b5c:	20409437          	lui	s0,0x20409
20404b60:	204095b7          	lui	a1,0x20409
20404b64:	20408537          	lui	a0,0x20408
20404b68:	cfc58593          	addi	a1,a1,-772 # 20408cfc <levels.0+0x1e4>
20404b6c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404b70:	02700693          	li	a3,39
20404b74:	cd840613          	addi	a2,s0,-808 # 20408cd8 <levels.0+0x1c0>
20404b78:	cb0fc0ef          	jal	ra,20401028 <printk>
20404b7c:	02700593          	li	a1,39
20404b80:	cd840513          	addi	a0,s0,-808
20404b84:	be9fd0ef          	jal	ra,2040276c <assert_post_action>
20404b88:	00800413          	li	s0,8
20404b8c:	300437f3          	csrrc	a5,mstatus,s0
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
20404b90:	bfdfd0ef          	jal	ra,2040278c <arch_cpu_idle>
20404b94:	ff9ff06f          	j	20404b8c <idle+0x4c>

20404b98 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
20404b98:	fd010113          	addi	sp,sp,-48
20404b9c:	02812423          	sw	s0,40(sp)
20404ba0:	02912223          	sw	s1,36(sp)
20404ba4:	03212023          	sw	s2,32(sp)
20404ba8:	01312e23          	sw	s3,28(sp)
20404bac:	01412c23          	sw	s4,24(sp)
20404bb0:	01512a23          	sw	s5,20(sp)
20404bb4:	01612823          	sw	s6,16(sp)
20404bb8:	02112623          	sw	ra,44(sp)
20404bbc:	01712623          	sw	s7,12(sp)
20404bc0:	00050413          	mv	s0,a0
20404bc4:	00058993          	mv	s3,a1
20404bc8:	00060a13          	mv	s4,a2
20404bcc:	00068a93          	mv	s5,a3
20404bd0:	00070b13          	mv	s6,a4
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
20404bd4:	00850913          	addi	s2,a0,8
20404bd8:	00800493          	li	s1,8
20404bdc:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20404be0:	00090513          	mv	a0,s2
	key = (mstatus & MSTATUS_IEN);
20404be4:	0084f493          	andi	s1,s1,8
20404be8:	ee5ff0ef          	jal	ra,20404acc <z_spin_lock_valid>
20404bec:	04051063          	bnez	a0,20404c2c <queue_insert+0x94>
20404bf0:	20409bb7          	lui	s7,0x20409
20404bf4:	204095b7          	lui	a1,0x20409
20404bf8:	20408537          	lui	a0,0x20408
20404bfc:	08100693          	li	a3,129
20404c00:	a90b8613          	addi	a2,s7,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404c04:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20404c08:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404c0c:	c1cfc0ef          	jal	ra,20401028 <printk>
20404c10:	20409537          	lui	a0,0x20409
20404c14:	00090593          	mv	a1,s2
20404c18:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20404c1c:	c0cfc0ef          	jal	ra,20401028 <printk>
20404c20:	08100593          	li	a1,129
20404c24:	a90b8513          	addi	a0,s7,-1392
20404c28:	b45fd0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20404c2c:	00090513          	mv	a0,s2
20404c30:	ef5ff0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
20404c34:	000b0463          	beqz	s6,20404c3c <queue_insert+0xa4>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
20404c38:	00442983          	lw	s3,4(s0)
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
20404c3c:	00c40513          	addi	a0,s0,12
20404c40:	189010ef          	jal	ra,204065c8 <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
20404c44:	02050263          	beqz	a0,20404c68 <queue_insert+0xd0>
	thread->arch.swap_return_value = value;
20404c48:	06052c23          	sw	zero,120(a0)
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
20404c4c:	01452a23          	sw	s4,20(a0)
	z_ready_thread(thread);
20404c50:	030010ef          	jal	ra,20405c80 <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
20404c54:	00090513          	mv	a0,s2
20404c58:	00048593          	mv	a1,s1
20404c5c:	744000ef          	jal	ra,204053a0 <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
20404c60:	00000513          	li	a0,0
20404c64:	0640006f          	j	20404cc8 <queue_insert+0x130>
	if (alloc) {
20404c68:	0c0a8263          	beqz	s5,20404d2c <queue_insert+0x194>
	return z_thread_aligned_alloc(0, size);
20404c6c:	00800593          	li	a1,8
20404c70:	625020ef          	jal	ra,20407a94 <z_thread_aligned_alloc>
		if (anode == NULL) {
20404c74:	08051063          	bnez	a0,20404cf4 <queue_insert+0x15c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20404c78:	00090513          	mv	a0,s2
20404c7c:	e79ff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20404c80:	04051063          	bnez	a0,20404cc0 <queue_insert+0x128>
20404c84:	20409437          	lui	s0,0x20409
20404c88:	204095b7          	lui	a1,0x20409
20404c8c:	20408537          	lui	a0,0x20408
20404c90:	0ac00693          	li	a3,172
20404c94:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404c98:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20404c9c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404ca0:	b88fc0ef          	jal	ra,20401028 <printk>
20404ca4:	20409537          	lui	a0,0x20409
20404ca8:	00090593          	mv	a1,s2
20404cac:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20404cb0:	b78fc0ef          	jal	ra,20401028 <printk>
20404cb4:	0ac00593          	li	a1,172
20404cb8:	a9040513          	addi	a0,s0,-1392
20404cbc:	ab1fd0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20404cc0:	3004a4f3          	csrrs	s1,mstatus,s1
			return -ENOMEM;
20404cc4:	ff400513          	li	a0,-12
}
20404cc8:	02c12083          	lw	ra,44(sp)
20404ccc:	02812403          	lw	s0,40(sp)
20404cd0:	02412483          	lw	s1,36(sp)
20404cd4:	02012903          	lw	s2,32(sp)
20404cd8:	01c12983          	lw	s3,28(sp)
20404cdc:	01812a03          	lw	s4,24(sp)
20404ce0:	01412a83          	lw	s5,20(sp)
20404ce4:	01012b03          	lw	s6,16(sp)
20404ce8:	00c12b83          	lw	s7,12(sp)
20404cec:	03010113          	addi	sp,sp,48
20404cf0:	00008067          	ret
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
20404cf4:	00100793          	li	a5,1
		anode->data = data;
20404cf8:	01452223          	sw	s4,4(a0)
20404cfc:	00f52023          	sw	a5,0(a0)
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
20404d00:	00052783          	lw	a5,0(a0)
	parent->next_and_flags = cur_flags | (unative_t)child;
20404d04:	0037f713          	andi	a4,a5,3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
20404d08:	02099863          	bnez	s3,20404d38 <queue_insert+0x1a0>
	parent->next_and_flags = cur_flags | (unative_t)child;
20404d0c:	00042783          	lw	a5,0(s0)
20404d10:	00e7e7b3          	or	a5,a5,a4
20404d14:	00f52023          	sw	a5,0(a0)
Z_GENLIST_PREPEND(sflist, sfnode)
20404d18:	00442783          	lw	a5,4(s0)
	list->head = node;
20404d1c:	00a42023          	sw	a0,0(s0)
Z_GENLIST_PREPEND(sflist, sfnode)
20404d20:	f2079ae3          	bnez	a5,20404c54 <queue_insert+0xbc>
	list->tail = node;
20404d24:	00a42223          	sw	a0,4(s0)
}
20404d28:	f2dff06f          	j	20404c54 <queue_insert+0xbc>
	node->next_and_flags = flags;
20404d2c:	000a2023          	sw	zero,0(s4)
}
20404d30:	000a0513          	mv	a0,s4
20404d34:	fcdff06f          	j	20404d00 <queue_insert+0x168>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
20404d38:	0009a783          	lw	a5,0(s3)
20404d3c:	ffc7f793          	andi	a5,a5,-4
Z_GENLIST_INSERT(sflist, sfnode)
20404d40:	02079863          	bnez	a5,20404d70 <queue_insert+0x1d8>
	parent->next_and_flags = cur_flags | (unative_t)child;
20404d44:	00e52023          	sw	a4,0(a0)
	return list->tail;
20404d48:	00442703          	lw	a4,4(s0)
Z_GENLIST_APPEND(sflist, sfnode)
20404d4c:	00071863          	bnez	a4,20404d5c <queue_insert+0x1c4>
	list->tail = node;
20404d50:	00a42223          	sw	a0,4(s0)
	list->head = node;
20404d54:	00a42023          	sw	a0,0(s0)
}
20404d58:	efdff06f          	j	20404c54 <queue_insert+0xbc>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
20404d5c:	00072783          	lw	a5,0(a4)
	parent->next_and_flags = cur_flags | (unative_t)child;
20404d60:	0037f793          	andi	a5,a5,3
20404d64:	00f567b3          	or	a5,a0,a5
20404d68:	00f72023          	sw	a5,0(a4)
20404d6c:	fb9ff06f          	j	20404d24 <queue_insert+0x18c>
20404d70:	00e7e7b3          	or	a5,a5,a4
20404d74:	00f52023          	sw	a5,0(a0)
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
20404d78:	0009a783          	lw	a5,0(s3)
	parent->next_and_flags = cur_flags | (unative_t)child;
20404d7c:	0037f793          	andi	a5,a5,3
20404d80:	00f56533          	or	a0,a0,a5
20404d84:	00a9a023          	sw	a0,0(s3)
}
20404d88:	ecdff06f          	j	20404c54 <queue_insert+0xbc>

20404d8c <z_queue_node_peek>:
{
20404d8c:	ff010113          	addi	sp,sp,-16
20404d90:	00812423          	sw	s0,8(sp)
20404d94:	00112623          	sw	ra,12(sp)
20404d98:	00050413          	mv	s0,a0
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
20404d9c:	00050e63          	beqz	a0,20404db8 <z_queue_node_peek+0x2c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
20404da0:	00052783          	lw	a5,0(a0)
20404da4:	0037f793          	andi	a5,a5,3
20404da8:	00078863          	beqz	a5,20404db8 <z_queue_node_peek+0x2c>
		ret = anode->data;
20404dac:	00452403          	lw	s0,4(a0)
		if (needs_free) {
20404db0:	00058463          	beqz	a1,20404db8 <z_queue_node_peek+0x2c>
			k_free(anode);
20404db4:	3f5020ef          	jal	ra,204079a8 <k_free>
}
20404db8:	00c12083          	lw	ra,12(sp)
20404dbc:	00040513          	mv	a0,s0
20404dc0:	00812403          	lw	s0,8(sp)
20404dc4:	01010113          	addi	sp,sp,16
20404dc8:	00008067          	ret

20404dcc <k_queue_append>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, insert, queue);
}

void k_queue_append(struct k_queue *queue, void *data)
{
20404dcc:	00058613          	mv	a2,a1
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append, queue);

	(void)queue_insert(queue, NULL, data, false, true);
20404dd0:	00100713          	li	a4,1
20404dd4:	00000693          	li	a3,0
20404dd8:	00000593          	li	a1,0
20404ddc:	dbdff06f          	j	20404b98 <queue_insert>

20404de0 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
20404de0:	fe010113          	addi	sp,sp,-32
20404de4:	00912a23          	sw	s1,20(sp)
20404de8:	01212823          	sw	s2,16(sp)
20404dec:	01312623          	sw	s3,12(sp)
20404df0:	01412423          	sw	s4,8(sp)
20404df4:	01512223          	sw	s5,4(sp)
20404df8:	00112e23          	sw	ra,28(sp)
20404dfc:	00812c23          	sw	s0,24(sp)
20404e00:	00050913          	mv	s2,a0
20404e04:	00058a13          	mv	s4,a1
20404e08:	00060993          	mv	s3,a2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
20404e0c:	00850a93          	addi	s5,a0,8
	__asm__ volatile ("csrrc %0, mstatus, %1"
20404e10:	00800493          	li	s1,8
20404e14:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20404e18:	000a8513          	mv	a0,s5
	key = (mstatus & MSTATUS_IEN);
20404e1c:	0084f493          	andi	s1,s1,8
20404e20:	cadff0ef          	jal	ra,20404acc <z_spin_lock_valid>
20404e24:	04051063          	bnez	a0,20404e64 <z_impl_k_queue_get+0x84>
20404e28:	20409437          	lui	s0,0x20409
20404e2c:	204095b7          	lui	a1,0x20409
20404e30:	20408537          	lui	a0,0x20408
20404e34:	08100693          	li	a3,129
20404e38:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404e3c:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20404e40:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404e44:	9e4fc0ef          	jal	ra,20401028 <printk>
20404e48:	20409537          	lui	a0,0x20409
20404e4c:	000a8593          	mv	a1,s5
20404e50:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20404e54:	9d4fc0ef          	jal	ra,20401028 <printk>
20404e58:	08100593          	li	a1,129
20404e5c:	a9040513          	addi	a0,s0,-1392
20404e60:	90dfd0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20404e64:	000a8513          	mv	a0,s5
20404e68:	cbdff0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	return list->head;
20404e6c:	00092403          	lw	s0,0(s2)
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
20404e70:	0a040063          	beqz	s0,20404f10 <z_impl_k_queue_get+0x130>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
20404e74:	00042783          	lw	a5,0(s0)
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
20404e78:	00492703          	lw	a4,4(s2)
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
20404e7c:	ffc7f793          	andi	a5,a5,-4
	list->head = node;
20404e80:	00f92023          	sw	a5,0(s2)
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
20404e84:	00e41463          	bne	s0,a4,20404e8c <z_impl_k_queue_get+0xac>
	list->tail = node;
20404e88:	00f92223          	sw	a5,4(s2)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
20404e8c:	00040513          	mv	a0,s0
20404e90:	00100593          	li	a1,1
20404e94:	ef9ff0ef          	jal	ra,20404d8c <z_queue_node_peek>
20404e98:	00050413          	mv	s0,a0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20404e9c:	000a8513          	mv	a0,s5
20404ea0:	c55ff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20404ea4:	04051063          	bnez	a0,20404ee4 <z_impl_k_queue_get+0x104>
20404ea8:	20409937          	lui	s2,0x20409
20404eac:	204095b7          	lui	a1,0x20409
20404eb0:	20408537          	lui	a0,0x20408
20404eb4:	0ac00693          	li	a3,172
20404eb8:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404ebc:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20404ec0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404ec4:	964fc0ef          	jal	ra,20401028 <printk>
20404ec8:	20409537          	lui	a0,0x20409
20404ecc:	000a8593          	mv	a1,s5
20404ed0:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20404ed4:	954fc0ef          	jal	ra,20401028 <printk>
20404ed8:	0ac00593          	li	a1,172
20404edc:	a9090513          	addi	a0,s2,-1392
20404ee0:	88dfd0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20404ee4:	3004a4f3          	csrrs	s1,mstatus,s1

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
20404ee8:	01c12083          	lw	ra,28(sp)
20404eec:	00040513          	mv	a0,s0
20404ef0:	01812403          	lw	s0,24(sp)
20404ef4:	01412483          	lw	s1,20(sp)
20404ef8:	01012903          	lw	s2,16(sp)
20404efc:	00c12983          	lw	s3,12(sp)
20404f00:	00812a03          	lw	s4,8(sp)
20404f04:	00412a83          	lw	s5,4(sp)
20404f08:	02010113          	addi	sp,sp,32
20404f0c:	00008067          	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
20404f10:	013a67b3          	or	a5,s4,s3
20404f14:	f80784e3          	beqz	a5,20404e9c <z_impl_k_queue_get+0xbc>
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
20404f18:	000a0693          	mv	a3,s4
20404f1c:	00098713          	mv	a4,s3
20404f20:	00c90613          	addi	a2,s2,12
20404f24:	00048593          	mv	a1,s1
20404f28:	000a8513          	mv	a0,s5
20404f2c:	310010ef          	jal	ra,2040623c <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
20404f30:	fa051ce3          	bnez	a0,20404ee8 <z_impl_k_queue_get+0x108>
20404f34:	800007b7          	lui	a5,0x80000
20404f38:	2d47a783          	lw	a5,724(a5) # 800002d4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002d5>
20404f3c:	0147a403          	lw	s0,20(a5)
20404f40:	fa9ff06f          	j	20404ee8 <z_impl_k_queue_get+0x108>

20404f44 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
20404f44:	fe010113          	addi	sp,sp,-32
20404f48:	00912a23          	sw	s1,20(sp)
20404f4c:	00112e23          	sw	ra,28(sp)
20404f50:	00812c23          	sw	s0,24(sp)
20404f54:	01212823          	sw	s2,16(sp)
20404f58:	01312623          	sw	s3,12(sp)
20404f5c:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20404f60:	00800593          	li	a1,8
20404f64:	3005b5f3          	csrrc	a1,mstatus,a1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20404f68:	80000437          	lui	s0,0x80000
20404f6c:	02440513          	addi	a0,s0,36 # 80000024 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000025>
	key = (mstatus & MSTATUS_IEN);
20404f70:	0085f993          	andi	s3,a1,8
20404f74:	b59ff0ef          	jal	ra,20404acc <z_spin_lock_valid>
20404f78:	04051063          	bnez	a0,20404fb8 <z_impl_k_sem_give+0x74>
20404f7c:	20409937          	lui	s2,0x20409
20404f80:	204095b7          	lui	a1,0x20409
20404f84:	20408537          	lui	a0,0x20408
20404f88:	08100693          	li	a3,129
20404f8c:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20404f90:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20404f94:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20404f98:	890fc0ef          	jal	ra,20401028 <printk>
20404f9c:	20409537          	lui	a0,0x20409
20404fa0:	02440593          	addi	a1,s0,36
20404fa4:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20404fa8:	880fc0ef          	jal	ra,20401028 <printk>
20404fac:	08100593          	li	a1,129
20404fb0:	a9090513          	addi	a0,s2,-1392
20404fb4:	fb8fd0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20404fb8:	02440513          	addi	a0,s0,36
20404fbc:	b69ff0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
20404fc0:	00048513          	mv	a0,s1
20404fc4:	604010ef          	jal	ra,204065c8 <z_unpend_first_thread>

	if (thread != NULL) {
20404fc8:	02050863          	beqz	a0,20404ff8 <z_impl_k_sem_give+0xb4>
20404fcc:	06052c23          	sw	zero,120(a0)
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
20404fd0:	4b1000ef          	jal	ra,20405c80 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
20404fd4:	02440513          	addi	a0,s0,36

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
20404fd8:	01812403          	lw	s0,24(sp)
20404fdc:	01c12083          	lw	ra,28(sp)
20404fe0:	01412483          	lw	s1,20(sp)
20404fe4:	01012903          	lw	s2,16(sp)
	z_reschedule(&lock, key);
20404fe8:	00098593          	mv	a1,s3
}
20404fec:	00c12983          	lw	s3,12(sp)
20404ff0:	02010113          	addi	sp,sp,32
	z_reschedule(&lock, key);
20404ff4:	3ac0006f          	j	204053a0 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
20404ff8:	0084a703          	lw	a4,8(s1)
20404ffc:	00c4a783          	lw	a5,12(s1)
20405000:	40e787b3          	sub	a5,a5,a4
20405004:	00f037b3          	snez	a5,a5
20405008:	00e787b3          	add	a5,a5,a4
2040500c:	00f4a423          	sw	a5,8(s1)
}
20405010:	fc5ff06f          	j	20404fd4 <z_impl_k_sem_give+0x90>

20405014 <z_impl_k_sem_take>:

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
20405014:	800007b7          	lui	a5,0x80000
20405018:	2cc7a783          	lw	a5,716(a5) # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
{
2040501c:	fe010113          	addi	sp,sp,-32
20405020:	00912a23          	sw	s1,20(sp)
20405024:	01212823          	sw	s2,16(sp)
20405028:	01312623          	sw	s3,12(sp)
2040502c:	00112e23          	sw	ra,28(sp)
20405030:	00812c23          	sw	s0,24(sp)
20405034:	01412423          	sw	s4,8(sp)
20405038:	01512223          	sw	s5,4(sp)
2040503c:	00050493          	mv	s1,a0
20405040:	00058993          	mv	s3,a1
20405044:	00060913          	mv	s2,a2
	__ASSERT(((arch_is_in_isr() == false) ||
20405048:	04078263          	beqz	a5,2040508c <z_impl_k_sem_take+0x78>
2040504c:	00c5e7b3          	or	a5,a1,a2
20405050:	02078e63          	beqz	a5,2040508c <z_impl_k_sem_take+0x78>
20405054:	20409437          	lui	s0,0x20409
20405058:	204095b7          	lui	a1,0x20409
2040505c:	20408537          	lui	a0,0x20408
20405060:	d4458593          	addi	a1,a1,-700 # 20408d44 <levels.0+0x22c>
20405064:	07900693          	li	a3,121
20405068:	d2440613          	addi	a2,s0,-732 # 20408d24 <levels.0+0x20c>
2040506c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405070:	fb9fb0ef          	jal	ra,20401028 <printk>
20405074:	20409537          	lui	a0,0x20409
20405078:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
2040507c:	fadfb0ef          	jal	ra,20401028 <printk>
20405080:	07900593          	li	a1,121
20405084:	d2440513          	addi	a0,s0,-732
20405088:	ee4fd0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrc %0, mstatus, %1"
2040508c:	00800593          	li	a1,8
20405090:	3005b5f3          	csrrc	a1,mstatus,a1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20405094:	80000437          	lui	s0,0x80000
20405098:	02440513          	addi	a0,s0,36 # 80000024 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000025>
	key = (mstatus & MSTATUS_IEN);
2040509c:	0085fa93          	andi	s5,a1,8
204050a0:	a2dff0ef          	jal	ra,20404acc <z_spin_lock_valid>
204050a4:	04051063          	bnez	a0,204050e4 <z_impl_k_sem_take+0xd0>
204050a8:	20409a37          	lui	s4,0x20409
204050ac:	204095b7          	lui	a1,0x20409
204050b0:	20408537          	lui	a0,0x20408
204050b4:	08100693          	li	a3,129
204050b8:	a90a0613          	addi	a2,s4,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204050bc:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
204050c0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204050c4:	f65fb0ef          	jal	ra,20401028 <printk>
204050c8:	20409537          	lui	a0,0x20409
204050cc:	02440593          	addi	a1,s0,36
204050d0:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204050d4:	f55fb0ef          	jal	ra,20401028 <printk>
204050d8:	08100593          	li	a1,129
204050dc:	a90a0513          	addi	a0,s4,-1392
204050e0:	e8cfd0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
204050e4:	02440513          	addi	a0,s0,36
204050e8:	a3dff0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
204050ec:	0084a783          	lw	a5,8(s1)
204050f0:	08078063          	beqz	a5,20405170 <z_impl_k_sem_take+0x15c>
		sem->count--;
204050f4:	fff78793          	addi	a5,a5,-1
204050f8:	00f4a423          	sw	a5,8(s1)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204050fc:	02440513          	addi	a0,s0,36
20405100:	9f5ff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20405104:	04051063          	bnez	a0,20405144 <z_impl_k_sem_take+0x130>
20405108:	204094b7          	lui	s1,0x20409
2040510c:	204095b7          	lui	a1,0x20409
20405110:	20408537          	lui	a0,0x20408
20405114:	0ac00693          	li	a3,172
20405118:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
2040511c:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405120:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405124:	f05fb0ef          	jal	ra,20401028 <printk>
20405128:	20409537          	lui	a0,0x20409
2040512c:	02440593          	addi	a1,s0,36
20405130:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405134:	ef5fb0ef          	jal	ra,20401028 <printk>
20405138:	0ac00593          	li	a1,172
2040513c:	a9048513          	addi	a0,s1,-1392
20405140:	e2cfd0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20405144:	300aa5f3          	csrrs	a1,mstatus,s5
		k_spin_unlock(&lock, key);
		ret = 0;
20405148:	00000513          	li	a0,0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
2040514c:	01c12083          	lw	ra,28(sp)
20405150:	01812403          	lw	s0,24(sp)
20405154:	01412483          	lw	s1,20(sp)
20405158:	01012903          	lw	s2,16(sp)
2040515c:	00c12983          	lw	s3,12(sp)
20405160:	00812a03          	lw	s4,8(sp)
20405164:	00412a83          	lw	s5,4(sp)
20405168:	02010113          	addi	sp,sp,32
2040516c:	00008067          	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
20405170:	0129e7b3          	or	a5,s3,s2
20405174:	04079c63          	bnez	a5,204051cc <z_impl_k_sem_take+0x1b8>
20405178:	02440513          	addi	a0,s0,36
2040517c:	979ff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20405180:	04051063          	bnez	a0,204051c0 <z_impl_k_sem_take+0x1ac>
20405184:	204094b7          	lui	s1,0x20409
20405188:	204095b7          	lui	a1,0x20409
2040518c:	20408537          	lui	a0,0x20408
20405190:	0ac00693          	li	a3,172
20405194:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405198:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
2040519c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204051a0:	e89fb0ef          	jal	ra,20401028 <printk>
204051a4:	20409537          	lui	a0,0x20409
204051a8:	02440593          	addi	a1,s0,36
204051ac:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
204051b0:	e79fb0ef          	jal	ra,20401028 <printk>
204051b4:	0ac00593          	li	a1,172
204051b8:	a9048513          	addi	a0,s1,-1392
204051bc:	db0fd0ef          	jal	ra,2040276c <assert_post_action>
204051c0:	300aa5f3          	csrrs	a1,mstatus,s5
		ret = -EBUSY;
204051c4:	ff000513          	li	a0,-16
204051c8:	f85ff06f          	j	2040514c <z_impl_k_sem_take+0x138>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
204051cc:	02440513          	addi	a0,s0,36
}
204051d0:	01812403          	lw	s0,24(sp)
204051d4:	01c12083          	lw	ra,28(sp)
204051d8:	00812a03          	lw	s4,8(sp)
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
204051dc:	00098693          	mv	a3,s3
204051e0:	00090713          	mv	a4,s2
}
204051e4:	00c12983          	lw	s3,12(sp)
204051e8:	01012903          	lw	s2,16(sp)
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
204051ec:	00048613          	mv	a2,s1
204051f0:	000a8593          	mv	a1,s5
}
204051f4:	01412483          	lw	s1,20(sp)
204051f8:	00412a83          	lw	s5,4(sp)
204051fc:	02010113          	addi	sp,sp,32
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
20405200:	03c0106f          	j	2040623c <z_pend_curr>

20405204 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
20405204:	ff010113          	addi	sp,sp,-16
20405208:	00812423          	sw	s0,8(sp)
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
2040520c:	80000437          	lui	s0,0x80000
20405210:	03040413          	addi	s0,s0,48 # 80000030 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000031>
20405214:	00042783          	lw	a5,0(s0)
{
20405218:	00112623          	sw	ra,12(sp)
	if (slice_time != 0) {
2040521c:	02078863          	beqz	a5,2040524c <z_reset_time_slice+0x48>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
20405220:	944ff0ef          	jal	ra,20404364 <sys_clock_elapsed>
20405224:	00050793          	mv	a5,a0
20405228:	00042503          	lw	a0,0(s0)
		z_set_timeout_expiry(slice_time, false);
	}
}
2040522c:	00812403          	lw	s0,8(sp)
20405230:	00c12083          	lw	ra,12(sp)
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
20405234:	00f507b3          	add	a5,a0,a5
20405238:	80000737          	lui	a4,0x80000
2040523c:	2cf72e23          	sw	a5,732(a4) # 800002dc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002dd>
		z_set_timeout_expiry(slice_time, false);
20405240:	00000593          	li	a1,0
}
20405244:	01010113          	addi	sp,sp,16
		z_set_timeout_expiry(slice_time, false);
20405248:	0e00206f          	j	20407328 <z_set_timeout_expiry>
}
2040524c:	00c12083          	lw	ra,12(sp)
20405250:	00812403          	lw	s0,8(sp)
20405254:	01010113          	addi	sp,sp,16
20405258:	00008067          	ret

2040525c <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
2040525c:	fe010113          	addi	sp,sp,-32
20405260:	00912a23          	sw	s1,20(sp)
20405264:	01212823          	sw	s2,16(sp)
20405268:	01312623          	sw	s3,12(sp)
2040526c:	00112e23          	sw	ra,28(sp)
20405270:	00812c23          	sw	s0,24(sp)
20405274:	01412423          	sw	s4,8(sp)
20405278:	00050993          	mv	s3,a0
2040527c:	00058913          	mv	s2,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
20405280:	00800493          	li	s1,8
20405284:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20405288:	80000437          	lui	s0,0x80000
2040528c:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20405290:	0084f493          	andi	s1,s1,8
20405294:	839ff0ef          	jal	ra,20404acc <z_spin_lock_valid>
20405298:	04051063          	bnez	a0,204052d8 <k_sched_time_slice_set+0x7c>
2040529c:	20409a37          	lui	s4,0x20409
204052a0:	204095b7          	lui	a1,0x20409
204052a4:	20408537          	lui	a0,0x20408
204052a8:	08100693          	li	a3,129
204052ac:	a90a0613          	addi	a2,s4,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204052b0:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
204052b4:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204052b8:	d71fb0ef          	jal	ra,20401028 <printk>
204052bc:	20409537          	lui	a0,0x20409
204052c0:	02840593          	addi	a1,s0,40
204052c4:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204052c8:	d61fb0ef          	jal	ra,20401028 <printk>
204052cc:	08100593          	li	a1,129
204052d0:	a90a0513          	addi	a0,s4,-1392
204052d4:	c98fd0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
204052d8:	02840513          	addi	a0,s0,40
204052dc:	849ff0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
204052e0:	800007b7          	lui	a5,0x80000
204052e4:	2c07ae23          	sw	zero,732(a5) # 800002dc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002dd>
			return (uint32_t)((t * to_hz + off) / from_hz);
204052e8:	00799793          	slli	a5,s3,0x7
204052ec:	3e778513          	addi	a0,a5,999
204052f0:	00f537b3          	sltu	a5,a0,a5
204052f4:	0199d593          	srli	a1,s3,0x19
204052f8:	00b785b3          	add	a1,a5,a1
204052fc:	3e800613          	li	a2,1000
20405300:	00000693          	li	a3,0
20405304:	87cfb0ef          	jal	ra,20400380 <__udivdi3>
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
20405308:	800007b7          	lui	a5,0x80000
2040530c:	03078793          	addi	a5,a5,48 # 80000030 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000031>
20405310:	09304063          	bgtz	s3,20405390 <k_sched_time_slice_set+0x134>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
20405314:	00a7a023          	sw	a0,0(a5)
		}
		slice_max_prio = prio;
20405318:	800007b7          	lui	a5,0x80000
2040531c:	0327a623          	sw	s2,44(a5) # 8000002c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000002d>
		z_reset_time_slice();
20405320:	ee5ff0ef          	jal	ra,20405204 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20405324:	02840513          	addi	a0,s0,40
20405328:	fccff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
2040532c:	04051063          	bnez	a0,2040536c <k_sched_time_slice_set+0x110>
20405330:	20409937          	lui	s2,0x20409
20405334:	204095b7          	lui	a1,0x20409
20405338:	20408537          	lui	a0,0x20408
2040533c:	0ac00693          	li	a3,172
20405340:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405344:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405348:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040534c:	cddfb0ef          	jal	ra,20401028 <printk>
20405350:	20409537          	lui	a0,0x20409
20405354:	02840593          	addi	a1,s0,40
20405358:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
2040535c:	ccdfb0ef          	jal	ra,20401028 <printk>
20405360:	0ac00593          	li	a1,172
20405364:	a9090513          	addi	a0,s2,-1392
20405368:	c04fd0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
2040536c:	3004a4f3          	csrrs	s1,mstatus,s1
	}
}
20405370:	01c12083          	lw	ra,28(sp)
20405374:	01812403          	lw	s0,24(sp)
20405378:	01412483          	lw	s1,20(sp)
2040537c:	01012903          	lw	s2,16(sp)
20405380:	00c12983          	lw	s3,12(sp)
20405384:	00812a03          	lw	s4,8(sp)
20405388:	02010113          	addi	sp,sp,32
2040538c:	00008067          	ret
			slice_time = MAX(2, slice_time);
20405390:	00200713          	li	a4,2
20405394:	f8e550e3          	bge	a0,a4,20405314 <k_sched_time_slice_set+0xb8>
20405398:	00200513          	li	a0,2
2040539c:	f79ff06f          	j	20405314 <k_sched_time_slice_set+0xb8>

204053a0 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
204053a0:	ff010113          	addi	sp,sp,-16
204053a4:	00812423          	sw	s0,8(sp)
204053a8:	01212023          	sw	s2,0(sp)
204053ac:	00112623          	sw	ra,12(sp)
204053b0:	00912223          	sw	s1,4(sp)
	 * have the single bit set).  But there is a mask applied to
	 * the argument in arch_irq_unlock() that has me worried
	 * that something elseswhere might try to set a bit?  Do it
	 * the safe way for now.
	 */
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
204053b4:	0085f913          	andi	s2,a1,8
204053b8:	00050413          	mv	s0,a0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
204053bc:	08090263          	beqz	s2,20405440 <z_reschedule+0xa0>
	return _kernel.cpus[0].nested != 0U;
204053c0:	800007b7          	lui	a5,0x80000
204053c4:	2cc78793          	addi	a5,a5,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
	if (resched(key.key) && need_swap()) {
204053c8:	0007a703          	lw	a4,0(a5)
204053cc:	06071a63          	bnez	a4,20405440 <z_reschedule+0xa0>
204053d0:	0187a703          	lw	a4,24(a5)
204053d4:	0087a783          	lw	a5,8(a5)
204053d8:	06f70463          	beq	a4,a5,20405440 <z_reschedule+0xa0>
204053dc:	00058493          	mv	s1,a1
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204053e0:	f14ff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204053e4:	04051063          	bnez	a0,20405424 <z_reschedule+0x84>
204053e8:	20409937          	lui	s2,0x20409
204053ec:	204095b7          	lui	a1,0x20409
204053f0:	20408537          	lui	a0,0x20408
204053f4:	0c300693          	li	a3,195
204053f8:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204053fc:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405400:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405404:	c25fb0ef          	jal	ra,20401028 <printk>
20405408:	20409537          	lui	a0,0x20409
2040540c:	00040593          	mv	a1,s0
20405410:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405414:	c15fb0ef          	jal	ra,20401028 <printk>
20405418:	0c300593          	li	a1,195
2040541c:	a9090513          	addi	a0,s2,-1392
20405420:	b4cfd0ef          	jal	ra,2040276c <assert_post_action>
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
20405424:	00812403          	lw	s0,8(sp)
20405428:	00c12083          	lw	ra,12(sp)
2040542c:	00012903          	lw	s2,0(sp)
20405430:	00048513          	mv	a0,s1
20405434:	00412483          	lw	s1,4(sp)
20405438:	01010113          	addi	sp,sp,16
2040543c:	e85fa06f          	j	204002c0 <arch_swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20405440:	00040513          	mv	a0,s0
20405444:	eb0ff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20405448:	04051063          	bnez	a0,20405488 <z_reschedule+0xe8>
2040544c:	204094b7          	lui	s1,0x20409
20405450:	204095b7          	lui	a1,0x20409
20405454:	20408537          	lui	a0,0x20408
20405458:	0ac00693          	li	a3,172
2040545c:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405460:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405464:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405468:	bc1fb0ef          	jal	ra,20401028 <printk>
2040546c:	20409537          	lui	a0,0x20409
20405470:	00040593          	mv	a1,s0
20405474:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405478:	bb1fb0ef          	jal	ra,20401028 <printk>
2040547c:	0ac00593          	li	a1,172
20405480:	a9048513          	addi	a0,s1,-1392
20405484:	ae8fd0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20405488:	30092973          	csrrs	s2,mstatus,s2
2040548c:	00c12083          	lw	ra,12(sp)
20405490:	00812403          	lw	s0,8(sp)
20405494:	00412483          	lw	s1,4(sp)
20405498:	00012903          	lw	s2,0(sp)
2040549c:	01010113          	addi	sp,sp,16
204054a0:	00008067          	ret

204054a4 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
204054a4:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
204054a8:	00078a63          	beqz	a5,204054bc <z_reschedule_irqlock+0x18>

void z_reschedule_irqlock(uint32_t key)
{
	if (resched(key)) {
204054ac:	80000737          	lui	a4,0x80000
204054b0:	2cc72703          	lw	a4,716(a4) # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
204054b4:	00071463          	bnez	a4,204054bc <z_reschedule_irqlock+0x18>
204054b8:	e09fa06f          	j	204002c0 <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204054bc:	3007a7f3          	csrrs	a5,mstatus,a5
		z_swap_irqlock(key);
	} else {
		irq_unlock(key);
	}
}
204054c0:	00008067          	ret

204054c4 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
204054c4:	00800513          	li	a0,8
204054c8:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(arch_irq_lock());
204054cc:	00857513          	andi	a0,a0,8
204054d0:	fd5ff06f          	j	204054a4 <z_reschedule_irqlock>

204054d4 <k_sched_lock>:

void k_sched_lock(void)
{
204054d4:	fe010113          	addi	sp,sp,-32
204054d8:	00112e23          	sw	ra,28(sp)
204054dc:	00812c23          	sw	s0,24(sp)
204054e0:	00912a23          	sw	s1,20(sp)
204054e4:	01212823          	sw	s2,16(sp)
204054e8:	01312623          	sw	s3,12(sp)
204054ec:	00800793          	li	a5,8
204054f0:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
204054f4:	80000437          	lui	s0,0x80000
204054f8:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
204054fc:	0087f993          	andi	s3,a5,8
20405500:	dccff0ef          	jal	ra,20404acc <z_spin_lock_valid>
20405504:	04051063          	bnez	a0,20405544 <k_sched_lock+0x70>
20405508:	204094b7          	lui	s1,0x20409
2040550c:	204095b7          	lui	a1,0x20409
20405510:	20408537          	lui	a0,0x20408
20405514:	08100693          	li	a3,129
20405518:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
2040551c:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20405520:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405524:	b05fb0ef          	jal	ra,20401028 <printk>
20405528:	20409537          	lui	a0,0x20409
2040552c:	02840593          	addi	a1,s0,40
20405530:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20405534:	af5fb0ef          	jal	ra,20401028 <printk>
20405538:	08100593          	li	a1,129
2040553c:	a9048513          	addi	a0,s1,-1392
20405540:	a2cfd0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20405544:	02840513          	addi	a0,s0,40
20405548:	800004b7          	lui	s1,0x80000
2040554c:	dd8ff0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	}
}

static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
20405550:	2cc4a783          	lw	a5,716(s1) # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20405554:	2cc48493          	addi	s1,s1,716
20405558:	02078e63          	beqz	a5,20405594 <k_sched_lock+0xc0>
2040555c:	20409937          	lui	s2,0x20409
20405560:	204095b7          	lui	a1,0x20409
20405564:	20408537          	lui	a0,0x20408
20405568:	dc458593          	addi	a1,a1,-572 # 20408dc4 <levels.0+0x2ac>
2040556c:	0fd00693          	li	a3,253
20405570:	d9890613          	addi	a2,s2,-616 # 20408d98 <levels.0+0x280>
20405574:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405578:	ab1fb0ef          	jal	ra,20401028 <printk>
2040557c:	20409537          	lui	a0,0x20409
20405580:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
20405584:	aa5fb0ef          	jal	ra,20401028 <printk>
20405588:	0fd00593          	li	a1,253
2040558c:	d9890513          	addi	a0,s2,-616
20405590:	9dcfd0ef          	jal	ra,2040276c <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1U, "");
20405594:	0084a783          	lw	a5,8(s1)
20405598:	00f7c703          	lbu	a4,15(a5)
2040559c:	00100793          	li	a5,1
204055a0:	02f71e63          	bne	a4,a5,204055dc <k_sched_lock+0x108>
204055a4:	20409937          	lui	s2,0x20409
204055a8:	204095b7          	lui	a1,0x20409
204055ac:	20408537          	lui	a0,0x20408
204055b0:	dd858593          	addi	a1,a1,-552 # 20408dd8 <levels.0+0x2c0>
204055b4:	0fe00693          	li	a3,254
204055b8:	d9890613          	addi	a2,s2,-616 # 20408d98 <levels.0+0x280>
204055bc:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204055c0:	a69fb0ef          	jal	ra,20401028 <printk>
204055c4:	20409537          	lui	a0,0x20409
204055c8:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
204055cc:	a5dfb0ef          	jal	ra,20401028 <printk>
204055d0:	0fe00593          	li	a1,254
204055d4:	d9890513          	addi	a0,s2,-616
204055d8:	994fd0ef          	jal	ra,2040276c <assert_post_action>

	--_current->base.sched_locked;
204055dc:	0084a703          	lw	a4,8(s1)
204055e0:	00f74783          	lbu	a5,15(a4)
204055e4:	fff78793          	addi	a5,a5,-1
204055e8:	00f707a3          	sb	a5,15(a4)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204055ec:	02840513          	addi	a0,s0,40
204055f0:	d04ff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204055f4:	04051063          	bnez	a0,20405634 <k_sched_lock+0x160>
204055f8:	204094b7          	lui	s1,0x20409
204055fc:	204095b7          	lui	a1,0x20409
20405600:	20408537          	lui	a0,0x20408
20405604:	0ac00693          	li	a3,172
20405608:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
2040560c:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405610:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405614:	a15fb0ef          	jal	ra,20401028 <printk>
20405618:	20409537          	lui	a0,0x20409
2040561c:	02840593          	addi	a1,s0,40
20405620:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405624:	a05fb0ef          	jal	ra,20401028 <printk>
20405628:	0ac00593          	li	a1,172
2040562c:	a9048513          	addi	a0,s1,-1392
20405630:	93cfd0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20405634:	3009a7f3          	csrrs	a5,mstatus,s3
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
20405638:	01c12083          	lw	ra,28(sp)
2040563c:	01812403          	lw	s0,24(sp)
20405640:	01412483          	lw	s1,20(sp)
20405644:	01012903          	lw	s2,16(sp)
20405648:	00c12983          	lw	s3,12(sp)
2040564c:	02010113          	addi	sp,sp,32
20405650:	00008067          	ret

20405654 <z_priq_dumb_remove>:
#endif
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
20405654:	ff010113          	addi	sp,sp,-16
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
20405658:	800007b7          	lui	a5,0x80000
{
2040565c:	00812423          	sw	s0,8(sp)
20405660:	00112623          	sw	ra,12(sp)
20405664:	00912223          	sw	s1,4(sp)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
20405668:	1c078793          	addi	a5,a5,448 # 800001c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800001c1>
{
2040566c:	00058413          	mv	s0,a1
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
20405670:	02f59863          	bne	a1,a5,204056a0 <z_priq_dumb_remove+0x4c>
20405674:	204094b7          	lui	s1,0x20409
20405678:	204095b7          	lui	a1,0x20409
2040567c:	20408537          	lui	a0,0x20408
20405680:	e3058593          	addi	a1,a1,-464 # 20408e30 <levels.0+0x318>
20405684:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405688:	3e700693          	li	a3,999
2040568c:	e0c48613          	addi	a2,s1,-500 # 20408e0c <levels.0+0x2f4>
20405690:	999fb0ef          	jal	ra,20401028 <printk>
20405694:	3e700593          	li	a1,999
20405698:	e0c48513          	addi	a0,s1,-500
2040569c:	8d0fd0ef          	jal	ra,2040276c <assert_post_action>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
204056a0:	00442703          	lw	a4,4(s0)
	sys_dnode_t *const next = node->next;
204056a4:	00042783          	lw	a5,0(s0)

	sys_dlist_remove(&thread->base.qnode_dlist);
}
204056a8:	00c12083          	lw	ra,12(sp)
204056ac:	00412483          	lw	s1,4(sp)

	prev->next = next;
204056b0:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
204056b4:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
204056b8:	00042023          	sw	zero,0(s0)
	node->prev = NULL;
204056bc:	00042223          	sw	zero,4(s0)
204056c0:	00812403          	lw	s0,8(sp)
204056c4:	01010113          	addi	sp,sp,16
204056c8:	00008067          	ret

204056cc <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread->base.pended_on);
204056cc:	00852783          	lw	a5,8(a0)
{
204056d0:	ff010113          	addi	sp,sp,-16
204056d4:	00812423          	sw	s0,8(sp)
204056d8:	00112623          	sw	ra,12(sp)
204056dc:	00912223          	sw	s1,4(sp)
204056e0:	00050413          	mv	s0,a0
	__ASSERT_NO_MSG(thread->base.pended_on);
204056e4:	02079863          	bnez	a5,20405714 <unpend_thread_no_timeout+0x48>
204056e8:	204094b7          	lui	s1,0x20409
204056ec:	204095b7          	lui	a1,0x20409
204056f0:	20408537          	lui	a0,0x20408
204056f4:	e5458593          	addi	a1,a1,-428 # 20408e54 <levels.0+0x33c>
204056f8:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204056fc:	28300693          	li	a3,643
20405700:	e0c48613          	addi	a2,s1,-500 # 20408e0c <levels.0+0x2f4>
20405704:	925fb0ef          	jal	ra,20401028 <printk>
20405708:	28300593          	li	a1,643
2040570c:	e0c48513          	addi	a0,s1,-500
20405710:	85cfd0ef          	jal	ra,2040276c <assert_post_action>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
20405714:	00842503          	lw	a0,8(s0)
20405718:	00040593          	mv	a1,s0
2040571c:	f39ff0ef          	jal	ra,20405654 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
20405720:	00d44783          	lbu	a5,13(s0)
}
20405724:	00c12083          	lw	ra,12(sp)
	thread->base.pended_on = NULL;
20405728:	00042423          	sw	zero,8(s0)
2040572c:	ffd7f793          	andi	a5,a5,-3
20405730:	00f406a3          	sb	a5,13(s0)
}
20405734:	00812403          	lw	s0,8(sp)
20405738:	00412483          	lw	s1,4(sp)
2040573c:	01010113          	addi	sp,sp,16
20405740:	00008067          	ret

20405744 <z_unpend_thread>:
{
20405744:	fe010113          	addi	sp,sp,-32
20405748:	00912a23          	sw	s1,20(sp)
2040574c:	01212823          	sw	s2,16(sp)
20405750:	00112e23          	sw	ra,28(sp)
20405754:	00812c23          	sw	s0,24(sp)
20405758:	01312623          	sw	s3,12(sp)
2040575c:	00050913          	mv	s2,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20405760:	00800493          	li	s1,8
20405764:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20405768:	80000437          	lui	s0,0x80000
2040576c:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20405770:	0084f493          	andi	s1,s1,8
20405774:	b58ff0ef          	jal	ra,20404acc <z_spin_lock_valid>
20405778:	04051063          	bnez	a0,204057b8 <z_unpend_thread+0x74>
2040577c:	204099b7          	lui	s3,0x20409
20405780:	204095b7          	lui	a1,0x20409
20405784:	20408537          	lui	a0,0x20408
20405788:	08100693          	li	a3,129
2040578c:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405790:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20405794:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405798:	891fb0ef          	jal	ra,20401028 <printk>
2040579c:	20409537          	lui	a0,0x20409
204057a0:	02840593          	addi	a1,s0,40
204057a4:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204057a8:	881fb0ef          	jal	ra,20401028 <printk>
204057ac:	08100593          	li	a1,129
204057b0:	a9098513          	addi	a0,s3,-1392
204057b4:	fb9fc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
204057b8:	02840513          	addi	a0,s0,40
204057bc:	b68ff0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
		unpend_thread_no_timeout(thread);
204057c0:	00090513          	mv	a0,s2
204057c4:	f09ff0ef          	jal	ra,204056cc <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204057c8:	02840513          	addi	a0,s0,40
204057cc:	b28ff0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204057d0:	04051063          	bnez	a0,20405810 <z_unpend_thread+0xcc>
204057d4:	204099b7          	lui	s3,0x20409
204057d8:	204095b7          	lui	a1,0x20409
204057dc:	20408537          	lui	a0,0x20408
204057e0:	0ac00693          	li	a3,172
204057e4:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204057e8:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
204057ec:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204057f0:	839fb0ef          	jal	ra,20401028 <printk>
204057f4:	20409537          	lui	a0,0x20409
204057f8:	02840593          	addi	a1,s0,40
204057fc:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405800:	829fb0ef          	jal	ra,20401028 <printk>
20405804:	0ac00593          	li	a1,172
20405808:	a9098513          	addi	a0,s3,-1392
2040580c:	f61fc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20405810:	3004a4f3          	csrrs	s1,mstatus,s1
}
20405814:	01812403          	lw	s0,24(sp)
20405818:	01c12083          	lw	ra,28(sp)
2040581c:	01412483          	lw	s1,20(sp)
20405820:	00c12983          	lw	s3,12(sp)
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
20405824:	01890513          	addi	a0,s2,24
20405828:	01012903          	lw	s2,16(sp)
2040582c:	02010113          	addi	sp,sp,32
20405830:	1f90106f          	j	20407228 <z_abort_timeout>

20405834 <z_priq_dumb_best>:

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
20405834:	00050793          	mv	a5,a0
	return list->head == list;
20405838:	00052503          	lw	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
2040583c:	00a79463          	bne	a5,a0,20405844 <z_priq_dumb_best+0x10>
	struct k_thread *thread = NULL;
20405840:	00000513          	li	a0,0

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
20405844:	00008067          	ret

20405848 <update_cache>:
{
20405848:	ff010113          	addi	sp,sp,-16
2040584c:	01212023          	sw	s2,0(sp)
20405850:	00050913          	mv	s2,a0
	return _priq_run_best(curr_cpu_runq());
20405854:	80000537          	lui	a0,0x80000
20405858:	2e850513          	addi	a0,a0,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
{
2040585c:	00812423          	sw	s0,8(sp)
20405860:	00912223          	sw	s1,4(sp)
20405864:	00112623          	sw	ra,12(sp)
20405868:	80000437          	lui	s0,0x80000
	return _priq_run_best(curr_cpu_runq());
2040586c:	fc9ff0ef          	jal	ra,20405834 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
20405870:	2cc40413          	addi	s0,s0,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20405874:	00050493          	mv	s1,a0
20405878:	00051463          	bnez	a0,20405880 <update_cache+0x38>
2040587c:	00c42483          	lw	s1,12(s0)
	if (preempt_ok != 0) {
20405880:	06091e63          	bnez	s2,204058fc <update_cache+0xb4>
	__ASSERT(_current != NULL, "");
20405884:	00842783          	lw	a5,8(s0)
20405888:	02079e63          	bnez	a5,204058c4 <update_cache+0x7c>
2040588c:	20409937          	lui	s2,0x20409
20405890:	204095b7          	lui	a1,0x20409
20405894:	20408537          	lui	a0,0x20408
20405898:	e6c58593          	addi	a1,a1,-404 # 20408e6c <levels.0+0x354>
2040589c:	08900693          	li	a3,137
204058a0:	e0c90613          	addi	a2,s2,-500 # 20408e0c <levels.0+0x2f4>
204058a4:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204058a8:	f80fb0ef          	jal	ra,20401028 <printk>
204058ac:	20409537          	lui	a0,0x20409
204058b0:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
204058b4:	f74fb0ef          	jal	ra,20401028 <printk>
204058b8:	08900593          	li	a1,137
204058bc:	e0c90513          	addi	a0,s2,-500
204058c0:	eadfc0ef          	jal	ra,2040276c <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
204058c4:	00842783          	lw	a5,8(s0)
204058c8:	00d7c703          	lbu	a4,13(a5)
204058cc:	01f77713          	andi	a4,a4,31
204058d0:	02071663          	bnez	a4,204058fc <update_cache+0xb4>
	if (is_preempt(_current) || is_metairq(thread)) {
204058d4:	00e7d683          	lhu	a3,14(a5)
204058d8:	07f00713          	li	a4,127
204058dc:	02d77063          	bgeu	a4,a3,204058fc <update_cache+0xb4>
		_kernel.ready_q.cache = _current;
204058e0:	00f42c23          	sw	a5,24(s0)
}
204058e4:	00c12083          	lw	ra,12(sp)
204058e8:	00812403          	lw	s0,8(sp)
204058ec:	00412483          	lw	s1,4(sp)
204058f0:	00012903          	lw	s2,0(sp)
204058f4:	01010113          	addi	sp,sp,16
204058f8:	00008067          	ret
		if (thread != _current) {
204058fc:	00842783          	lw	a5,8(s0)
20405900:	00978463          	beq	a5,s1,20405908 <update_cache+0xc0>
			z_reset_time_slice();
20405904:	901ff0ef          	jal	ra,20405204 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
20405908:	00942c23          	sw	s1,24(s0)
}
2040590c:	fd9ff06f          	j	204058e4 <update_cache+0x9c>

20405910 <move_thread_to_end_of_prio_q>:
{
20405910:	ff010113          	addi	sp,sp,-16
20405914:	00812423          	sw	s0,8(sp)
20405918:	00112623          	sw	ra,12(sp)
2040591c:	00912223          	sw	s1,4(sp)
	return (thread->base.thread_state & state) != 0U;
20405920:	00d54783          	lbu	a5,13(a0)
20405924:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
20405928:	01879713          	slli	a4,a5,0x18
2040592c:	41875713          	srai	a4,a4,0x18
20405930:	00075e63          	bgez	a4,2040594c <move_thread_to_end_of_prio_q+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20405934:	07f7f793          	andi	a5,a5,127
20405938:	00f506a3          	sb	a5,13(a0)
	_priq_run_remove(thread_runq(thread), thread);
2040593c:	00050593          	mv	a1,a0
20405940:	80000537          	lui	a0,0x80000
20405944:	2e850513          	addi	a0,a0,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
20405948:	d0dff0ef          	jal	ra,20405654 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
2040594c:	00d44783          	lbu	a5,13(s0)
20405950:	f807e793          	ori	a5,a5,-128
20405954:	00f406a3          	sb	a5,13(s0)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
20405958:	800007b7          	lui	a5,0x80000
2040595c:	1c078793          	addi	a5,a5,448 # 800001c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800001c1>
20405960:	02f41863          	bne	s0,a5,20405990 <move_thread_to_end_of_prio_q+0x80>
20405964:	204094b7          	lui	s1,0x20409
20405968:	204095b7          	lui	a1,0x20409
2040596c:	20408537          	lui	a0,0x20408
20405970:	e3058593          	addi	a1,a1,-464 # 20408e30 <levels.0+0x318>
20405974:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405978:	0ba00693          	li	a3,186
2040597c:	e0c48613          	addi	a2,s1,-500 # 20408e0c <levels.0+0x2f4>
20405980:	ea8fb0ef          	jal	ra,20401028 <printk>
20405984:	0ba00593          	li	a1,186
20405988:	e0c48513          	addi	a0,s1,-500
2040598c:	de1fc0ef          	jal	ra,2040276c <assert_post_action>
	return list->head == list;
20405990:	80000737          	lui	a4,0x80000
20405994:	2cc70693          	addi	a3,a4,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20405998:	01c6a783          	lw	a5,28(a3)
	return (node == list->tail) ? NULL : node->next;
2040599c:	0206a583          	lw	a1,32(a3)
204059a0:	800006b7          	lui	a3,0x80000
204059a4:	2e868693          	addi	a3,a3,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
204059a8:	2cc70713          	addi	a4,a4,716
	return sys_dlist_is_empty(list) ? NULL : list->head;
204059ac:	04d78e63          	beq	a5,a3,20405a08 <move_thread_to_end_of_prio_q+0xf8>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
204059b0:	04078c63          	beqz	a5,20405a08 <move_thread_to_end_of_prio_q+0xf8>
	int32_t b1 = thread_1->base.prio;
204059b4:	00e40503          	lb	a0,14(s0)
	int32_t b2 = thread_2->base.prio;
204059b8:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
204059bc:	04c50063          	beq	a0,a2,204059fc <move_thread_to_end_of_prio_q+0xec>
		return b2 - b1;
204059c0:	40a60633          	sub	a2,a2,a0
		if (z_sched_prio_cmp(thread, t) > 0) {
204059c4:	02c05c63          	blez	a2,204059fc <move_thread_to_end_of_prio_q+0xec>
	sys_dnode_t *const prev = successor->prev;
204059c8:	0047a683          	lw	a3,4(a5)
	node->next = successor;
204059cc:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
204059d0:	00d42223          	sw	a3,4(s0)
	prev->next = node;
204059d4:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
204059d8:	0087a223          	sw	s0,4(a5)
	update_cache(thread == _current);
204059dc:	00872503          	lw	a0,8(a4)
}
204059e0:	00c12083          	lw	ra,12(sp)
204059e4:	00412483          	lw	s1,4(sp)
	update_cache(thread == _current);
204059e8:	40850533          	sub	a0,a0,s0
}
204059ec:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
204059f0:	00153513          	seqz	a0,a0
}
204059f4:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
204059f8:	e51ff06f          	j	20405848 <update_cache>
	return (node == list->tail) ? NULL : node->next;
204059fc:	00b78663          	beq	a5,a1,20405a08 <move_thread_to_end_of_prio_q+0xf8>
20405a00:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20405a04:	fa079ae3          	bnez	a5,204059b8 <move_thread_to_end_of_prio_q+0xa8>
	node->next = list;
20405a08:	00d42023          	sw	a3,0(s0)
	node->prev = tail;
20405a0c:	00b42223          	sw	a1,4(s0)
	tail->next = node;
20405a10:	0085a023          	sw	s0,0(a1)
	list->tail = node;
20405a14:	02872023          	sw	s0,32(a4)
}
20405a18:	fc5ff06f          	j	204059dc <move_thread_to_end_of_prio_q+0xcc>

20405a1c <z_time_slice>:
{
20405a1c:	fe010113          	addi	sp,sp,-32
20405a20:	00912a23          	sw	s1,20(sp)
20405a24:	01212823          	sw	s2,16(sp)
20405a28:	00112e23          	sw	ra,28(sp)
20405a2c:	00812c23          	sw	s0,24(sp)
20405a30:	01312623          	sw	s3,12(sp)
20405a34:	00050913          	mv	s2,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20405a38:	00800493          	li	s1,8
20405a3c:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20405a40:	80000437          	lui	s0,0x80000
20405a44:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20405a48:	0084f493          	andi	s1,s1,8
20405a4c:	880ff0ef          	jal	ra,20404acc <z_spin_lock_valid>
20405a50:	04051063          	bnez	a0,20405a90 <z_time_slice+0x74>
20405a54:	204099b7          	lui	s3,0x20409
20405a58:	204095b7          	lui	a1,0x20409
20405a5c:	20408537          	lui	a0,0x20408
20405a60:	08100693          	li	a3,129
20405a64:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405a68:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20405a6c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405a70:	db8fb0ef          	jal	ra,20401028 <printk>
20405a74:	20409537          	lui	a0,0x20409
20405a78:	02840593          	addi	a1,s0,40
20405a7c:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20405a80:	da8fb0ef          	jal	ra,20401028 <printk>
20405a84:	08100593          	li	a1,129
20405a88:	a9098513          	addi	a0,s3,-1392
20405a8c:	ce1fc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20405a90:	02840513          	addi	a0,s0,40
20405a94:	890ff0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	if (slice_time && sliceable(_current)) {
20405a98:	800007b7          	lui	a5,0x80000
20405a9c:	0307a703          	lw	a4,48(a5) # 80000030 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000031>
20405aa0:	800007b7          	lui	a5,0x80000
20405aa4:	2cc78793          	addi	a5,a5,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20405aa8:	0c070063          	beqz	a4,20405b68 <z_time_slice+0x14c>
20405aac:	0087a503          	lw	a0,8(a5)
		&& !z_is_idle_thread_object(thread);
20405ab0:	07f00713          	li	a4,127
20405ab4:	00e55683          	lhu	a3,14(a0)
20405ab8:	0ad76863          	bltu	a4,a3,20405b68 <z_time_slice+0x14c>
		&& !z_is_thread_prevented_from_running(thread)
20405abc:	00d54683          	lbu	a3,13(a0)
20405ac0:	01f6f693          	andi	a3,a3,31
20405ac4:	0a069263          	bnez	a3,20405b68 <z_time_slice+0x14c>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
20405ac8:	80000737          	lui	a4,0x80000
20405acc:	00e50683          	lb	a3,14(a0)
20405ad0:	02c72703          	lw	a4,44(a4) # 8000002c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000002d>
20405ad4:	08e6ca63          	blt	a3,a4,20405b68 <z_time_slice+0x14c>
		&& !z_is_idle_thread_object(thread);
20405ad8:	800006b7          	lui	a3,0x80000
20405adc:	1c068693          	addi	a3,a3,448 # 800001c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800001c1>
20405ae0:	08d50463          	beq	a0,a3,20405b68 <z_time_slice+0x14c>
		if (ticks >= _current_cpu->slice_ticks) {
20405ae4:	0107a703          	lw	a4,16(a5)
20405ae8:	06e94a63          	blt	s2,a4,20405b5c <z_time_slice+0x140>
			move_thread_to_end_of_prio_q(_current);
20405aec:	e25ff0ef          	jal	ra,20405910 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
20405af0:	f14ff0ef          	jal	ra,20405204 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20405af4:	02840513          	addi	a0,s0,40
20405af8:	ffdfe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20405afc:	04051063          	bnez	a0,20405b3c <z_time_slice+0x120>
20405b00:	20409937          	lui	s2,0x20409
20405b04:	204095b7          	lui	a1,0x20409
20405b08:	20408537          	lui	a0,0x20408
20405b0c:	0ac00693          	li	a3,172
20405b10:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405b14:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405b18:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405b1c:	d0cfb0ef          	jal	ra,20401028 <printk>
20405b20:	20409537          	lui	a0,0x20409
20405b24:	02840593          	addi	a1,s0,40
20405b28:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405b2c:	cfcfb0ef          	jal	ra,20401028 <printk>
20405b30:	0ac00593          	li	a1,172
20405b34:	a9090513          	addi	a0,s2,-1392
20405b38:	c35fc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20405b3c:	3004a4f3          	csrrs	s1,mstatus,s1
}
20405b40:	01c12083          	lw	ra,28(sp)
20405b44:	01812403          	lw	s0,24(sp)
20405b48:	01412483          	lw	s1,20(sp)
20405b4c:	01012903          	lw	s2,16(sp)
20405b50:	00c12983          	lw	s3,12(sp)
20405b54:	02010113          	addi	sp,sp,32
20405b58:	00008067          	ret
			_current_cpu->slice_ticks -= ticks;
20405b5c:	41270733          	sub	a4,a4,s2
20405b60:	00e7a823          	sw	a4,16(a5)
20405b64:	f91ff06f          	j	20405af4 <z_time_slice+0xd8>
		_current_cpu->slice_ticks = 0;
20405b68:	0007a823          	sw	zero,16(a5)
20405b6c:	f89ff06f          	j	20405af4 <z_time_slice+0xd8>

20405b70 <ready_thread>:
20405b70:	00d54783          	lbu	a5,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
20405b74:	01879713          	slli	a4,a5,0x18
20405b78:	41875713          	srai	a4,a4,0x18
20405b7c:	10074063          	bltz	a4,20405c7c <ready_thread+0x10c>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
20405b80:	01f7f713          	andi	a4,a5,31
20405b84:	0e071c63          	bnez	a4,20405c7c <ready_thread+0x10c>
20405b88:	01852703          	lw	a4,24(a0)
{
20405b8c:	ff010113          	addi	sp,sp,-16
20405b90:	00812423          	sw	s0,8(sp)
20405b94:	00112623          	sw	ra,12(sp)
20405b98:	00912223          	sw	s1,4(sp)
20405b9c:	00050413          	mv	s0,a0
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
20405ba0:	0c071463          	bnez	a4,20405c68 <ready_thread+0xf8>
	thread->base.thread_state |= _THREAD_QUEUED;
20405ba4:	f807e793          	ori	a5,a5,-128
20405ba8:	00f506a3          	sb	a5,13(a0)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
20405bac:	800007b7          	lui	a5,0x80000
20405bb0:	1c078793          	addi	a5,a5,448 # 800001c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800001c1>
20405bb4:	02f51863          	bne	a0,a5,20405be4 <ready_thread+0x74>
20405bb8:	204094b7          	lui	s1,0x20409
20405bbc:	204095b7          	lui	a1,0x20409
20405bc0:	20408537          	lui	a0,0x20408
20405bc4:	e3058593          	addi	a1,a1,-464 # 20408e30 <levels.0+0x318>
20405bc8:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405bcc:	0ba00693          	li	a3,186
20405bd0:	e0c48613          	addi	a2,s1,-500 # 20408e0c <levels.0+0x2f4>
20405bd4:	c54fb0ef          	jal	ra,20401028 <printk>
20405bd8:	0ba00593          	li	a1,186
20405bdc:	e0c48513          	addi	a0,s1,-500
20405be0:	b8dfc0ef          	jal	ra,2040276c <assert_post_action>
	return list->head == list;
20405be4:	80000737          	lui	a4,0x80000
20405be8:	2cc70693          	addi	a3,a4,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20405bec:	01c6a783          	lw	a5,28(a3)
	return (node == list->tail) ? NULL : node->next;
20405bf0:	0206a583          	lw	a1,32(a3)
20405bf4:	800006b7          	lui	a3,0x80000
20405bf8:	2e868693          	addi	a3,a3,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
20405bfc:	2cc70713          	addi	a4,a4,716
	return sys_dlist_is_empty(list) ? NULL : list->head;
20405c00:	04d78a63          	beq	a5,a3,20405c54 <ready_thread+0xe4>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20405c04:	04078863          	beqz	a5,20405c54 <ready_thread+0xe4>
	int32_t b1 = thread_1->base.prio;
20405c08:	00e40503          	lb	a0,14(s0)
	int32_t b2 = thread_2->base.prio;
20405c0c:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
20405c10:	02c50c63          	beq	a0,a2,20405c48 <ready_thread+0xd8>
		return b2 - b1;
20405c14:	40a60633          	sub	a2,a2,a0
		if (z_sched_prio_cmp(thread, t) > 0) {
20405c18:	02c05863          	blez	a2,20405c48 <ready_thread+0xd8>
	sys_dnode_t *const prev = successor->prev;
20405c1c:	0047a703          	lw	a4,4(a5)
	node->next = successor;
20405c20:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
20405c24:	00e42223          	sw	a4,4(s0)
	prev->next = node;
20405c28:	00872023          	sw	s0,0(a4)
	successor->prev = node;
20405c2c:	0087a223          	sw	s0,4(a5)
}
20405c30:	00812403          	lw	s0,8(sp)
20405c34:	00c12083          	lw	ra,12(sp)
20405c38:	00412483          	lw	s1,4(sp)
		update_cache(0);
20405c3c:	00000513          	li	a0,0
}
20405c40:	01010113          	addi	sp,sp,16
		update_cache(0);
20405c44:	c05ff06f          	j	20405848 <update_cache>
	return (node == list->tail) ? NULL : node->next;
20405c48:	00f58663          	beq	a1,a5,20405c54 <ready_thread+0xe4>
20405c4c:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20405c50:	fa079ee3          	bnez	a5,20405c0c <ready_thread+0x9c>
	node->next = list;
20405c54:	00d42023          	sw	a3,0(s0)
	node->prev = tail;
20405c58:	00b42223          	sw	a1,4(s0)
	tail->next = node;
20405c5c:	0085a023          	sw	s0,0(a1)
	list->tail = node;
20405c60:	02872023          	sw	s0,32(a4)
}
20405c64:	fcdff06f          	j	20405c30 <ready_thread+0xc0>
}
20405c68:	00c12083          	lw	ra,12(sp)
20405c6c:	00812403          	lw	s0,8(sp)
20405c70:	00412483          	lw	s1,4(sp)
20405c74:	01010113          	addi	sp,sp,16
20405c78:	00008067          	ret
20405c7c:	00008067          	ret

20405c80 <z_ready_thread>:
{
20405c80:	fe010113          	addi	sp,sp,-32
20405c84:	00912a23          	sw	s1,20(sp)
20405c88:	01212823          	sw	s2,16(sp)
20405c8c:	00112e23          	sw	ra,28(sp)
20405c90:	00812c23          	sw	s0,24(sp)
20405c94:	01312623          	sw	s3,12(sp)
20405c98:	00050913          	mv	s2,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20405c9c:	00800493          	li	s1,8
20405ca0:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20405ca4:	80000437          	lui	s0,0x80000
20405ca8:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20405cac:	0084f493          	andi	s1,s1,8
20405cb0:	e1dfe0ef          	jal	ra,20404acc <z_spin_lock_valid>
20405cb4:	04051063          	bnez	a0,20405cf4 <z_ready_thread+0x74>
20405cb8:	204099b7          	lui	s3,0x20409
20405cbc:	204095b7          	lui	a1,0x20409
20405cc0:	20408537          	lui	a0,0x20408
20405cc4:	08100693          	li	a3,129
20405cc8:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405ccc:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20405cd0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405cd4:	b54fb0ef          	jal	ra,20401028 <printk>
20405cd8:	20409537          	lui	a0,0x20409
20405cdc:	02840593          	addi	a1,s0,40
20405ce0:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20405ce4:	b44fb0ef          	jal	ra,20401028 <printk>
20405ce8:	08100593          	li	a1,129
20405cec:	a9098513          	addi	a0,s3,-1392
20405cf0:	a7dfc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20405cf4:	02840513          	addi	a0,s0,40
20405cf8:	e2dfe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
			ready_thread(thread);
20405cfc:	00090513          	mv	a0,s2
20405d00:	e71ff0ef          	jal	ra,20405b70 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20405d04:	02840513          	addi	a0,s0,40
20405d08:	dedfe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20405d0c:	04051063          	bnez	a0,20405d4c <z_ready_thread+0xcc>
20405d10:	20409937          	lui	s2,0x20409
20405d14:	204095b7          	lui	a1,0x20409
20405d18:	20408537          	lui	a0,0x20408
20405d1c:	0ac00693          	li	a3,172
20405d20:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405d24:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405d28:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405d2c:	afcfb0ef          	jal	ra,20401028 <printk>
20405d30:	20409537          	lui	a0,0x20409
20405d34:	02840593          	addi	a1,s0,40
20405d38:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405d3c:	aecfb0ef          	jal	ra,20401028 <printk>
20405d40:	0ac00593          	li	a1,172
20405d44:	a9090513          	addi	a0,s2,-1392
20405d48:	a25fc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20405d4c:	3004a4f3          	csrrs	s1,mstatus,s1
}
20405d50:	01c12083          	lw	ra,28(sp)
20405d54:	01812403          	lw	s0,24(sp)
20405d58:	01412483          	lw	s1,20(sp)
20405d5c:	01012903          	lw	s2,16(sp)
20405d60:	00c12983          	lw	s3,12(sp)
20405d64:	02010113          	addi	sp,sp,32
20405d68:	00008067          	ret

20405d6c <z_sched_start>:
{
20405d6c:	fe010113          	addi	sp,sp,-32
20405d70:	00912a23          	sw	s1,20(sp)
20405d74:	00112e23          	sw	ra,28(sp)
20405d78:	00812c23          	sw	s0,24(sp)
20405d7c:	01212823          	sw	s2,16(sp)
20405d80:	01312623          	sw	s3,12(sp)
20405d84:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20405d88:	00800593          	li	a1,8
20405d8c:	3005b5f3          	csrrc	a1,mstatus,a1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20405d90:	80000437          	lui	s0,0x80000
20405d94:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20405d98:	0085f993          	andi	s3,a1,8
20405d9c:	d31fe0ef          	jal	ra,20404acc <z_spin_lock_valid>
20405da0:	04051063          	bnez	a0,20405de0 <z_sched_start+0x74>
20405da4:	20409937          	lui	s2,0x20409
20405da8:	204095b7          	lui	a1,0x20409
20405dac:	20408537          	lui	a0,0x20408
20405db0:	08100693          	li	a3,129
20405db4:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405db8:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20405dbc:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405dc0:	a68fb0ef          	jal	ra,20401028 <printk>
20405dc4:	20409537          	lui	a0,0x20409
20405dc8:	02840593          	addi	a1,s0,40
20405dcc:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20405dd0:	a58fb0ef          	jal	ra,20401028 <printk>
20405dd4:	08100593          	li	a1,129
20405dd8:	a9090513          	addi	a0,s2,-1392
20405ddc:	991fc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20405de0:	02840513          	addi	a0,s0,40
20405de4:	d41fe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
20405de8:	00d4c783          	lbu	a5,13(s1)
	if (z_has_thread_started(thread)) {
20405dec:	0047f713          	andi	a4,a5,4
20405df0:	06071663          	bnez	a4,20405e5c <z_sched_start+0xf0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20405df4:	02840513          	addi	a0,s0,40
20405df8:	cfdfe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20405dfc:	04051063          	bnez	a0,20405e3c <z_sched_start+0xd0>
20405e00:	204094b7          	lui	s1,0x20409
20405e04:	204095b7          	lui	a1,0x20409
20405e08:	20408537          	lui	a0,0x20408
20405e0c:	0ac00693          	li	a3,172
20405e10:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405e14:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405e18:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405e1c:	a0cfb0ef          	jal	ra,20401028 <printk>
20405e20:	20409537          	lui	a0,0x20409
20405e24:	02840593          	addi	a1,s0,40
20405e28:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405e2c:	9fcfb0ef          	jal	ra,20401028 <printk>
20405e30:	0ac00593          	li	a1,172
20405e34:	a9048513          	addi	a0,s1,-1392
20405e38:	935fc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20405e3c:	3009a5f3          	csrrs	a1,mstatus,s3
}
20405e40:	01c12083          	lw	ra,28(sp)
20405e44:	01812403          	lw	s0,24(sp)
20405e48:	01412483          	lw	s1,20(sp)
20405e4c:	01012903          	lw	s2,16(sp)
20405e50:	00c12983          	lw	s3,12(sp)
20405e54:	02010113          	addi	sp,sp,32
20405e58:	00008067          	ret
	thread->base.thread_state &= ~_THREAD_PRESTART;
20405e5c:	ffb7f793          	andi	a5,a5,-5
	ready_thread(thread);
20405e60:	00048513          	mv	a0,s1
20405e64:	00f486a3          	sb	a5,13(s1)
20405e68:	d09ff0ef          	jal	ra,20405b70 <ready_thread>
	z_reschedule(&sched_spinlock, key);
20405e6c:	02840513          	addi	a0,s0,40
}
20405e70:	01812403          	lw	s0,24(sp)
20405e74:	01c12083          	lw	ra,28(sp)
20405e78:	01412483          	lw	s1,20(sp)
20405e7c:	01012903          	lw	s2,16(sp)
	z_reschedule(&sched_spinlock, key);
20405e80:	00098593          	mv	a1,s3
}
20405e84:	00c12983          	lw	s3,12(sp)
20405e88:	02010113          	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
20405e8c:	d14ff06f          	j	204053a0 <z_reschedule>

20405e90 <z_thread_timeout>:
{
20405e90:	fd010113          	addi	sp,sp,-48
20405e94:	02912223          	sw	s1,36(sp)
20405e98:	02112623          	sw	ra,44(sp)
20405e9c:	02812423          	sw	s0,40(sp)
20405ea0:	03212023          	sw	s2,32(sp)
20405ea4:	01312e23          	sw	s3,28(sp)
20405ea8:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20405eac:	00800793          	li	a5,8
20405eb0:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20405eb4:	80000437          	lui	s0,0x80000
20405eb8:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20405ebc:	0087f993          	andi	s3,a5,8
20405ec0:	c0dfe0ef          	jal	ra,20404acc <z_spin_lock_valid>
20405ec4:	04051063          	bnez	a0,20405f04 <z_thread_timeout+0x74>
20405ec8:	20409937          	lui	s2,0x20409
20405ecc:	204095b7          	lui	a1,0x20409
20405ed0:	20408537          	lui	a0,0x20408
20405ed4:	08100693          	li	a3,129
20405ed8:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405edc:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20405ee0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405ee4:	944fb0ef          	jal	ra,20401028 <printk>
20405ee8:	20409537          	lui	a0,0x20409
20405eec:	02840593          	addi	a1,s0,40
20405ef0:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20405ef4:	934fb0ef          	jal	ra,20401028 <printk>
20405ef8:	08100593          	li	a1,129
20405efc:	a9090513          	addi	a0,s2,-1392
20405f00:	86dfc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20405f04:	02840513          	addi	a0,s0,40
20405f08:	c1dfe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
		if (!killed) {
20405f0c:	ff54c783          	lbu	a5,-11(s1)
20405f10:	0287f793          	andi	a5,a5,40
20405f14:	02079663          	bnez	a5,20405f40 <z_thread_timeout+0xb0>
			if (thread->base.pended_on != NULL) {
20405f18:	ff04a783          	lw	a5,-16(s1)
	struct k_thread *thread = CONTAINER_OF(timeout,
20405f1c:	fe848513          	addi	a0,s1,-24
			if (thread->base.pended_on != NULL) {
20405f20:	00078863          	beqz	a5,20405f30 <z_thread_timeout+0xa0>
				unpend_thread_no_timeout(thread);
20405f24:	00a12623          	sw	a0,12(sp)
20405f28:	fa4ff0ef          	jal	ra,204056cc <unpend_thread_no_timeout>
20405f2c:	00c12503          	lw	a0,12(sp)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
20405f30:	ff54c783          	lbu	a5,-11(s1)
20405f34:	feb7f793          	andi	a5,a5,-21
20405f38:	fef48aa3          	sb	a5,-11(s1)
			ready_thread(thread);
20405f3c:	c35ff0ef          	jal	ra,20405b70 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20405f40:	02840513          	addi	a0,s0,40
20405f44:	bb1fe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20405f48:	04051063          	bnez	a0,20405f88 <z_thread_timeout+0xf8>
20405f4c:	204094b7          	lui	s1,0x20409
20405f50:	204095b7          	lui	a1,0x20409
20405f54:	20408537          	lui	a0,0x20408
20405f58:	0ac00693          	li	a3,172
20405f5c:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20405f60:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20405f64:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20405f68:	8c0fb0ef          	jal	ra,20401028 <printk>
20405f6c:	20409537          	lui	a0,0x20409
20405f70:	02840593          	addi	a1,s0,40
20405f74:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20405f78:	8b0fb0ef          	jal	ra,20401028 <printk>
20405f7c:	0ac00593          	li	a1,172
20405f80:	a9048513          	addi	a0,s1,-1392
20405f84:	fe8fc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20405f88:	3009a7f3          	csrrs	a5,mstatus,s3
}
20405f8c:	02c12083          	lw	ra,44(sp)
20405f90:	02812403          	lw	s0,40(sp)
20405f94:	02412483          	lw	s1,36(sp)
20405f98:	02012903          	lw	s2,32(sp)
20405f9c:	01c12983          	lw	s3,28(sp)
20405fa0:	03010113          	addi	sp,sp,48
20405fa4:	00008067          	ret

20405fa8 <unready_thread>:
{
20405fa8:	ff010113          	addi	sp,sp,-16
20405fac:	00812423          	sw	s0,8(sp)
20405fb0:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
20405fb4:	00d54783          	lbu	a5,13(a0)
20405fb8:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
20405fbc:	01879713          	slli	a4,a5,0x18
20405fc0:	41875713          	srai	a4,a4,0x18
20405fc4:	00075e63          	bgez	a4,20405fe0 <unready_thread+0x38>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20405fc8:	07f7f793          	andi	a5,a5,127
20405fcc:	00f506a3          	sb	a5,13(a0)
	_priq_run_remove(thread_runq(thread), thread);
20405fd0:	00050593          	mv	a1,a0
20405fd4:	80000537          	lui	a0,0x80000
20405fd8:	2e850513          	addi	a0,a0,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
20405fdc:	e78ff0ef          	jal	ra,20405654 <z_priq_dumb_remove>
	update_cache(thread == _current);
20405fe0:	800007b7          	lui	a5,0x80000
20405fe4:	2d47a503          	lw	a0,724(a5) # 800002d4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002d5>
}
20405fe8:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
20405fec:	40850533          	sub	a0,a0,s0
}
20405ff0:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
20405ff4:	00153513          	seqz	a0,a0
}
20405ff8:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
20405ffc:	84dff06f          	j	20405848 <update_cache>

20406000 <add_to_waitq_locked>:
{
20406000:	ff010113          	addi	sp,sp,-16
20406004:	00812423          	sw	s0,8(sp)
20406008:	00912223          	sw	s1,4(sp)
2040600c:	00050413          	mv	s0,a0
20406010:	00112623          	sw	ra,12(sp)
20406014:	01212023          	sw	s2,0(sp)
20406018:	00058493          	mv	s1,a1
	unready_thread(thread);
2040601c:	f8dff0ef          	jal	ra,20405fa8 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
20406020:	00d44783          	lbu	a5,13(s0)
20406024:	0027e793          	ori	a5,a5,2
20406028:	00f406a3          	sb	a5,13(s0)
	if (wait_q != NULL) {
2040602c:	06048a63          	beqz	s1,204060a0 <add_to_waitq_locked+0xa0>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
20406030:	800007b7          	lui	a5,0x80000
		thread->base.pended_on = wait_q;
20406034:	00942423          	sw	s1,8(s0)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
20406038:	1c078793          	addi	a5,a5,448 # 800001c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800001c1>
2040603c:	02f41863          	bne	s0,a5,2040606c <add_to_waitq_locked+0x6c>
20406040:	20409937          	lui	s2,0x20409
20406044:	204095b7          	lui	a1,0x20409
20406048:	20408537          	lui	a0,0x20408
2040604c:	e3058593          	addi	a1,a1,-464 # 20408e30 <levels.0+0x318>
20406050:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406054:	0ba00693          	li	a3,186
20406058:	e0c90613          	addi	a2,s2,-500 # 20408e0c <levels.0+0x2f4>
2040605c:	fcdfa0ef          	jal	ra,20401028 <printk>
20406060:	0ba00593          	li	a1,186
20406064:	e0c90513          	addi	a0,s2,-500
20406068:	f04fc0ef          	jal	ra,2040276c <assert_post_action>
	return list->head == list;
2040606c:	0004a783          	lw	a5,0(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20406070:	04f48c63          	beq	s1,a5,204060c8 <add_to_waitq_locked+0xc8>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20406074:	04078a63          	beqz	a5,204060c8 <add_to_waitq_locked+0xc8>
	int32_t b1 = thread_1->base.prio;
20406078:	00e40683          	lb	a3,14(s0)
	int32_t b2 = thread_2->base.prio;
2040607c:	00e78703          	lb	a4,14(a5)
	if (b1 != b2) {
20406080:	02e68c63          	beq	a3,a4,204060b8 <add_to_waitq_locked+0xb8>
		return b2 - b1;
20406084:	40d70733          	sub	a4,a4,a3
		if (z_sched_prio_cmp(thread, t) > 0) {
20406088:	02e05863          	blez	a4,204060b8 <add_to_waitq_locked+0xb8>
	sys_dnode_t *const prev = successor->prev;
2040608c:	0047a703          	lw	a4,4(a5)
	node->next = successor;
20406090:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
20406094:	00e42223          	sw	a4,4(s0)
	prev->next = node;
20406098:	00872023          	sw	s0,0(a4)
	successor->prev = node;
2040609c:	0087a223          	sw	s0,4(a5)
}
204060a0:	00c12083          	lw	ra,12(sp)
204060a4:	00812403          	lw	s0,8(sp)
204060a8:	00412483          	lw	s1,4(sp)
204060ac:	00012903          	lw	s2,0(sp)
204060b0:	01010113          	addi	sp,sp,16
204060b4:	00008067          	ret
	return (node == list->tail) ? NULL : node->next;
204060b8:	0044a703          	lw	a4,4(s1)
204060bc:	00e78663          	beq	a5,a4,204060c8 <add_to_waitq_locked+0xc8>
204060c0:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
204060c4:	fa079ce3          	bnez	a5,2040607c <add_to_waitq_locked+0x7c>
	sys_dnode_t *const tail = list->tail;
204060c8:	0044a783          	lw	a5,4(s1)
	node->next = list;
204060cc:	00942023          	sw	s1,0(s0)
	node->prev = tail;
204060d0:	00f42223          	sw	a5,4(s0)
	tail->next = node;
204060d4:	0087a023          	sw	s0,0(a5)
	list->tail = node;
204060d8:	0084a223          	sw	s0,4(s1)
}
204060dc:	fc5ff06f          	j	204060a0 <add_to_waitq_locked+0xa0>

204060e0 <pend>:
{
204060e0:	fe010113          	addi	sp,sp,-32
204060e4:	00912a23          	sw	s1,20(sp)
204060e8:	01312623          	sw	s3,12(sp)
204060ec:	01412423          	sw	s4,8(sp)
204060f0:	01512223          	sw	s5,4(sp)
204060f4:	00112e23          	sw	ra,28(sp)
204060f8:	00812c23          	sw	s0,24(sp)
204060fc:	01212823          	sw	s2,16(sp)
20406100:	01612023          	sw	s6,0(sp)
20406104:	00050993          	mv	s3,a0
20406108:	00058493          	mv	s1,a1
2040610c:	00060a93          	mv	s5,a2
20406110:	00068a13          	mv	s4,a3
	__asm__ volatile ("csrrc %0, mstatus, %1"
20406114:	00800793          	li	a5,8
20406118:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
2040611c:	80000437          	lui	s0,0x80000
20406120:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20406124:	0087fb13          	andi	s6,a5,8
20406128:	9a5fe0ef          	jal	ra,20404acc <z_spin_lock_valid>
2040612c:	04051063          	bnez	a0,2040616c <pend+0x8c>
20406130:	20409937          	lui	s2,0x20409
20406134:	204095b7          	lui	a1,0x20409
20406138:	20408537          	lui	a0,0x20408
2040613c:	08100693          	li	a3,129
20406140:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406144:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20406148:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040614c:	eddfa0ef          	jal	ra,20401028 <printk>
20406150:	20409537          	lui	a0,0x20409
20406154:	02840593          	addi	a1,s0,40
20406158:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
2040615c:	ecdfa0ef          	jal	ra,20401028 <printk>
20406160:	08100593          	li	a1,129
20406164:	a9090513          	addi	a0,s2,-1392
20406168:	e04fc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
2040616c:	02840513          	addi	a0,s0,40
20406170:	9b5fe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
		add_to_waitq_locked(thread, wait_q);
20406174:	00098513          	mv	a0,s3
20406178:	00048593          	mv	a1,s1
2040617c:	e85ff0ef          	jal	ra,20406000 <add_to_waitq_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20406180:	02840513          	addi	a0,s0,40
20406184:	971fe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20406188:	04051063          	bnez	a0,204061c8 <pend+0xe8>
2040618c:	204094b7          	lui	s1,0x20409
20406190:	204095b7          	lui	a1,0x20409
20406194:	20408537          	lui	a0,0x20408
20406198:	0ac00693          	li	a3,172
2040619c:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204061a0:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
204061a4:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204061a8:	e81fa0ef          	jal	ra,20401028 <printk>
204061ac:	20409537          	lui	a0,0x20409
204061b0:	02840593          	addi	a1,s0,40
204061b4:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
204061b8:	e71fa0ef          	jal	ra,20401028 <printk>
204061bc:	0ac00593          	li	a1,172
204061c0:	a9048513          	addi	a0,s1,-1392
204061c4:	da8fc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204061c8:	300b27f3          	csrrs	a5,mstatus,s6
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
204061cc:	fff00693          	li	a3,-1
204061d0:	00da9463          	bne	s5,a3,204061d8 <pend+0xf8>
204061d4:	055a0063          	beq	s4,s5,20406214 <pend+0x134>
}
204061d8:	01812403          	lw	s0,24(sp)
204061dc:	01c12083          	lw	ra,28(sp)
204061e0:	01412483          	lw	s1,20(sp)
204061e4:	01012903          	lw	s2,16(sp)
204061e8:	00012b03          	lw	s6,0(sp)
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
204061ec:	000a8613          	mv	a2,s5
204061f0:	000a0693          	mv	a3,s4
204061f4:	00412a83          	lw	s5,4(sp)
204061f8:	00812a03          	lw	s4,8(sp)
204061fc:	01898513          	addi	a0,s3,24
20406200:	00c12983          	lw	s3,12(sp)
20406204:	204065b7          	lui	a1,0x20406
20406208:	e9058593          	addi	a1,a1,-368 # 20405e90 <z_thread_timeout>
2040620c:	02010113          	addi	sp,sp,32
20406210:	57d0006f          	j	20406f8c <z_add_timeout>
20406214:	01c12083          	lw	ra,28(sp)
20406218:	01812403          	lw	s0,24(sp)
2040621c:	01412483          	lw	s1,20(sp)
20406220:	01012903          	lw	s2,16(sp)
20406224:	00c12983          	lw	s3,12(sp)
20406228:	00812a03          	lw	s4,8(sp)
2040622c:	00412a83          	lw	s5,4(sp)
20406230:	00012b03          	lw	s6,0(sp)
20406234:	02010113          	addi	sp,sp,32
20406238:	00008067          	ret

2040623c <z_pend_curr>:
{
2040623c:	ff010113          	addi	sp,sp,-16
	pend(_current, wait_q, timeout);
20406240:	800007b7          	lui	a5,0x80000
{
20406244:	00812423          	sw	s0,8(sp)
20406248:	00050413          	mv	s0,a0
	pend(_current, wait_q, timeout);
2040624c:	2d47a503          	lw	a0,724(a5) # 800002d4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002d5>
{
20406250:	00912223          	sw	s1,4(sp)
20406254:	00058493          	mv	s1,a1
20406258:	00060593          	mv	a1,a2
2040625c:	00068613          	mv	a2,a3
20406260:	00070693          	mv	a3,a4
20406264:	00112623          	sw	ra,12(sp)
20406268:	01212023          	sw	s2,0(sp)
	pend(_current, wait_q, timeout);
2040626c:	e75ff0ef          	jal	ra,204060e0 <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20406270:	00040513          	mv	a0,s0
20406274:	881fe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20406278:	04051063          	bnez	a0,204062b8 <z_pend_curr+0x7c>
2040627c:	20409937          	lui	s2,0x20409
20406280:	204095b7          	lui	a1,0x20409
20406284:	20408537          	lui	a0,0x20408
20406288:	0c300693          	li	a3,195
2040628c:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406290:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20406294:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406298:	d91fa0ef          	jal	ra,20401028 <printk>
2040629c:	20409537          	lui	a0,0x20409
204062a0:	00040593          	mv	a1,s0
204062a4:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
204062a8:	d81fa0ef          	jal	ra,20401028 <printk>
204062ac:	0c300593          	li	a1,195
204062b0:	a9090513          	addi	a0,s2,-1392
204062b4:	cb8fc0ef          	jal	ra,2040276c <assert_post_action>
}
204062b8:	00812403          	lw	s0,8(sp)
204062bc:	00c12083          	lw	ra,12(sp)
204062c0:	00012903          	lw	s2,0(sp)
204062c4:	00048513          	mv	a0,s1
204062c8:	00412483          	lw	s1,4(sp)
204062cc:	01010113          	addi	sp,sp,16
204062d0:	ff1f906f          	j	204002c0 <arch_swap>

204062d4 <z_impl_k_thread_suspend>:
{
204062d4:	fe010113          	addi	sp,sp,-32
204062d8:	00812c23          	sw	s0,24(sp)
204062dc:	00050413          	mv	s0,a0
	return z_abort_timeout(&thread->base.timeout);
204062e0:	01850513          	addi	a0,a0,24
204062e4:	01212823          	sw	s2,16(sp)
204062e8:	00112e23          	sw	ra,28(sp)
204062ec:	00912a23          	sw	s1,20(sp)
204062f0:	01312623          	sw	s3,12(sp)
204062f4:	01412423          	sw	s4,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
204062f8:	00800913          	li	s2,8
204062fc:	72d000ef          	jal	ra,20407228 <z_abort_timeout>
20406300:	30093973          	csrrc	s2,mstatus,s2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20406304:	800004b7          	lui	s1,0x80000
20406308:	02848513          	addi	a0,s1,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
2040630c:	00897913          	andi	s2,s2,8
20406310:	fbcfe0ef          	jal	ra,20404acc <z_spin_lock_valid>
20406314:	04051063          	bnez	a0,20406354 <z_impl_k_thread_suspend+0x80>
20406318:	204099b7          	lui	s3,0x20409
2040631c:	204095b7          	lui	a1,0x20409
20406320:	20408537          	lui	a0,0x20408
20406324:	08100693          	li	a3,129
20406328:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
2040632c:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20406330:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406334:	cf5fa0ef          	jal	ra,20401028 <printk>
20406338:	20409537          	lui	a0,0x20409
2040633c:	02848593          	addi	a1,s1,40
20406340:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20406344:	ce5fa0ef          	jal	ra,20401028 <printk>
20406348:	08100593          	li	a1,129
2040634c:	a9098513          	addi	a0,s3,-1392
20406350:	c1cfc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20406354:	02848513          	addi	a0,s1,40
20406358:	fccfe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	return (thread->base.thread_state & state) != 0U;
2040635c:	00d44783          	lbu	a5,13(s0)
		if (z_is_thread_queued(thread)) {
20406360:	01879713          	slli	a4,a5,0x18
20406364:	41875713          	srai	a4,a4,0x18
20406368:	00075e63          	bgez	a4,20406384 <z_impl_k_thread_suspend+0xb0>
	thread->base.thread_state &= ~_THREAD_QUEUED;
2040636c:	07f7f793          	andi	a5,a5,127
	_priq_run_remove(thread_runq(thread), thread);
20406370:	80000537          	lui	a0,0x80000
	thread->base.thread_state &= ~_THREAD_QUEUED;
20406374:	00f406a3          	sb	a5,13(s0)
	_priq_run_remove(thread_runq(thread), thread);
20406378:	00040593          	mv	a1,s0
2040637c:	2e850513          	addi	a0,a0,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
20406380:	ad4ff0ef          	jal	ra,20405654 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
20406384:	00d44783          	lbu	a5,13(s0)
		update_cache(thread == _current);
20406388:	800009b7          	lui	s3,0x80000
2040638c:	0107e793          	ori	a5,a5,16
20406390:	00f406a3          	sb	a5,13(s0)
20406394:	2cc98793          	addi	a5,s3,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20406398:	0087a503          	lw	a0,8(a5)
2040639c:	2cc98993          	addi	s3,s3,716
204063a0:	40850533          	sub	a0,a0,s0
204063a4:	00153513          	seqz	a0,a0
204063a8:	ca0ff0ef          	jal	ra,20405848 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204063ac:	02848513          	addi	a0,s1,40
204063b0:	f44fe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204063b4:	04051063          	bnez	a0,204063f4 <z_impl_k_thread_suspend+0x120>
204063b8:	20409a37          	lui	s4,0x20409
204063bc:	204095b7          	lui	a1,0x20409
204063c0:	20408537          	lui	a0,0x20408
204063c4:	0ac00693          	li	a3,172
204063c8:	a90a0613          	addi	a2,s4,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204063cc:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
204063d0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204063d4:	c55fa0ef          	jal	ra,20401028 <printk>
204063d8:	20409537          	lui	a0,0x20409
204063dc:	02848593          	addi	a1,s1,40
204063e0:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
204063e4:	c45fa0ef          	jal	ra,20401028 <printk>
204063e8:	0ac00593          	li	a1,172
204063ec:	a90a0513          	addi	a0,s4,-1392
204063f0:	b7cfc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204063f4:	30092973          	csrrs	s2,mstatus,s2
	if (thread == _current) {
204063f8:	0089a783          	lw	a5,8(s3)
204063fc:	02879263          	bne	a5,s0,20406420 <z_impl_k_thread_suspend+0x14c>
}
20406400:	01812403          	lw	s0,24(sp)
20406404:	01c12083          	lw	ra,28(sp)
20406408:	01412483          	lw	s1,20(sp)
2040640c:	01012903          	lw	s2,16(sp)
20406410:	00c12983          	lw	s3,12(sp)
20406414:	00812a03          	lw	s4,8(sp)
20406418:	02010113          	addi	sp,sp,32
		z_reschedule_unlocked();
2040641c:	8a8ff06f          	j	204054c4 <z_reschedule_unlocked>
}
20406420:	01c12083          	lw	ra,28(sp)
20406424:	01812403          	lw	s0,24(sp)
20406428:	01412483          	lw	s1,20(sp)
2040642c:	01012903          	lw	s2,16(sp)
20406430:	00c12983          	lw	s3,12(sp)
20406434:	00812a03          	lw	s4,8(sp)
20406438:	02010113          	addi	sp,sp,32
2040643c:	00008067          	ret

20406440 <k_sched_unlock>:
{
20406440:	fe010113          	addi	sp,sp,-32
20406444:	00112e23          	sw	ra,28(sp)
20406448:	00812c23          	sw	s0,24(sp)
2040644c:	00912a23          	sw	s1,20(sp)
20406450:	01212823          	sw	s2,16(sp)
20406454:	01312623          	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20406458:	00800793          	li	a5,8
2040645c:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20406460:	80000437          	lui	s0,0x80000
20406464:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20406468:	0087f993          	andi	s3,a5,8
2040646c:	e60fe0ef          	jal	ra,20404acc <z_spin_lock_valid>
20406470:	04051063          	bnez	a0,204064b0 <k_sched_unlock+0x70>
20406474:	204094b7          	lui	s1,0x20409
20406478:	204095b7          	lui	a1,0x20409
2040647c:	20408537          	lui	a0,0x20408
20406480:	08100693          	li	a3,129
20406484:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406488:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
2040648c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406490:	b99fa0ef          	jal	ra,20401028 <printk>
20406494:	20409537          	lui	a0,0x20409
20406498:	02840593          	addi	a1,s0,40
2040649c:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204064a0:	b89fa0ef          	jal	ra,20401028 <printk>
204064a4:	08100593          	li	a1,129
204064a8:	a9048513          	addi	a0,s1,-1392
204064ac:	ac0fc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
204064b0:	02840513          	addi	a0,s0,40
204064b4:	e70fe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0U, "");
204064b8:	800004b7          	lui	s1,0x80000
204064bc:	2cc48793          	addi	a5,s1,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
204064c0:	0087a783          	lw	a5,8(a5)
204064c4:	2cc48493          	addi	s1,s1,716
204064c8:	00f7c783          	lbu	a5,15(a5)
204064cc:	02079e63          	bnez	a5,20406508 <k_sched_unlock+0xc8>
204064d0:	20409937          	lui	s2,0x20409
204064d4:	204095b7          	lui	a1,0x20409
204064d8:	20408537          	lui	a0,0x20408
204064dc:	e9458593          	addi	a1,a1,-364 # 20408e94 <levels.0+0x37c>
204064e0:	38500693          	li	a3,901
204064e4:	e0c90613          	addi	a2,s2,-500 # 20408e0c <levels.0+0x2f4>
204064e8:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204064ec:	b3dfa0ef          	jal	ra,20401028 <printk>
204064f0:	20409537          	lui	a0,0x20409
204064f4:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
204064f8:	b31fa0ef          	jal	ra,20401028 <printk>
204064fc:	38500593          	li	a1,901
20406500:	e0c90513          	addi	a0,s2,-500
20406504:	a68fc0ef          	jal	ra,2040276c <assert_post_action>
		__ASSERT(!arch_is_in_isr(), "");
20406508:	0004a783          	lw	a5,0(s1)
2040650c:	02078e63          	beqz	a5,20406548 <k_sched_unlock+0x108>
20406510:	20409937          	lui	s2,0x20409
20406514:	204095b7          	lui	a1,0x20409
20406518:	20408537          	lui	a0,0x20408
2040651c:	dc458593          	addi	a1,a1,-572 # 20408dc4 <levels.0+0x2ac>
20406520:	38600693          	li	a3,902
20406524:	e0c90613          	addi	a2,s2,-500 # 20408e0c <levels.0+0x2f4>
20406528:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040652c:	afdfa0ef          	jal	ra,20401028 <printk>
20406530:	20409537          	lui	a0,0x20409
20406534:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
20406538:	af1fa0ef          	jal	ra,20401028 <printk>
2040653c:	38600593          	li	a1,902
20406540:	e0c90513          	addi	a0,s2,-500
20406544:	a28fc0ef          	jal	ra,2040276c <assert_post_action>
		++_current->base.sched_locked;
20406548:	0084a703          	lw	a4,8(s1)
		update_cache(0);
2040654c:	00000513          	li	a0,0
		++_current->base.sched_locked;
20406550:	00f74783          	lbu	a5,15(a4)
20406554:	00178793          	addi	a5,a5,1
20406558:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
2040655c:	aecff0ef          	jal	ra,20405848 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20406560:	02840513          	addi	a0,s0,40
20406564:	d90fe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20406568:	04051063          	bnez	a0,204065a8 <k_sched_unlock+0x168>
2040656c:	204094b7          	lui	s1,0x20409
20406570:	204095b7          	lui	a1,0x20409
20406574:	20408537          	lui	a0,0x20408
20406578:	0ac00693          	li	a3,172
2040657c:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406580:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20406584:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406588:	aa1fa0ef          	jal	ra,20401028 <printk>
2040658c:	20409537          	lui	a0,0x20409
20406590:	02840593          	addi	a1,s0,40
20406594:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20406598:	a91fa0ef          	jal	ra,20401028 <printk>
2040659c:	0ac00593          	li	a1,172
204065a0:	a9048513          	addi	a0,s1,-1392
204065a4:	9c8fc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204065a8:	3009a7f3          	csrrs	a5,mstatus,s3
}
204065ac:	01812403          	lw	s0,24(sp)
204065b0:	01c12083          	lw	ra,28(sp)
204065b4:	01412483          	lw	s1,20(sp)
204065b8:	01012903          	lw	s2,16(sp)
204065bc:	00c12983          	lw	s3,12(sp)
204065c0:	02010113          	addi	sp,sp,32
	z_reschedule_unlocked();
204065c4:	f01fe06f          	j	204054c4 <z_reschedule_unlocked>

204065c8 <z_unpend_first_thread>:
{
204065c8:	fe010113          	addi	sp,sp,-32
204065cc:	00912a23          	sw	s1,20(sp)
204065d0:	00112e23          	sw	ra,28(sp)
204065d4:	00812c23          	sw	s0,24(sp)
204065d8:	01212823          	sw	s2,16(sp)
204065dc:	01312623          	sw	s3,12(sp)
204065e0:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
204065e4:	00800793          	li	a5,8
204065e8:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
204065ec:	80000437          	lui	s0,0x80000
204065f0:	02840513          	addi	a0,s0,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
204065f4:	0087f993          	andi	s3,a5,8
204065f8:	cd4fe0ef          	jal	ra,20404acc <z_spin_lock_valid>
204065fc:	04051063          	bnez	a0,2040663c <z_unpend_first_thread+0x74>
20406600:	20409937          	lui	s2,0x20409
20406604:	204095b7          	lui	a1,0x20409
20406608:	20408537          	lui	a0,0x20408
2040660c:	08100693          	li	a3,129
20406610:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406614:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20406618:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040661c:	a0dfa0ef          	jal	ra,20401028 <printk>
20406620:	20409537          	lui	a0,0x20409
20406624:	02840593          	addi	a1,s0,40
20406628:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
2040662c:	9fdfa0ef          	jal	ra,20401028 <printk>
20406630:	08100593          	li	a1,129
20406634:	a9090513          	addi	a0,s2,-1392
20406638:	934fc0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
2040663c:	02840513          	addi	a0,s0,40
20406640:	ce4fe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
20406644:	00048513          	mv	a0,s1
20406648:	9ecff0ef          	jal	ra,20405834 <z_priq_dumb_best>
2040664c:	00050493          	mv	s1,a0
		if (thread != NULL) {
20406650:	00050863          	beqz	a0,20406660 <z_unpend_first_thread+0x98>
			unpend_thread_no_timeout(thread);
20406654:	878ff0ef          	jal	ra,204056cc <unpend_thread_no_timeout>
20406658:	01848513          	addi	a0,s1,24
2040665c:	3cd000ef          	jal	ra,20407228 <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20406660:	02840513          	addi	a0,s0,40
20406664:	c90fe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20406668:	04051063          	bnez	a0,204066a8 <z_unpend_first_thread+0xe0>
2040666c:	20409937          	lui	s2,0x20409
20406670:	204095b7          	lui	a1,0x20409
20406674:	20408537          	lui	a0,0x20408
20406678:	0ac00693          	li	a3,172
2040667c:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406680:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20406684:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406688:	9a1fa0ef          	jal	ra,20401028 <printk>
2040668c:	20409537          	lui	a0,0x20409
20406690:	02840593          	addi	a1,s0,40
20406694:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20406698:	991fa0ef          	jal	ra,20401028 <printk>
2040669c:	0ac00593          	li	a1,172
204066a0:	a9090513          	addi	a0,s2,-1392
204066a4:	8c8fc0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204066a8:	3009a7f3          	csrrs	a5,mstatus,s3
}
204066ac:	01c12083          	lw	ra,28(sp)
204066b0:	01812403          	lw	s0,24(sp)
204066b4:	01012903          	lw	s2,16(sp)
204066b8:	00c12983          	lw	s3,12(sp)
204066bc:	00048513          	mv	a0,s1
204066c0:	01412483          	lw	s1,20(sp)
204066c4:	02010113          	addi	sp,sp,32
204066c8:	00008067          	ret

204066cc <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
204066cc:	ff010113          	addi	sp,sp,-16
204066d0:	00912223          	sw	s1,4(sp)
204066d4:	00112623          	sw	ra,12(sp)
204066d8:	00050493          	mv	s1,a0
204066dc:	00812423          	sw	s0,8(sp)
	int need_sched = 0;
204066e0:	00000513          	li	a0,0
	return list->head == list;
204066e4:	0004a403          	lw	s0,0(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
204066e8:	00848463          	beq	s1,s0,204066f0 <z_unpend_all+0x24>
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
204066ec:	00041c63          	bnez	s0,20406704 <z_unpend_all+0x38>
		z_ready_thread(thread);
		need_sched = 1;
	}

	return need_sched;
}
204066f0:	00c12083          	lw	ra,12(sp)
204066f4:	00812403          	lw	s0,8(sp)
204066f8:	00412483          	lw	s1,4(sp)
204066fc:	01010113          	addi	sp,sp,16
20406700:	00008067          	ret
		z_unpend_thread(thread);
20406704:	00040513          	mv	a0,s0
20406708:	83cff0ef          	jal	ra,20405744 <z_unpend_thread>
		z_ready_thread(thread);
2040670c:	00040513          	mv	a0,s0
20406710:	d70ff0ef          	jal	ra,20405c80 <z_ready_thread>
		need_sched = 1;
20406714:	00100513          	li	a0,1
20406718:	fcdff06f          	j	204066e4 <z_unpend_all+0x18>

2040671c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
2040671c:	800007b7          	lui	a5,0x80000
20406720:	80000737          	lui	a4,0x80000
20406724:	2cc78793          	addi	a5,a5,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20406728:	2e870713          	addi	a4,a4,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
2040672c:	00e7ae23          	sw	a4,28(a5)
	list->tail = (sys_dnode_t *)list;
20406730:	02e7a023          	sw	a4,32(a5)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
20406734:	00000593          	li	a1,0
20406738:	00000513          	li	a0,0
2040673c:	b21fe06f          	j	2040525c <k_sched_time_slice_set>

20406740 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
20406740:	fe010113          	addi	sp,sp,-32
20406744:	00912a23          	sw	s1,20(sp)
20406748:	800004b7          	lui	s1,0x80000
	__ASSERT(!arch_is_in_isr(), "");
2040674c:	2cc4a783          	lw	a5,716(s1) # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
{
20406750:	00112e23          	sw	ra,28(sp)
20406754:	00812c23          	sw	s0,24(sp)
20406758:	01212823          	sw	s2,16(sp)
2040675c:	01312623          	sw	s3,12(sp)
20406760:	01412423          	sw	s4,8(sp)
20406764:	2cc48493          	addi	s1,s1,716
	__ASSERT(!arch_is_in_isr(), "");
20406768:	02078e63          	beqz	a5,204067a4 <z_impl_k_yield+0x64>
2040676c:	20409437          	lui	s0,0x20409
20406770:	204095b7          	lui	a1,0x20409
20406774:	20408537          	lui	a0,0x20408
20406778:	dc458593          	addi	a1,a1,-572 # 20408dc4 <levels.0+0x2ac>
2040677c:	4dc00693          	li	a3,1244
20406780:	e0c40613          	addi	a2,s0,-500 # 20408e0c <levels.0+0x2f4>
20406784:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406788:	8a1fa0ef          	jal	ra,20401028 <printk>
2040678c:	20409537          	lui	a0,0x20409
20406790:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
20406794:	895fa0ef          	jal	ra,20401028 <printk>
20406798:	4dc00593          	li	a1,1244
2040679c:	e0c40513          	addi	a0,s0,-500
204067a0:	fcdfb0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrc %0, mstatus, %1"
204067a4:	00800993          	li	s3,8
204067a8:	3009b9f3          	csrrc	s3,mstatus,s3
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
204067ac:	80000937          	lui	s2,0x80000
204067b0:	02890513          	addi	a0,s2,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
204067b4:	0089f993          	andi	s3,s3,8
204067b8:	b14fe0ef          	jal	ra,20404acc <z_spin_lock_valid>
204067bc:	04051063          	bnez	a0,204067fc <z_impl_k_yield+0xbc>
204067c0:	20409437          	lui	s0,0x20409
204067c4:	204095b7          	lui	a1,0x20409
204067c8:	20408537          	lui	a0,0x20408
204067cc:	08100693          	li	a3,129
204067d0:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204067d4:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
204067d8:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204067dc:	84dfa0ef          	jal	ra,20401028 <printk>
204067e0:	20409537          	lui	a0,0x20409
204067e4:	02890593          	addi	a1,s2,40
204067e8:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204067ec:	83dfa0ef          	jal	ra,20401028 <printk>
204067f0:	08100593          	li	a1,129
204067f4:	a9040513          	addi	a0,s0,-1392
204067f8:	f75fb0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
204067fc:	02890513          	addi	a0,s2,40
20406800:	b24fe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
20406804:	0084a583          	lw	a1,8(s1)
	_priq_run_remove(thread_runq(thread), thread);
20406808:	80000537          	lui	a0,0x80000
2040680c:	2e850513          	addi	a0,a0,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20406810:	00d5c783          	lbu	a5,13(a1)
20406814:	07f7f793          	andi	a5,a5,127
20406818:	00f586a3          	sb	a5,13(a1)
	_priq_run_remove(thread_runq(thread), thread);
2040681c:	e39fe0ef          	jal	ra,20405654 <z_priq_dumb_remove>
	}
	queue_thread(_current);
20406820:	0084a403          	lw	s0,8(s1)
	thread->base.thread_state |= _THREAD_QUEUED;
20406824:	00d44783          	lbu	a5,13(s0)
20406828:	f807e793          	ori	a5,a5,-128
2040682c:	00f406a3          	sb	a5,13(s0)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
20406830:	800007b7          	lui	a5,0x80000
20406834:	1c078793          	addi	a5,a5,448 # 800001c0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800001c1>
20406838:	02f41863          	bne	s0,a5,20406868 <z_impl_k_yield+0x128>
2040683c:	20409a37          	lui	s4,0x20409
20406840:	204095b7          	lui	a1,0x20409
20406844:	20408537          	lui	a0,0x20408
20406848:	e3058593          	addi	a1,a1,-464 # 20408e30 <levels.0+0x318>
2040684c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406850:	0ba00693          	li	a3,186
20406854:	e0ca0613          	addi	a2,s4,-500 # 20408e0c <levels.0+0x2f4>
20406858:	fd0fa0ef          	jal	ra,20401028 <printk>
2040685c:	0ba00593          	li	a1,186
20406860:	e0ca0513          	addi	a0,s4,-500
20406864:	f09fb0ef          	jal	ra,2040276c <assert_post_action>
	return list->head == list;
20406868:	01c4a783          	lw	a5,28(s1)
2040686c:	80000737          	lui	a4,0x80000
20406870:	2e870713          	addi	a4,a4,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
	return (node == list->tail) ? NULL : node->next;
20406874:	0204a603          	lw	a2,32(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20406878:	0ae78863          	beq	a5,a4,20406928 <z_impl_k_yield+0x1e8>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
2040687c:	0a078663          	beqz	a5,20406928 <z_impl_k_yield+0x1e8>
	int32_t b1 = thread_1->base.prio;
20406880:	00e40583          	lb	a1,14(s0)
	int32_t b2 = thread_2->base.prio;
20406884:	00e78683          	lb	a3,14(a5)
	if (b1 != b2) {
20406888:	08d58a63          	beq	a1,a3,2040691c <z_impl_k_yield+0x1dc>
		return b2 - b1;
2040688c:	40b686b3          	sub	a3,a3,a1
		if (z_sched_prio_cmp(thread, t) > 0) {
20406890:	08d05663          	blez	a3,2040691c <z_impl_k_yield+0x1dc>
	sys_dnode_t *const prev = successor->prev;
20406894:	0047a703          	lw	a4,4(a5)
	node->next = successor;
20406898:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
2040689c:	00e42223          	sw	a4,4(s0)
	prev->next = node;
204068a0:	00872023          	sw	s0,0(a4)
	successor->prev = node;
204068a4:	0087a223          	sw	s0,4(a5)
	update_cache(1);
204068a8:	00100513          	li	a0,1
204068ac:	f9dfe0ef          	jal	ra,20405848 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204068b0:	02890513          	addi	a0,s2,40
204068b4:	a40fe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204068b8:	04051063          	bnez	a0,204068f8 <z_impl_k_yield+0x1b8>
204068bc:	20409437          	lui	s0,0x20409
204068c0:	204095b7          	lui	a1,0x20409
204068c4:	20408537          	lui	a0,0x20408
204068c8:	0c300693          	li	a3,195
204068cc:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204068d0:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
204068d4:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204068d8:	f50fa0ef          	jal	ra,20401028 <printk>
204068dc:	20409537          	lui	a0,0x20409
204068e0:	02890593          	addi	a1,s2,40
204068e4:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
204068e8:	f40fa0ef          	jal	ra,20401028 <printk>
204068ec:	0c300593          	li	a1,195
204068f0:	a9040513          	addi	a0,s0,-1392
204068f4:	e79fb0ef          	jal	ra,2040276c <assert_post_action>
	z_swap(&sched_spinlock, key);
}
204068f8:	01812403          	lw	s0,24(sp)
204068fc:	01c12083          	lw	ra,28(sp)
20406900:	01412483          	lw	s1,20(sp)
20406904:	01012903          	lw	s2,16(sp)
20406908:	00812a03          	lw	s4,8(sp)
2040690c:	00098513          	mv	a0,s3
20406910:	00c12983          	lw	s3,12(sp)
20406914:	02010113          	addi	sp,sp,32
20406918:	9a9f906f          	j	204002c0 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
2040691c:	00c78663          	beq	a5,a2,20406928 <z_impl_k_yield+0x1e8>
20406920:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20406924:	f60790e3          	bnez	a5,20406884 <z_impl_k_yield+0x144>
	node->next = list;
20406928:	00e42023          	sw	a4,0(s0)
	node->prev = tail;
2040692c:	00c42223          	sw	a2,4(s0)
	tail->next = node;
20406930:	00862023          	sw	s0,0(a2)
	list->tail = node;
20406934:	0284a023          	sw	s0,32(s1)
}
20406938:	f71ff06f          	j	204068a8 <z_impl_k_yield+0x168>

2040693c <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
2040693c:	fe010113          	addi	sp,sp,-32
20406940:	00912a23          	sw	s1,20(sp)
20406944:	800004b7          	lui	s1,0x80000
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
20406948:	2cc4a783          	lw	a5,716(s1) # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
{
2040694c:	01312623          	sw	s3,12(sp)
20406950:	01412423          	sw	s4,8(sp)
20406954:	00112e23          	sw	ra,28(sp)
20406958:	00812c23          	sw	s0,24(sp)
2040695c:	01212823          	sw	s2,16(sp)
20406960:	01512223          	sw	s5,4(sp)
20406964:	01612023          	sw	s6,0(sp)
20406968:	00050993          	mv	s3,a0
2040696c:	00058a13          	mv	s4,a1
20406970:	2cc48493          	addi	s1,s1,716
	__ASSERT(!arch_is_in_isr(), "");
20406974:	02078e63          	beqz	a5,204069b0 <z_tick_sleep+0x74>
20406978:	20409437          	lui	s0,0x20409
2040697c:	204095b7          	lui	a1,0x20409
20406980:	20408537          	lui	a0,0x20408
20406984:	dc458593          	addi	a1,a1,-572 # 20408dc4 <levels.0+0x2ac>
20406988:	4f800693          	li	a3,1272
2040698c:	e0c40613          	addi	a2,s0,-500 # 20408e0c <levels.0+0x2f4>
20406990:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406994:	e94fa0ef          	jal	ra,20401028 <printk>
20406998:	20409537          	lui	a0,0x20409
2040699c:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
204069a0:	e88fa0ef          	jal	ra,20401028 <printk>
204069a4:	4f800593          	li	a1,1272
204069a8:	e0c40513          	addi	a0,s0,-500
204069ac:	dc1fb0ef          	jal	ra,2040276c <assert_post_action>
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
204069b0:	0149e7b3          	or	a5,s3,s4
204069b4:	00079863          	bnez	a5,204069c4 <z_tick_sleep+0x88>
	z_impl_k_yield();
204069b8:	d89ff0ef          	jal	ra,20406740 <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
204069bc:	00000513          	li	a0,0
204069c0:	1740006f          	j	20406b34 <z_tick_sleep+0x1f8>
	if (Z_TICK_ABS(ticks) <= 0) {
204069c4:	ffe00793          	li	a5,-2
204069c8:	413786b3          	sub	a3,a5,s3
204069cc:	00d7b733          	sltu	a4,a5,a3
204069d0:	fffa4793          	not	a5,s4
204069d4:	40e787b3          	sub	a5,a5,a4
204069d8:	18f04263          	bgtz	a5,20406b5c <z_tick_sleep+0x220>
204069dc:	00079463          	bnez	a5,204069e4 <z_tick_sleep+0xa8>
204069e0:	16069e63          	bnez	a3,20406b5c <z_tick_sleep+0x220>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
204069e4:	5f5000ef          	jal	ra,204077d8 <sys_clock_tick_get_32>
204069e8:	01350433          	add	s0,a0,s3
	__asm__ volatile ("csrrc %0, mstatus, %1"
204069ec:	00800513          	li	a0,8
204069f0:	30053573          	csrrc	a0,mstatus,a0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
204069f4:	80000937          	lui	s2,0x80000
	key = (mstatus & MSTATUS_IEN);
204069f8:	00857b13          	andi	s6,a0,8
204069fc:	02890513          	addi	a0,s2,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
20406a00:	8ccfe0ef          	jal	ra,20404acc <z_spin_lock_valid>
20406a04:	04051063          	bnez	a0,20406a44 <z_tick_sleep+0x108>
20406a08:	20409ab7          	lui	s5,0x20409
20406a0c:	204095b7          	lui	a1,0x20409
20406a10:	20408537          	lui	a0,0x20408
20406a14:	08100693          	li	a3,129
20406a18:	a90a8613          	addi	a2,s5,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406a1c:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20406a20:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406a24:	e04fa0ef          	jal	ra,20401028 <printk>
20406a28:	20409537          	lui	a0,0x20409
20406a2c:	02890593          	addi	a1,s2,40
20406a30:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20406a34:	df4fa0ef          	jal	ra,20401028 <printk>
20406a38:	08100593          	li	a1,129
20406a3c:	a90a8513          	addi	a0,s5,-1392
20406a40:	d2dfb0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20406a44:	02890513          	addi	a0,s2,40
20406a48:	8dcfe0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	unready_thread(_current);
20406a4c:	0084a503          	lw	a0,8(s1)
20406a50:	d58ff0ef          	jal	ra,20405fa8 <unready_thread>
	z_add_thread_timeout(_current, timeout);
20406a54:	0084a503          	lw	a0,8(s1)
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
20406a58:	204065b7          	lui	a1,0x20406
20406a5c:	00098613          	mv	a2,s3
20406a60:	01850513          	addi	a0,a0,24
20406a64:	000a0693          	mv	a3,s4
20406a68:	e9058593          	addi	a1,a1,-368 # 20405e90 <z_thread_timeout>
20406a6c:	520000ef          	jal	ra,20406f8c <z_add_timeout>
	z_mark_thread_as_suspended(_current);
20406a70:	0084a703          	lw	a4,8(s1)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20406a74:	02890513          	addi	a0,s2,40
20406a78:	00d74783          	lbu	a5,13(a4)
20406a7c:	0107e793          	ori	a5,a5,16
20406a80:	00f706a3          	sb	a5,13(a4)
20406a84:	870fe0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20406a88:	04051063          	bnez	a0,20406ac8 <z_tick_sleep+0x18c>
20406a8c:	204099b7          	lui	s3,0x20409
20406a90:	204095b7          	lui	a1,0x20409
20406a94:	20408537          	lui	a0,0x20408
20406a98:	0c300693          	li	a3,195
20406a9c:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406aa0:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20406aa4:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406aa8:	d80fa0ef          	jal	ra,20401028 <printk>
20406aac:	20409537          	lui	a0,0x20409
20406ab0:	02890593          	addi	a1,s2,40
20406ab4:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20406ab8:	d70fa0ef          	jal	ra,20401028 <printk>
20406abc:	0c300593          	li	a1,195
20406ac0:	a9098513          	addi	a0,s3,-1392
20406ac4:	ca9fb0ef          	jal	ra,2040276c <assert_post_action>
20406ac8:	000b0513          	mv	a0,s6
20406acc:	ff4f90ef          	jal	ra,204002c0 <arch_swap>
	return (thread->base.thread_state & state) != 0U;
20406ad0:	0084a783          	lw	a5,8(s1)
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
20406ad4:	00d7c783          	lbu	a5,13(a5)
20406ad8:	0107f793          	andi	a5,a5,16
20406adc:	02078e63          	beqz	a5,20406b18 <z_tick_sleep+0x1dc>
20406ae0:	204094b7          	lui	s1,0x20409
20406ae4:	204095b7          	lui	a1,0x20409
20406ae8:	20408537          	lui	a0,0x20408
20406aec:	ec858593          	addi	a1,a1,-312 # 20408ec8 <levels.0+0x3b0>
20406af0:	51900693          	li	a3,1305
20406af4:	e0c48613          	addi	a2,s1,-500 # 20408e0c <levels.0+0x2f4>
20406af8:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406afc:	d2cfa0ef          	jal	ra,20401028 <printk>
20406b00:	20409537          	lui	a0,0x20409
20406b04:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
20406b08:	d20fa0ef          	jal	ra,20401028 <printk>
20406b0c:	51900593          	li	a1,1305
20406b10:	e0c48513          	addi	a0,s1,-500
20406b14:	c59fb0ef          	jal	ra,2040276c <assert_post_action>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
20406b18:	4c1000ef          	jal	ra,204077d8 <sys_clock_tick_get_32>
20406b1c:	40a407b3          	sub	a5,s0,a0
20406b20:	00f43433          	sltu	s0,s0,a5
20406b24:	40800433          	neg	s0,s0
	if (ticks > 0) {
20406b28:	e8041ae3          	bnez	s0,204069bc <z_tick_sleep+0x80>
		return ticks;
20406b2c:	00078513          	mv	a0,a5
	if (ticks > 0) {
20406b30:	e80786e3          	beqz	a5,204069bc <z_tick_sleep+0x80>
}
20406b34:	01c12083          	lw	ra,28(sp)
20406b38:	01812403          	lw	s0,24(sp)
20406b3c:	01412483          	lw	s1,20(sp)
20406b40:	01012903          	lw	s2,16(sp)
20406b44:	00c12983          	lw	s3,12(sp)
20406b48:	00812a03          	lw	s4,8(sp)
20406b4c:	00412a83          	lw	s5,4(sp)
20406b50:	00012b03          	lw	s6,0(sp)
20406b54:	02010113          	addi	sp,sp,32
20406b58:	00008067          	ret
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
20406b5c:	ffe00413          	li	s0,-2
20406b60:	41340433          	sub	s0,s0,s3
20406b64:	e89ff06f          	j	204069ec <z_tick_sleep+0xb0>

20406b68 <z_impl_k_sleep>:
20406b68:	800007b7          	lui	a5,0x80000

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
20406b6c:	2cc7a703          	lw	a4,716(a5) # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
{
20406b70:	fe010113          	addi	sp,sp,-32
20406b74:	00812c23          	sw	s0,24(sp)
20406b78:	00912a23          	sw	s1,20(sp)
20406b7c:	01212823          	sw	s2,16(sp)
20406b80:	01312623          	sw	s3,12(sp)
20406b84:	01512223          	sw	s5,4(sp)
20406b88:	00112e23          	sw	ra,28(sp)
20406b8c:	01412423          	sw	s4,8(sp)
20406b90:	00050493          	mv	s1,a0
20406b94:	00058413          	mv	s0,a1
20406b98:	00050993          	mv	s3,a0
20406b9c:	00058a93          	mv	s5,a1
20406ba0:	2cc78913          	addi	s2,a5,716
	__ASSERT(!arch_is_in_isr(), "");
20406ba4:	02070e63          	beqz	a4,20406be0 <z_impl_k_sleep+0x78>
20406ba8:	20409a37          	lui	s4,0x20409
20406bac:	204095b7          	lui	a1,0x20409
20406bb0:	20408537          	lui	a0,0x20408
20406bb4:	dc458593          	addi	a1,a1,-572 # 20408dc4 <levels.0+0x2ac>
20406bb8:	52800693          	li	a3,1320
20406bbc:	e0ca0613          	addi	a2,s4,-500 # 20408e0c <levels.0+0x2f4>
20406bc0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406bc4:	c64fa0ef          	jal	ra,20401028 <printk>
20406bc8:	20409537          	lui	a0,0x20409
20406bcc:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
20406bd0:	c58fa0ef          	jal	ra,20401028 <printk>
20406bd4:	52800593          	li	a1,1320
20406bd8:	e0ca0513          	addi	a0,s4,-500
20406bdc:	b91fb0ef          	jal	ra,2040276c <assert_post_action>

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20406be0:	fff00793          	li	a5,-1
20406be4:	02f99c63          	bne	s3,a5,20406c1c <z_impl_k_sleep+0xb4>
20406be8:	033a9a63          	bne	s5,s3,20406c1c <z_impl_k_sleep+0xb4>
		k_thread_suspend(_current);
20406bec:	00892503          	lw	a0,8(s2)
	z_impl_k_thread_suspend(thread);
20406bf0:	ee4ff0ef          	jal	ra,204062d4 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
20406bf4:	fff00513          	li	a0,-1
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
20406bf8:	01c12083          	lw	ra,28(sp)
20406bfc:	01812403          	lw	s0,24(sp)
20406c00:	01412483          	lw	s1,20(sp)
20406c04:	01012903          	lw	s2,16(sp)
20406c08:	00c12983          	lw	s3,12(sp)
20406c0c:	00812a03          	lw	s4,8(sp)
20406c10:	00412a83          	lw	s5,4(sp)
20406c14:	02010113          	addi	sp,sp,32
20406c18:	00008067          	ret
	ticks = z_tick_sleep(ticks);
20406c1c:	00048513          	mv	a0,s1
20406c20:	00040593          	mv	a1,s0
20406c24:	d19ff0ef          	jal	ra,2040693c <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
20406c28:	3e800713          	li	a4,1000
20406c2c:	02e507b3          	mul	a5,a0,a4
20406c30:	02e51533          	mulh	a0,a0,a4
20406c34:	0077d793          	srli	a5,a5,0x7
20406c38:	01951513          	slli	a0,a0,0x19
20406c3c:	00f56533          	or	a0,a0,a5
	return ret;
20406c40:	fb9ff06f          	j	20406bf8 <z_impl_k_sleep+0x90>

20406c44 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
20406c44:	800007b7          	lui	a5,0x80000
20406c48:	2d47a503          	lw	a0,724(a5) # 800002d4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002d5>
20406c4c:	00008067          	ret

20406c50 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
20406c50:	fe010113          	addi	sp,sp,-32
20406c54:	00812c23          	sw	s0,24(sp)
20406c58:	01212823          	sw	s2,16(sp)
20406c5c:	00112e23          	sw	ra,28(sp)
20406c60:	00912a23          	sw	s1,20(sp)
20406c64:	01312623          	sw	s3,12(sp)
20406c68:	01412423          	sw	s4,8(sp)
20406c6c:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20406c70:	00800913          	li	s2,8
20406c74:	30093973          	csrrc	s2,mstatus,s2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20406c78:	800004b7          	lui	s1,0x80000
20406c7c:	02848513          	addi	a0,s1,40 # 80000028 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000029>
	key = (mstatus & MSTATUS_IEN);
20406c80:	00897913          	andi	s2,s2,8
20406c84:	e49fd0ef          	jal	ra,20404acc <z_spin_lock_valid>
20406c88:	04051063          	bnez	a0,20406cc8 <z_thread_abort+0x78>
20406c8c:	204099b7          	lui	s3,0x20409
20406c90:	204095b7          	lui	a1,0x20409
20406c94:	20408537          	lui	a0,0x20408
20406c98:	08100693          	li	a3,129
20406c9c:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406ca0:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20406ca4:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406ca8:	b80fa0ef          	jal	ra,20401028 <printk>
20406cac:	20409537          	lui	a0,0x20409
20406cb0:	02848593          	addi	a1,s1,40
20406cb4:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20406cb8:	b70fa0ef          	jal	ra,20401028 <printk>
20406cbc:	08100593          	li	a1,129
20406cc0:	a9098513          	addi	a0,s3,-1392
20406cc4:	aa9fb0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20406cc8:	02848513          	addi	a0,s1,40
20406ccc:	e59fd0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
20406cd0:	00d44783          	lbu	a5,13(s0)
20406cd4:	0087f713          	andi	a4,a5,8
20406cd8:	06070863          	beqz	a4,20406d48 <z_thread_abort+0xf8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20406cdc:	02848513          	addi	a0,s1,40
20406ce0:	e15fd0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20406ce4:	04051063          	bnez	a0,20406d24 <z_thread_abort+0xd4>
20406ce8:	20409437          	lui	s0,0x20409
20406cec:	204095b7          	lui	a1,0x20409
20406cf0:	20408537          	lui	a0,0x20408
20406cf4:	0ac00693          	li	a3,172
20406cf8:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406cfc:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20406d00:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406d04:	b24fa0ef          	jal	ra,20401028 <printk>
20406d08:	20409537          	lui	a0,0x20409
20406d0c:	02848593          	addi	a1,s1,40
20406d10:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20406d14:	b14fa0ef          	jal	ra,20401028 <printk>
20406d18:	0ac00593          	li	a1,172
20406d1c:	a9040513          	addi	a0,s0,-1392
20406d20:	a4dfb0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20406d24:	30092973          	csrrs	s2,mstatus,s2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
20406d28:	01c12083          	lw	ra,28(sp)
20406d2c:	01812403          	lw	s0,24(sp)
20406d30:	01412483          	lw	s1,20(sp)
20406d34:	01012903          	lw	s2,16(sp)
20406d38:	00c12983          	lw	s3,12(sp)
20406d3c:	00812a03          	lw	s4,8(sp)
20406d40:	02010113          	addi	sp,sp,32
20406d44:	00008067          	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
20406d48:	fdf7f713          	andi	a4,a5,-33
20406d4c:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
20406d50:	01871693          	slli	a3,a4,0x18
20406d54:	4186d693          	srai	a3,a3,0x18
20406d58:	0c06cc63          	bltz	a3,20406e30 <z_thread_abort+0x1e0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
20406d5c:	00e406a3          	sb	a4,13(s0)
		if (thread->base.pended_on != NULL) {
20406d60:	00842783          	lw	a5,8(s0)
20406d64:	00078663          	beqz	a5,20406d70 <z_thread_abort+0x120>
			unpend_thread_no_timeout(thread);
20406d68:	00040513          	mv	a0,s0
20406d6c:	961fe0ef          	jal	ra,204056cc <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
20406d70:	01840513          	addi	a0,s0,24
20406d74:	4b4000ef          	jal	ra,20407228 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
20406d78:	06840a13          	addi	s4,s0,104
	return list->head == list;
20406d7c:	06842983          	lw	s3,104(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20406d80:	01498463          	beq	s3,s4,20406d88 <z_thread_abort+0x138>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
20406d84:	0c099663          	bnez	s3,20406e50 <z_thread_abort+0x200>
		update_cache(1);
20406d88:	00100513          	li	a0,1
20406d8c:	abdfe0ef          	jal	ra,20405848 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
20406d90:	800007b7          	lui	a5,0x80000
20406d94:	2cc78793          	addi	a5,a5,716 # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20406d98:	0087a703          	lw	a4,8(a5)
20406d9c:	f48710e3          	bne	a4,s0,20406cdc <z_thread_abort+0x8c>
20406da0:	0007a783          	lw	a5,0(a5)
20406da4:	f2079ce3          	bnez	a5,20406cdc <z_thread_abort+0x8c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20406da8:	02848513          	addi	a0,s1,40
20406dac:	d49fd0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20406db0:	204089b7          	lui	s3,0x20408
20406db4:	02051e63          	bnez	a0,20406df0 <z_thread_abort+0x1a0>
20406db8:	20409437          	lui	s0,0x20409
20406dbc:	204095b7          	lui	a1,0x20409
20406dc0:	0c300693          	li	a3,195
20406dc4:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20406dc8:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20406dcc:	3ec98513          	addi	a0,s3,1004 # 204083ec <__clz_tab+0x1a4>
20406dd0:	a58fa0ef          	jal	ra,20401028 <printk>
20406dd4:	20409537          	lui	a0,0x20409
20406dd8:	02848593          	addi	a1,s1,40
20406ddc:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20406de0:	a48fa0ef          	jal	ra,20401028 <printk>
20406de4:	0c300593          	li	a1,195
20406de8:	a9040513          	addi	a0,s0,-1392
20406dec:	981fb0ef          	jal	ra,2040276c <assert_post_action>
20406df0:	00090513          	mv	a0,s2
20406df4:	cccf90ef          	jal	ra,204002c0 <arch_swap>
		__ASSERT(false, "aborted _current back from dead");
20406df8:	20409437          	lui	s0,0x20409
20406dfc:	204095b7          	lui	a1,0x20409
20406e00:	64b00693          	li	a3,1611
20406e04:	e0c40613          	addi	a2,s0,-500 # 20408e0c <levels.0+0x2f4>
20406e08:	fc458593          	addi	a1,a1,-60 # 20408fc4 <levels.0+0x4ac>
20406e0c:	3ec98513          	addi	a0,s3,1004
20406e10:	a18fa0ef          	jal	ra,20401028 <printk>
20406e14:	20409537          	lui	a0,0x20409
20406e18:	f0850513          	addi	a0,a0,-248 # 20408f08 <levels.0+0x3f0>
20406e1c:	a0cfa0ef          	jal	ra,20401028 <printk>
20406e20:	64b00593          	li	a1,1611
20406e24:	e0c40513          	addi	a0,s0,-500
20406e28:	945fb0ef          	jal	ra,2040276c <assert_post_action>
20406e2c:	eb1ff06f          	j	20406cdc <z_thread_abort+0x8c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20406e30:	05f7f793          	andi	a5,a5,95
20406e34:	0087e793          	ori	a5,a5,8
	_priq_run_remove(thread_runq(thread), thread);
20406e38:	80000537          	lui	a0,0x80000
	thread->base.thread_state &= ~_THREAD_QUEUED;
20406e3c:	00f406a3          	sb	a5,13(s0)
	_priq_run_remove(thread_runq(thread), thread);
20406e40:	00040593          	mv	a1,s0
20406e44:	2e850513          	addi	a0,a0,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
20406e48:	80dfe0ef          	jal	ra,20405654 <z_priq_dumb_remove>
}
20406e4c:	f15ff06f          	j	20406d60 <z_thread_abort+0x110>
		unpend_thread_no_timeout(thread);
20406e50:	00098513          	mv	a0,s3
20406e54:	879fe0ef          	jal	ra,204056cc <unpend_thread_no_timeout>
20406e58:	01898513          	addi	a0,s3,24
20406e5c:	3cc000ef          	jal	ra,20407228 <z_abort_timeout>
		ready_thread(thread);
20406e60:	00098513          	mv	a0,s3
	thread->arch.swap_return_value = value;
20406e64:	0609ac23          	sw	zero,120(s3)
20406e68:	d09fe0ef          	jal	ra,20405b70 <ready_thread>
20406e6c:	f11ff06f          	j	20406d7c <z_thread_abort+0x12c>

20406e70 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
20406e70:	de1ff06f          	j	20406c50 <z_thread_abort>

20406e74 <z_data_copy>:
 * @return N/A
 */
void z_data_copy(void)
{
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
20406e74:	80002537          	lui	a0,0x80002
20406e78:	df050613          	addi	a2,a0,-528 # 80001df0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001df1>
	(void)memcpy(&__data_region_start, &__data_region_load_start,
20406e7c:	8f818793          	addi	a5,gp,-1800 # 80001f90 <__data_region_end>
20406e80:	204095b7          	lui	a1,0x20409
20406e84:	40c78633          	sub	a2,a5,a2
20406e88:	11c58593          	addi	a1,a1,284 # 2040911c <__data_load_start>
20406e8c:	df050513          	addi	a0,a0,-528
20406e90:	b6dfb06f          	j	204029fc <memcpy>

20406e94 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
20406e94:	800007b7          	lui	a5,0x80000
20406e98:	0347a783          	lw	a5,52(a5) # 80000034 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000035>
20406e9c:	00079463          	bnez	a5,20406ea4 <elapsed+0x10>
20406ea0:	cc4fd06f          	j	20404364 <sys_clock_elapsed>
}
20406ea4:	00000513          	li	a0,0
20406ea8:	00008067          	ret

20406eac <next_timeout>:

static int32_t next_timeout(void)
{
20406eac:	ff010113          	addi	sp,sp,-16
	return list->head == list;
20406eb0:	82018793          	addi	a5,gp,-2016 # 80001eb8 <timeout_list>
20406eb4:	00812423          	sw	s0,8(sp)
20406eb8:	0007a403          	lw	s0,0(a5)
20406ebc:	00112623          	sw	ra,12(sp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20406ec0:	00f41463          	bne	s0,a5,20406ec8 <next_timeout+0x1c>
20406ec4:	00000413          	li	s0,0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
20406ec8:	fcdff0ef          	jal	ra,20406e94 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
20406ecc:	02040c63          	beqz	s0,20406f04 <next_timeout+0x58>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
20406ed0:	01042703          	lw	a4,16(s0)
20406ed4:	01442783          	lw	a5,20(s0)
20406ed8:	41f55693          	srai	a3,a0,0x1f
20406edc:	40a70533          	sub	a0,a4,a0
20406ee0:	00a73733          	sltu	a4,a4,a0
20406ee4:	40d787b3          	sub	a5,a5,a3
20406ee8:	40e787b3          	sub	a5,a5,a4
	int32_t ret = to == NULL ? MAX_WAIT
20406eec:	00f04663          	bgtz	a5,20406ef8 <next_timeout+0x4c>
20406ef0:	04079063          	bnez	a5,20406f30 <next_timeout+0x84>
20406ef4:	02050e63          	beqz	a0,20406f30 <next_timeout+0x84>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
20406ef8:	00f04663          	bgtz	a5,20406f04 <next_timeout+0x58>
20406efc:	00079863          	bnez	a5,20406f0c <next_timeout+0x60>
20406f00:	00055663          	bgez	a0,20406f0c <next_timeout+0x60>
	int32_t ret = to == NULL ? MAX_WAIT
20406f04:	80000537          	lui	a0,0x80000
20406f08:	fff54513          	not	a0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
20406f0c:	800007b7          	lui	a5,0x80000
20406f10:	2dc7a783          	lw	a5,732(a5) # 800002dc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002dd>
20406f14:	00078663          	beqz	a5,20406f20 <next_timeout+0x74>
20406f18:	00a7d463          	bge	a5,a0,20406f20 <next_timeout+0x74>
20406f1c:	00078513          	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
20406f20:	00c12083          	lw	ra,12(sp)
20406f24:	00812403          	lw	s0,8(sp)
20406f28:	01010113          	addi	sp,sp,16
20406f2c:	00008067          	ret
	int32_t ret = to == NULL ? MAX_WAIT
20406f30:	00000513          	li	a0,0
20406f34:	fd9ff06f          	j	20406f0c <next_timeout+0x60>

20406f38 <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
20406f38:	00052783          	lw	a5,0(a0) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
20406f3c:	02050c63          	beqz	a0,20406f74 <remove_timeout+0x3c>
	return (node == list->tail) ? NULL : node->next;
20406f40:	8241a703          	lw	a4,-2012(gp) # 80001ebc <timeout_list+0x4>
20406f44:	02e50863          	beq	a0,a4,20406f74 <remove_timeout+0x3c>
	if (next(t) != NULL) {
20406f48:	02078663          	beqz	a5,20406f74 <remove_timeout+0x3c>
		next(t)->dticks += t->dticks;
20406f4c:	0107a703          	lw	a4,16(a5)
20406f50:	01052683          	lw	a3,16(a0)
20406f54:	01452583          	lw	a1,20(a0)
20406f58:	0147a603          	lw	a2,20(a5)
20406f5c:	00d706b3          	add	a3,a4,a3
20406f60:	00e6b733          	sltu	a4,a3,a4
20406f64:	00b60633          	add	a2,a2,a1
20406f68:	00c70733          	add	a4,a4,a2
20406f6c:	00d7a823          	sw	a3,16(a5)
20406f70:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = node->prev;
20406f74:	00452703          	lw	a4,4(a0)
	prev->next = next;
20406f78:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
20406f7c:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
20406f80:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
20406f84:	00052223          	sw	zero,4(a0)
}
20406f88:	00008067          	ret

20406f8c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
20406f8c:	fe010113          	addi	sp,sp,-32
20406f90:	00812c23          	sw	s0,24(sp)
20406f94:	00912a23          	sw	s1,20(sp)
20406f98:	01212823          	sw	s2,16(sp)
20406f9c:	01412423          	sw	s4,8(sp)
20406fa0:	00112e23          	sw	ra,28(sp)
20406fa4:	00068a13          	mv	s4,a3
20406fa8:	01312623          	sw	s3,12(sp)
20406fac:	01512223          	sw	s5,4(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20406fb0:	fff00693          	li	a3,-1
{
20406fb4:	00050413          	mv	s0,a0
20406fb8:	00058913          	mv	s2,a1
20406fbc:	00060493          	mv	s1,a2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20406fc0:	00d61463          	bne	a2,a3,20406fc8 <z_add_timeout+0x3c>
20406fc4:	24ca0063          	beq	s4,a2,20407204 <z_add_timeout+0x278>

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
20406fc8:	00042783          	lw	a5,0(s0)
20406fcc:	02078e63          	beqz	a5,20407008 <z_add_timeout+0x7c>
20406fd0:	204099b7          	lui	s3,0x20409
20406fd4:	204095b7          	lui	a1,0x20409
20406fd8:	20408537          	lui	a0,0x20408
20406fdc:	f5058593          	addi	a1,a1,-176 # 20408f50 <levels.0+0x438>
20406fe0:	05d00693          	li	a3,93
20406fe4:	f2c98613          	addi	a2,s3,-212 # 20408f2c <levels.0+0x414>
20406fe8:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20406fec:	83cfa0ef          	jal	ra,20401028 <printk>
20406ff0:	20409537          	lui	a0,0x20409
20406ff4:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
20406ff8:	830fa0ef          	jal	ra,20401028 <printk>
20406ffc:	05d00593          	li	a1,93
20407000:	f2c98513          	addi	a0,s3,-212
20407004:	f68fb0ef          	jal	ra,2040276c <assert_post_action>
	to->fn = fn;
20407008:	01242423          	sw	s2,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
2040700c:	00800993          	li	s3,8
20407010:	3009b9f3          	csrrc	s3,mstatus,s3
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20407014:	80000937          	lui	s2,0x80000
20407018:	03890513          	addi	a0,s2,56 # 80000038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000039>
	key = (mstatus & MSTATUS_IEN);
2040701c:	0089f993          	andi	s3,s3,8
20407020:	aadfd0ef          	jal	ra,20404acc <z_spin_lock_valid>
20407024:	04051063          	bnez	a0,20407064 <z_add_timeout+0xd8>
20407028:	20409ab7          	lui	s5,0x20409
2040702c:	204095b7          	lui	a1,0x20409
20407030:	20408537          	lui	a0,0x20408
20407034:	08100693          	li	a3,129
20407038:	a90a8613          	addi	a2,s5,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
2040703c:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20407040:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407044:	fe5f90ef          	jal	ra,20401028 <printk>
20407048:	20409537          	lui	a0,0x20409
2040704c:	03890593          	addi	a1,s2,56
20407050:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20407054:	fd5f90ef          	jal	ra,20401028 <printk>
20407058:	08100593          	li	a1,129
2040705c:	a90a8513          	addi	a0,s5,-1392
20407060:	f0cfb0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20407064:	03890513          	addi	a0,s2,56
20407068:	abdfd0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
2040706c:	ffe00693          	li	a3,-2
20407070:	409687b3          	sub	a5,a3,s1
20407074:	00f6b733          	sltu	a4,a3,a5
20407078:	fffa4793          	not	a5,s4
2040707c:	40e787b3          	sub	a5,a5,a4
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
20407080:	0607cc63          	bltz	a5,204070f8 <z_add_timeout+0x16c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
20407084:	800007b7          	lui	a5,0x80000
20407088:	00878793          	addi	a5,a5,8 # 80000008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000009>
2040708c:	0007a703          	lw	a4,0(a5)
20407090:	0047a783          	lw	a5,4(a5)
20407094:	40e68733          	sub	a4,a3,a4
20407098:	00e6b6b3          	sltu	a3,a3,a4
2040709c:	fff7c793          	not	a5,a5
204070a0:	40d787b3          	sub	a5,a5,a3
204070a4:	409704b3          	sub	s1,a4,s1
204070a8:	00973733          	sltu	a4,a4,s1
204070ac:	414786b3          	sub	a3,a5,s4

			to->dticks = MAX(1, ticks);
204070b0:	40e686b3          	sub	a3,a3,a4
204070b4:	00d04a63          	bgtz	a3,204070c8 <z_add_timeout+0x13c>
204070b8:	00069463          	bnez	a3,204070c0 <z_add_timeout+0x134>
204070bc:	00049663          	bnez	s1,204070c8 <z_add_timeout+0x13c>
204070c0:	00100493          	li	s1,1
204070c4:	00000693          	li	a3,0
204070c8:	00942823          	sw	s1,16(s0)
	return list->head == list;
204070cc:	82018713          	addi	a4,gp,-2016 # 80001eb8 <timeout_list>
204070d0:	00072783          	lw	a5,0(a4)
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
204070d4:	00d42a23          	sw	a3,20(s0)
204070d8:	82018613          	addi	a2,gp,-2016 # 80001eb8 <timeout_list>
	sys_dnode_t *const tail = list->tail;
204070dc:	00472803          	lw	a6,4(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
204070e0:	06c79263          	bne	a5,a2,20407144 <z_add_timeout+0x1b8>
	node->next = list;
204070e4:	00c42023          	sw	a2,0(s0)
	node->prev = tail;
204070e8:	01042223          	sw	a6,4(s0)
	tail->next = node;
204070ec:	00882023          	sw	s0,0(a6)
	list->tail = node;
204070f0:	00862223          	sw	s0,4(a2)
}
204070f4:	09c0006f          	j	20407190 <z_add_timeout+0x204>
204070f8:	d9dff0ef          	jal	ra,20406e94 <elapsed>
204070fc:	00148793          	addi	a5,s1,1
20407100:	0097b4b3          	sltu	s1,a5,s1
20407104:	014486b3          	add	a3,s1,s4
20407108:	41f55493          	srai	s1,a0,0x1f
2040710c:	00a78533          	add	a0,a5,a0
20407110:	00f537b3          	sltu	a5,a0,a5
20407114:	009686b3          	add	a3,a3,s1
20407118:	00d786b3          	add	a3,a5,a3
2040711c:	00a42823          	sw	a0,16(s0)
20407120:	fadff06f          	j	204070cc <z_add_timeout+0x140>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
20407124:	40e68733          	sub	a4,a3,a4
20407128:	00e6b6b3          	sltu	a3,a3,a4
2040712c:	40a585b3          	sub	a1,a1,a0
20407130:	40d586b3          	sub	a3,a1,a3
20407134:	00e42823          	sw	a4,16(s0)
20407138:	00d42a23          	sw	a3,20(s0)
	return (node == list->tail) ? NULL : node->next;
2040713c:	faf804e3          	beq	a6,a5,204070e4 <z_add_timeout+0x158>
20407140:	0007a783          	lw	a5,0(a5)
		for (t = first(); t != NULL; t = next(t)) {
20407144:	fa0780e3          	beqz	a5,204070e4 <z_add_timeout+0x158>
			if (t->dticks > to->dticks) {
20407148:	0147a503          	lw	a0,20(a5)
2040714c:	01442583          	lw	a1,20(s0)
20407150:	0107a703          	lw	a4,16(a5)
20407154:	01042683          	lw	a3,16(s0)
20407158:	00a5c663          	blt	a1,a0,20407164 <z_add_timeout+0x1d8>
2040715c:	fcb514e3          	bne	a0,a1,20407124 <z_add_timeout+0x198>
20407160:	fce6f2e3          	bgeu	a3,a4,20407124 <z_add_timeout+0x198>
				t->dticks -= to->dticks;
20407164:	40d706b3          	sub	a3,a4,a3
20407168:	00d73733          	sltu	a4,a4,a3
2040716c:	40b505b3          	sub	a1,a0,a1
20407170:	40e58733          	sub	a4,a1,a4
20407174:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = successor->prev;
20407178:	0047a703          	lw	a4,4(a5)
2040717c:	00d7a823          	sw	a3,16(a5)
	node->next = successor;
20407180:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
20407184:	00e42223          	sw	a4,4(s0)
	prev->next = node;
20407188:	00872023          	sw	s0,0(a4)
	successor->prev = node;
2040718c:	0087a223          	sw	s0,4(a5)
	return list->head == list;
20407190:	00062783          	lw	a5,0(a2)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20407194:	02c78263          	beq	a5,a2,204071b8 <z_add_timeout+0x22c>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
20407198:	02f41063          	bne	s0,a5,204071b8 <z_add_timeout+0x22c>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
2040719c:	d11ff0ef          	jal	ra,20406eac <next_timeout>

			if (next_time == 0 ||
204071a0:	00050863          	beqz	a0,204071b0 <z_add_timeout+0x224>
			    _current_cpu->slice_ticks != next_time) {
204071a4:	800007b7          	lui	a5,0x80000
			if (next_time == 0 ||
204071a8:	2dc7a783          	lw	a5,732(a5) # 800002dc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002dd>
204071ac:	00a78663          	beq	a5,a0,204071b8 <z_add_timeout+0x22c>
				sys_clock_set_timeout(next_time, false);
204071b0:	00000593          	li	a1,0
204071b4:	828fd0ef          	jal	ra,204041dc <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204071b8:	03890513          	addi	a0,s2,56
204071bc:	939fd0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204071c0:	04051063          	bnez	a0,20407200 <z_add_timeout+0x274>
204071c4:	20409437          	lui	s0,0x20409
204071c8:	204095b7          	lui	a1,0x20409
204071cc:	20408537          	lui	a0,0x20408
204071d0:	0ac00693          	li	a3,172
204071d4:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204071d8:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
204071dc:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204071e0:	e49f90ef          	jal	ra,20401028 <printk>
204071e4:	20409537          	lui	a0,0x20409
204071e8:	03890593          	addi	a1,s2,56
204071ec:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
204071f0:	e39f90ef          	jal	ra,20401028 <printk>
204071f4:	0ac00593          	li	a1,172
204071f8:	a9040513          	addi	a0,s0,-1392
204071fc:	d70fb0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20407200:	3009a9f3          	csrrs	s3,mstatus,s3
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
20407204:	01c12083          	lw	ra,28(sp)
20407208:	01812403          	lw	s0,24(sp)
2040720c:	01412483          	lw	s1,20(sp)
20407210:	01012903          	lw	s2,16(sp)
20407214:	00c12983          	lw	s3,12(sp)
20407218:	00812a03          	lw	s4,8(sp)
2040721c:	00412a83          	lw	s5,4(sp)
20407220:	02010113          	addi	sp,sp,32
20407224:	00008067          	ret

20407228 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
20407228:	fe010113          	addi	sp,sp,-32
2040722c:	00912a23          	sw	s1,20(sp)
20407230:	00112e23          	sw	ra,28(sp)
20407234:	00812c23          	sw	s0,24(sp)
20407238:	01212823          	sw	s2,16(sp)
2040723c:	01312623          	sw	s3,12(sp)
20407240:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20407244:	00800793          	li	a5,8
20407248:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
2040724c:	80000437          	lui	s0,0x80000
20407250:	03840513          	addi	a0,s0,56 # 80000038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000039>
	key = (mstatus & MSTATUS_IEN);
20407254:	0087f993          	andi	s3,a5,8
20407258:	875fd0ef          	jal	ra,20404acc <z_spin_lock_valid>
2040725c:	04051063          	bnez	a0,2040729c <z_abort_timeout+0x74>
20407260:	20409937          	lui	s2,0x20409
20407264:	204095b7          	lui	a1,0x20409
20407268:	20408537          	lui	a0,0x20408
2040726c:	08100693          	li	a3,129
20407270:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407274:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20407278:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040727c:	dadf90ef          	jal	ra,20401028 <printk>
20407280:	20409537          	lui	a0,0x20409
20407284:	03840593          	addi	a1,s0,56
20407288:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
2040728c:	d9df90ef          	jal	ra,20401028 <printk>
20407290:	08100593          	li	a1,129
20407294:	a9090513          	addi	a0,s2,-1392
20407298:	cd4fb0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
2040729c:	03840513          	addi	a0,s0,56
204072a0:	885fd0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
204072a4:	0004a783          	lw	a5,0(s1)
	int ret = -EINVAL;
204072a8:	fea00913          	li	s2,-22
		if (sys_dnode_is_linked(&to->node)) {
204072ac:	00078863          	beqz	a5,204072bc <z_abort_timeout+0x94>
			remove_timeout(to);
204072b0:	00048513          	mv	a0,s1
204072b4:	c85ff0ef          	jal	ra,20406f38 <remove_timeout>
			ret = 0;
204072b8:	00000913          	li	s2,0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204072bc:	03840513          	addi	a0,s0,56
204072c0:	835fd0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204072c4:	04051063          	bnez	a0,20407304 <z_abort_timeout+0xdc>
204072c8:	204094b7          	lui	s1,0x20409
204072cc:	204095b7          	lui	a1,0x20409
204072d0:	20408537          	lui	a0,0x20408
204072d4:	0ac00693          	li	a3,172
204072d8:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204072dc:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
204072e0:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204072e4:	d45f90ef          	jal	ra,20401028 <printk>
204072e8:	20409537          	lui	a0,0x20409
204072ec:	03840593          	addi	a1,s0,56
204072f0:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
204072f4:	d35f90ef          	jal	ra,20401028 <printk>
204072f8:	0ac00593          	li	a1,172
204072fc:	a9048513          	addi	a0,s1,-1392
20407300:	c6cfb0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20407304:	3009a7f3          	csrrs	a5,mstatus,s3
		}
	}

	return ret;
}
20407308:	01c12083          	lw	ra,28(sp)
2040730c:	01812403          	lw	s0,24(sp)
20407310:	01412483          	lw	s1,20(sp)
20407314:	00c12983          	lw	s3,12(sp)
20407318:	00090513          	mv	a0,s2
2040731c:	01012903          	lw	s2,16(sp)
20407320:	02010113          	addi	sp,sp,32
20407324:	00008067          	ret

20407328 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
20407328:	fe010113          	addi	sp,sp,-32
2040732c:	00912a23          	sw	s1,20(sp)
20407330:	01212823          	sw	s2,16(sp)
20407334:	00112e23          	sw	ra,28(sp)
20407338:	00812c23          	sw	s0,24(sp)
2040733c:	01312623          	sw	s3,12(sp)
20407340:	01412423          	sw	s4,8(sp)
20407344:	00050493          	mv	s1,a0
20407348:	00058913          	mv	s2,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
2040734c:	00800793          	li	a5,8
20407350:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20407354:	80000437          	lui	s0,0x80000
20407358:	03840513          	addi	a0,s0,56 # 80000038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000039>
	key = (mstatus & MSTATUS_IEN);
2040735c:	0087fa13          	andi	s4,a5,8
20407360:	f6cfd0ef          	jal	ra,20404acc <z_spin_lock_valid>
20407364:	04051063          	bnez	a0,204073a4 <z_set_timeout_expiry+0x7c>
20407368:	204099b7          	lui	s3,0x20409
2040736c:	204095b7          	lui	a1,0x20409
20407370:	20408537          	lui	a0,0x20408
20407374:	08100693          	li	a3,129
20407378:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
2040737c:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20407380:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407384:	ca5f90ef          	jal	ra,20401028 <printk>
20407388:	20409537          	lui	a0,0x20409
2040738c:	03840593          	addi	a1,s0,56
20407390:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20407394:	c95f90ef          	jal	ra,20401028 <printk>
20407398:	08100593          	li	a1,129
2040739c:	a9098513          	addi	a0,s3,-1392
204073a0:	bccfb0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
204073a4:	03840513          	addi	a0,s0,56
204073a8:	f7cfd0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
204073ac:	b01ff0ef          	jal	ra,20406eac <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
204073b0:	00100793          	li	a5,1
204073b4:	00a7da63          	bge	a5,a0,204073c8 <z_set_timeout_expiry+0xa0>
204073b8:	00954863          	blt	a0,s1,204073c8 <z_set_timeout_expiry+0xa0>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
204073bc:	00090593          	mv	a1,s2
204073c0:	00048513          	mv	a0,s1
204073c4:	e19fc0ef          	jal	ra,204041dc <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204073c8:	03840513          	addi	a0,s0,56
204073cc:	f28fd0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
204073d0:	04051063          	bnez	a0,20407410 <z_set_timeout_expiry+0xe8>
204073d4:	204094b7          	lui	s1,0x20409
204073d8:	204095b7          	lui	a1,0x20409
204073dc:	20408537          	lui	a0,0x20408
204073e0:	0ac00693          	li	a3,172
204073e4:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204073e8:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
204073ec:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204073f0:	c39f90ef          	jal	ra,20401028 <printk>
204073f4:	20409537          	lui	a0,0x20409
204073f8:	03840593          	addi	a1,s0,56
204073fc:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20407400:	c29f90ef          	jal	ra,20401028 <printk>
20407404:	0ac00593          	li	a1,172
20407408:	a9048513          	addi	a0,s1,-1392
2040740c:	b60fb0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20407410:	300a27f3          	csrrs	a5,mstatus,s4
		}
	}
}
20407414:	01c12083          	lw	ra,28(sp)
20407418:	01812403          	lw	s0,24(sp)
2040741c:	01412483          	lw	s1,20(sp)
20407420:	01012903          	lw	s2,16(sp)
20407424:	00c12983          	lw	s3,12(sp)
20407428:	00812a03          	lw	s4,8(sp)
2040742c:	02010113          	addi	sp,sp,32
20407430:	00008067          	ret

20407434 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
20407434:	fd010113          	addi	sp,sp,-48
20407438:	02812423          	sw	s0,40(sp)
2040743c:	03212023          	sw	s2,32(sp)
20407440:	02112623          	sw	ra,44(sp)
20407444:	02912223          	sw	s1,36(sp)
20407448:	01312e23          	sw	s3,28(sp)
2040744c:	01412c23          	sw	s4,24(sp)
20407450:	01512a23          	sw	s5,20(sp)
20407454:	01612823          	sw	s6,16(sp)
20407458:	01712623          	sw	s7,12(sp)
2040745c:	01812423          	sw	s8,8(sp)
20407460:	01912223          	sw	s9,4(sp)
20407464:	01a12023          	sw	s10,0(sp)
20407468:	00050913          	mv	s2,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
2040746c:	00800413          	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
20407470:	dacfe0ef          	jal	ra,20405a1c <z_time_slice>
20407474:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20407478:	800004b7          	lui	s1,0x80000
2040747c:	03848513          	addi	a0,s1,56 # 80000038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000039>
	key = (mstatus & MSTATUS_IEN);
20407480:	00847413          	andi	s0,s0,8
20407484:	e48fd0ef          	jal	ra,20404acc <z_spin_lock_valid>
20407488:	04051063          	bnez	a0,204074c8 <sys_clock_announce+0x94>
2040748c:	204099b7          	lui	s3,0x20409
20407490:	204095b7          	lui	a1,0x20409
20407494:	20408537          	lui	a0,0x20408
20407498:	08100693          	li	a3,129
2040749c:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
204074a0:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
204074a4:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
204074a8:	b81f90ef          	jal	ra,20401028 <printk>
204074ac:	20409537          	lui	a0,0x20409
204074b0:	03848593          	addi	a1,s1,56
204074b4:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204074b8:	b71f90ef          	jal	ra,20401028 <printk>
204074bc:	08100593          	li	a1,129
204074c0:	a9098513          	addi	a0,s3,-1392
204074c4:	aa8fb0ef          	jal	ra,2040276c <assert_post_action>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
204074c8:	800009b7          	lui	s3,0x80000
	z_spin_lock_set_owner(l);
204074cc:	03848513          	addi	a0,s1,56
204074d0:	e54fd0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
204074d4:	0329aa23          	sw	s2,52(s3) # 80000034 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000035>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
204074d8:	80000937          	lui	s2,0x80000
204074dc:	03498993          	addi	s3,s3,52
	return list->head == list;
204074e0:	82018a13          	addi	s4,gp,-2016 # 80001eb8 <timeout_list>
204074e4:	00890913          	addi	s2,s2,8 # 80000008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000009>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
204074e8:	20409ab7          	lui	s5,0x20409
204074ec:	20409bb7          	lui	s7,0x20409
204074f0:	20408b37          	lui	s6,0x20408
204074f4:	20409c37          	lui	s8,0x20409
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
204074f8:	20409cb7          	lui	s9,0x20409
	while (first() != NULL && first()->dticks <= announce_remaining) {
204074fc:	0009a783          	lw	a5,0(s3)
20407500:	000a2d03          	lw	s10,0(s4)
		curr_tick += dt;
20407504:	00092683          	lw	a3,0(s2)
20407508:	00492803          	lw	a6,4(s2)
2040750c:	41f7d593          	srai	a1,a5,0x1f
	return sys_dlist_is_empty(list) ? NULL : list->head;
20407510:	034d0a63          	beq	s10,s4,20407544 <sys_clock_announce+0x110>
	while (first() != NULL && first()->dticks <= announce_remaining) {
20407514:	020d0863          	beqz	s10,20407544 <sys_clock_announce+0x110>
20407518:	014d2603          	lw	a2,20(s10)
2040751c:	010d2703          	lw	a4,16(s10)
20407520:	00c5c663          	blt	a1,a2,2040752c <sys_clock_announce+0xf8>
20407524:	0cb61663          	bne	a2,a1,204075f0 <sys_clock_announce+0x1bc>
20407528:	0ce7f463          	bgeu	a5,a4,204075f0 <sys_clock_announce+0x1bc>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
2040752c:	40f70533          	sub	a0,a4,a5
20407530:	00a73733          	sltu	a4,a4,a0
20407534:	40b60633          	sub	a2,a2,a1
20407538:	40e60733          	sub	a4,a2,a4
2040753c:	00ad2823          	sw	a0,16(s10)
20407540:	00ed2a23          	sw	a4,20(s10)
	}

	curr_tick += announce_remaining;
20407544:	00d786b3          	add	a3,a5,a3
20407548:	010585b3          	add	a1,a1,a6
2040754c:	00f6b7b3          	sltu	a5,a3,a5
20407550:	00b787b3          	add	a5,a5,a1
20407554:	00d92023          	sw	a3,0(s2)
20407558:	00f92223          	sw	a5,4(s2)
	announce_remaining = 0;
2040755c:	0009a023          	sw	zero,0(s3)

	sys_clock_set_timeout(next_timeout(), false);
20407560:	94dff0ef          	jal	ra,20406eac <next_timeout>
20407564:	00000593          	li	a1,0
20407568:	c75fc0ef          	jal	ra,204041dc <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
2040756c:	03848513          	addi	a0,s1,56
20407570:	d84fd0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20407574:	04051063          	bnez	a0,204075b4 <sys_clock_announce+0x180>
20407578:	20409937          	lui	s2,0x20409
2040757c:	204095b7          	lui	a1,0x20409
20407580:	20408537          	lui	a0,0x20408
20407584:	0ac00693          	li	a3,172
20407588:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
2040758c:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20407590:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407594:	a95f90ef          	jal	ra,20401028 <printk>
20407598:	20409537          	lui	a0,0x20409
2040759c:	03848593          	addi	a1,s1,56
204075a0:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
204075a4:	a85f90ef          	jal	ra,20401028 <printk>
204075a8:	0ac00593          	li	a1,172
204075ac:	a9090513          	addi	a0,s2,-1392
204075b0:	9bcfb0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204075b4:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
204075b8:	02c12083          	lw	ra,44(sp)
204075bc:	02812403          	lw	s0,40(sp)
204075c0:	02412483          	lw	s1,36(sp)
204075c4:	02012903          	lw	s2,32(sp)
204075c8:	01c12983          	lw	s3,28(sp)
204075cc:	01812a03          	lw	s4,24(sp)
204075d0:	01412a83          	lw	s5,20(sp)
204075d4:	01012b03          	lw	s6,16(sp)
204075d8:	00c12b83          	lw	s7,12(sp)
204075dc:	00812c03          	lw	s8,8(sp)
204075e0:	00412c83          	lw	s9,4(sp)
204075e4:	00012d03          	lw	s10,0(sp)
204075e8:	03010113          	addi	sp,sp,48
204075ec:	00008067          	ret
		curr_tick += dt;
204075f0:	00d706b3          	add	a3,a4,a3
		announce_remaining -= dt;
204075f4:	40e787b3          	sub	a5,a5,a4
		curr_tick += dt;
204075f8:	41f75593          	srai	a1,a4,0x1f
204075fc:	00e6b633          	sltu	a2,a3,a4
20407600:	010585b3          	add	a1,a1,a6
		announce_remaining -= dt;
20407604:	00f9a023          	sw	a5,0(s3)
		t->dticks = 0;
20407608:	00000813          	li	a6,0
2040760c:	00000793          	li	a5,0
		curr_tick += dt;
20407610:	00b605b3          	add	a1,a2,a1
		remove_timeout(t);
20407614:	000d0513          	mv	a0,s10
		t->dticks = 0;
20407618:	00fd2823          	sw	a5,16(s10)
2040761c:	010d2a23          	sw	a6,20(s10)
		curr_tick += dt;
20407620:	00d92023          	sw	a3,0(s2)
20407624:	00b92223          	sw	a1,4(s2)
		remove_timeout(t);
20407628:	911ff0ef          	jal	ra,20406f38 <remove_timeout>
2040762c:	03848513          	addi	a0,s1,56
20407630:	cc4fd0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20407634:	02051863          	bnez	a0,20407664 <sys_clock_announce+0x230>
20407638:	0ac00693          	li	a3,172
2040763c:	a90a8613          	addi	a2,s5,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407640:	ae8b8593          	addi	a1,s7,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20407644:	3ecb0513          	addi	a0,s6,1004 # 204083ec <__clz_tab+0x1a4>
20407648:	9e1f90ef          	jal	ra,20401028 <printk>
2040764c:	03848593          	addi	a1,s1,56
20407650:	b00c0513          	addi	a0,s8,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20407654:	9d5f90ef          	jal	ra,20401028 <printk>
20407658:	0ac00593          	li	a1,172
2040765c:	a90a8513          	addi	a0,s5,-1392
20407660:	90cfb0ef          	jal	ra,2040276c <assert_post_action>
20407664:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
20407668:	008d2783          	lw	a5,8(s10)
2040766c:	000d0513          	mv	a0,s10
	__asm__ volatile ("csrrc %0, mstatus, %1"
20407670:	00800413          	li	s0,8
20407674:	000780e7          	jalr	a5
20407678:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
2040767c:	03848513          	addi	a0,s1,56
	key = (mstatus & MSTATUS_IEN);
20407680:	00847413          	andi	s0,s0,8
20407684:	c48fd0ef          	jal	ra,20404acc <z_spin_lock_valid>
20407688:	02051a63          	bnez	a0,204076bc <sys_clock_announce+0x288>
2040768c:	08100693          	li	a3,129
20407690:	a90a8613          	addi	a2,s5,-1392
20407694:	ab8c8593          	addi	a1,s9,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20407698:	3ecb0513          	addi	a0,s6,1004
2040769c:	98df90ef          	jal	ra,20401028 <printk>
204076a0:	20409537          	lui	a0,0x20409
204076a4:	03848593          	addi	a1,s1,56
204076a8:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
204076ac:	97df90ef          	jal	ra,20401028 <printk>
204076b0:	08100593          	li	a1,129
204076b4:	a90a8513          	addi	a0,s5,-1392
204076b8:	8b4fb0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
204076bc:	03848513          	addi	a0,s1,56
204076c0:	c64fd0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	return k;
204076c4:	e39ff06f          	j	204074fc <sys_clock_announce+0xc8>

204076c8 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
204076c8:	fe010113          	addi	sp,sp,-32
204076cc:	00112e23          	sw	ra,28(sp)
204076d0:	00812c23          	sw	s0,24(sp)
204076d4:	00912a23          	sw	s1,20(sp)
204076d8:	01212823          	sw	s2,16(sp)
204076dc:	01312623          	sw	s3,12(sp)
204076e0:	01412423          	sw	s4,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
204076e4:	00800793          	li	a5,8
204076e8:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
204076ec:	800004b7          	lui	s1,0x80000
204076f0:	03848513          	addi	a0,s1,56 # 80000038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000039>
	key = (mstatus & MSTATUS_IEN);
204076f4:	0087fa13          	andi	s4,a5,8
204076f8:	bd4fd0ef          	jal	ra,20404acc <z_spin_lock_valid>
204076fc:	04051063          	bnez	a0,2040773c <sys_clock_tick_get+0x74>
20407700:	20409437          	lui	s0,0x20409
20407704:	204095b7          	lui	a1,0x20409
20407708:	20408537          	lui	a0,0x20408
2040770c:	08100693          	li	a3,129
20407710:	a9040613          	addi	a2,s0,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407714:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20407718:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040771c:	90df90ef          	jal	ra,20401028 <printk>
20407720:	20409537          	lui	a0,0x20409
20407724:	03848593          	addi	a1,s1,56
20407728:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
2040772c:	8fdf90ef          	jal	ra,20401028 <printk>
20407730:	08100593          	li	a1,129
20407734:	a9040513          	addi	a0,s0,-1392
20407738:	834fb0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
2040773c:	03848513          	addi	a0,s1,56
20407740:	be4fd0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
20407744:	c21fc0ef          	jal	ra,20404364 <sys_clock_elapsed>
20407748:	800007b7          	lui	a5,0x80000
2040774c:	00878793          	addi	a5,a5,8 # 80000008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000009>
20407750:	0007a903          	lw	s2,0(a5)
20407754:	0047a403          	lw	s0,4(a5)
20407758:	01250933          	add	s2,a0,s2
2040775c:	00a93533          	sltu	a0,s2,a0
20407760:	00850433          	add	s0,a0,s0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20407764:	03848513          	addi	a0,s1,56
20407768:	b8cfd0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
2040776c:	04051063          	bnez	a0,204077ac <sys_clock_tick_get+0xe4>
20407770:	204099b7          	lui	s3,0x20409
20407774:	204095b7          	lui	a1,0x20409
20407778:	20408537          	lui	a0,0x20408
2040777c:	0ac00693          	li	a3,172
20407780:	a9098613          	addi	a2,s3,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407784:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20407788:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
2040778c:	89df90ef          	jal	ra,20401028 <printk>
20407790:	20409537          	lui	a0,0x20409
20407794:	03848593          	addi	a1,s1,56
20407798:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
2040779c:	88df90ef          	jal	ra,20401028 <printk>
204077a0:	0ac00593          	li	a1,172
204077a4:	a9098513          	addi	a0,s3,-1392
204077a8:	fc5fa0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
204077ac:	300a27f3          	csrrs	a5,mstatus,s4
	}
	return t;
}
204077b0:	01c12083          	lw	ra,28(sp)
204077b4:	00040593          	mv	a1,s0
204077b8:	01812403          	lw	s0,24(sp)
204077bc:	01412483          	lw	s1,20(sp)
204077c0:	00c12983          	lw	s3,12(sp)
204077c4:	00812a03          	lw	s4,8(sp)
204077c8:	00090513          	mv	a0,s2
204077cc:	01012903          	lw	s2,16(sp)
204077d0:	02010113          	addi	sp,sp,32
204077d4:	00008067          	ret

204077d8 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
204077d8:	ff010113          	addi	sp,sp,-16
204077dc:	00112623          	sw	ra,12(sp)
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
204077e0:	ee9ff0ef          	jal	ra,204076c8 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
204077e4:	00c12083          	lw	ra,12(sp)
204077e8:	01010113          	addi	sp,sp,16
204077ec:	00008067          	ret

204077f0 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
204077f0:	04050e63          	beqz	a0,2040784c <z_impl_k_busy_wait+0x5c>
{
204077f4:	ff010113          	addi	sp,sp,-16
204077f8:	00112623          	sw	ra,12(sp)
204077fc:	00812423          	sw	s0,8(sp)
20407800:	00912223          	sw	s1,4(sp)
20407804:	00050413          	mv	s0,a0

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
20407808:	c55fc0ef          	jal	ra,2040445c <sys_clock_cycle_get_32>
	uint32_t start_cycles = k_cycle_get_32();

	/* use 64-bit math to prevent overflow when multiplying */
	uint32_t cycles_to_wait = (uint32_t)(
		(uint64_t)usec_to_wait *
		(uint64_t)sys_clock_hw_cycles_per_sec() /
2040780c:	000f4637          	lui	a2,0xf4
20407810:	01145593          	srli	a1,s0,0x11
20407814:	00050493          	mv	s1,a0
20407818:	24060613          	addi	a2,a2,576 # f4240 <__rom_region_size+0xeaf84>
2040781c:	00f41513          	slli	a0,s0,0xf
20407820:	00000693          	li	a3,0
20407824:	b5df80ef          	jal	ra,20400380 <__udivdi3>
20407828:	00050413          	mv	s0,a0
2040782c:	c31fc0ef          	jal	ra,2040445c <sys_clock_cycle_get_32>

	for (;;) {
		uint32_t current_cycles = k_cycle_get_32();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
20407830:	409507b3          	sub	a5,a0,s1
20407834:	fe87ece3          	bltu	a5,s0,2040782c <z_impl_k_busy_wait+0x3c>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
20407838:	00c12083          	lw	ra,12(sp)
2040783c:	00812403          	lw	s0,8(sp)
20407840:	00412483          	lw	s1,4(sp)
20407844:	01010113          	addi	sp,sp,16
20407848:	00008067          	ret
2040784c:	00008067          	ret

20407850 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
20407850:	ff010113          	addi	sp,sp,-16
20407854:	00812423          	sw	s0,8(sp)
20407858:	00912223          	sw	s1,4(sp)
2040785c:	00112623          	sw	ra,12(sp)
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20407860:	fff00693          	li	a3,-1
{
20407864:	00050493          	mv	s1,a0
20407868:	00058413          	mv	s0,a1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
2040786c:	00d51463          	bne	a0,a3,20407874 <sys_clock_timeout_end_calc+0x24>
20407870:	06a58a63          	beq	a1,a0,204078e4 <sys_clock_timeout_end_calc+0x94>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
20407874:	009467b3          	or	a5,s0,s1
20407878:	00079c63          	bnez	a5,20407890 <sys_clock_timeout_end_calc+0x40>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
2040787c:	00812403          	lw	s0,8(sp)
20407880:	00c12083          	lw	ra,12(sp)
20407884:	00412483          	lw	s1,4(sp)
20407888:	01010113          	addi	sp,sp,16
		return sys_clock_tick_get();
2040788c:	e3dff06f          	j	204076c8 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
20407890:	ffe00593          	li	a1,-2
20407894:	40958533          	sub	a0,a1,s1
20407898:	00a5b7b3          	sltu	a5,a1,a0
2040789c:	fff44593          	not	a1,s0
204078a0:	40f585b3          	sub	a1,a1,a5
204078a4:	0205d663          	bgez	a1,204078d0 <sys_clock_timeout_end_calc+0x80>
		return sys_clock_tick_get() + MAX(1, dt);
204078a8:	e21ff0ef          	jal	ra,204076c8 <sys_clock_tick_get>
204078ac:	00804a63          	bgtz	s0,204078c0 <sys_clock_timeout_end_calc+0x70>
204078b0:	00041463          	bnez	s0,204078b8 <sys_clock_timeout_end_calc+0x68>
204078b4:	00049663          	bnez	s1,204078c0 <sys_clock_timeout_end_calc+0x70>
204078b8:	00100493          	li	s1,1
204078bc:	00000413          	li	s0,0
204078c0:	00a48533          	add	a0,s1,a0
204078c4:	009534b3          	sltu	s1,a0,s1
204078c8:	00b40433          	add	s0,s0,a1
204078cc:	008485b3          	add	a1,s1,s0
}
204078d0:	00c12083          	lw	ra,12(sp)
204078d4:	00812403          	lw	s0,8(sp)
204078d8:	00412483          	lw	s1,4(sp)
204078dc:	01010113          	addi	sp,sp,16
204078e0:	00008067          	ret
		return UINT64_MAX;
204078e4:	fff00513          	li	a0,-1
204078e8:	fff00593          	li	a1,-1
204078ec:	fe5ff06f          	j	204078d0 <sys_clock_timeout_end_calc+0x80>

204078f0 <z_heap_aligned_alloc>:
#include <string.h>
#include <sys/math_extras.h>
#include <sys/util.h>

static void *z_heap_aligned_alloc(struct k_heap *heap, size_t align, size_t size)
{
204078f0:	ff010113          	addi	sp,sp,-16
204078f4:	00060793          	mv	a5,a2
204078f8:	00112623          	sw	ra,12(sp)
204078fc:	00812423          	sw	s0,8(sp)
20407900:	00912223          	sw	s1,4(sp)
20407904:	01212023          	sw	s2,0(sp)
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
20407908:	00460613          	addi	a2,a2,4
2040790c:	02f67263          	bgeu	a2,a5,20407930 <z_heap_aligned_alloc+0x40>
	 * Merge a rewind bit with align value (see sys_heap_aligned_alloc()).
	 * This allows for storing the heap pointer right below the aligned
	 * boundary without wasting any memory.
	 */
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
		return NULL;
20407910:	00000413          	li	s0,0
	mem = ++heap_ref;
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
		 "misaligned memory at %p (align = %zu)", mem, align);

	return mem;
}
20407914:	00c12083          	lw	ra,12(sp)
20407918:	00040513          	mv	a0,s0
2040791c:	00812403          	lw	s0,8(sp)
20407920:	00412483          	lw	s1,4(sp)
20407924:	00012903          	lw	s2,0(sp)
20407928:	01010113          	addi	sp,sp,16
2040792c:	00008067          	ret
20407930:	00058493          	mv	s1,a1
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
20407934:	00000693          	li	a3,0
20407938:	00000713          	li	a4,0
2040793c:	0045e593          	ori	a1,a1,4
20407940:	00050413          	mv	s0,a0
20407944:	28c000ef          	jal	ra,20407bd0 <k_heap_aligned_alloc>
	if (mem == NULL) {
20407948:	fc0504e3          	beqz	a0,20407910 <z_heap_aligned_alloc+0x20>
	*heap_ref = heap;
2040794c:	00852023          	sw	s0,0(a0)
	mem = ++heap_ref;
20407950:	00450413          	addi	s0,a0,4
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
20407954:	fc0480e3          	beqz	s1,20407914 <z_heap_aligned_alloc+0x24>
20407958:	fff48793          	addi	a5,s1,-1
2040795c:	00f477b3          	and	a5,s0,a5
20407960:	fa078ae3          	beqz	a5,20407914 <z_heap_aligned_alloc+0x24>
20407964:	20409937          	lui	s2,0x20409
20407968:	204095b7          	lui	a1,0x20409
2040796c:	20408537          	lui	a0,0x20408
20407970:	02500693          	li	a3,37
20407974:	f7090613          	addi	a2,s2,-144 # 20408f70 <levels.0+0x458>
20407978:	f9458593          	addi	a1,a1,-108 # 20408f94 <levels.0+0x47c>
2040797c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407980:	ea8f90ef          	jal	ra,20401028 <printk>
20407984:	20409537          	lui	a0,0x20409
20407988:	00040593          	mv	a1,s0
2040798c:	00048613          	mv	a2,s1
20407990:	fc850513          	addi	a0,a0,-56 # 20408fc8 <levels.0+0x4b0>
20407994:	e94f90ef          	jal	ra,20401028 <printk>
20407998:	02500593          	li	a1,37
2040799c:	f7090513          	addi	a0,s2,-144
204079a0:	dcdfa0ef          	jal	ra,2040276c <assert_post_action>
204079a4:	f71ff06f          	j	20407914 <z_heap_aligned_alloc+0x24>

204079a8 <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
204079a8:	00050863          	beqz	a0,204079b8 <k_free+0x10>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
204079ac:	ffc50593          	addi	a1,a0,-4
204079b0:	ffc52503          	lw	a0,-4(a0)
204079b4:	4600006f          	j	20407e14 <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
204079b8:	00008067          	ret

204079bc <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
204079bc:	ff010113          	addi	sp,sp,-16
204079c0:	00812423          	sw	s0,8(sp)
204079c4:	00912223          	sw	s1,4(sp)
204079c8:	00112623          	sw	ra,12(sp)
204079cc:	01212023          	sw	s2,0(sp)
	__ASSERT(align / sizeof(void *) >= 1
204079d0:	00300793          	li	a5,3
{
204079d4:	00050413          	mv	s0,a0
204079d8:	00058493          	mv	s1,a1
	__ASSERT(align / sizeof(void *) >= 1
204079dc:	00a7f663          	bgeu	a5,a0,204079e8 <k_aligned_alloc+0x2c>
204079e0:	00357793          	andi	a5,a0,3
204079e4:	02078e63          	beqz	a5,20407a20 <k_aligned_alloc+0x64>
204079e8:	20409937          	lui	s2,0x20409
204079ec:	204095b7          	lui	a1,0x20409
204079f0:	20408537          	lui	a0,0x20408
204079f4:	ff058593          	addi	a1,a1,-16 # 20408ff0 <levels.0+0x4d8>
204079f8:	04200693          	li	a3,66
204079fc:	f7090613          	addi	a2,s2,-144 # 20408f70 <levels.0+0x458>
20407a00:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407a04:	e24f90ef          	jal	ra,20401028 <printk>
20407a08:	20409537          	lui	a0,0x20409
20407a0c:	03050513          	addi	a0,a0,48 # 20409030 <levels.0+0x518>
20407a10:	e18f90ef          	jal	ra,20401028 <printk>
20407a14:	04200593          	li	a1,66
20407a18:	f7090513          	addi	a0,s2,-144
20407a1c:	d51fa0ef          	jal	ra,2040276c <assert_post_action>
		&& (align % sizeof(void *)) == 0,
		"align must be a multiple of sizeof(void *)");

	__ASSERT((align & (align - 1)) == 0,
20407a20:	fff40793          	addi	a5,s0,-1
20407a24:	0087f7b3          	and	a5,a5,s0
20407a28:	02078e63          	beqz	a5,20407a64 <k_aligned_alloc+0xa8>
20407a2c:	20409937          	lui	s2,0x20409
20407a30:	204085b7          	lui	a1,0x20408
20407a34:	20408537          	lui	a0,0x20408
20407a38:	67458593          	addi	a1,a1,1652 # 20408674 <led1+0xe0>
20407a3c:	04600693          	li	a3,70
20407a40:	f7090613          	addi	a2,s2,-144 # 20408f70 <levels.0+0x458>
20407a44:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407a48:	de0f90ef          	jal	ra,20401028 <printk>
20407a4c:	20408537          	lui	a0,0x20408
20407a50:	69050513          	addi	a0,a0,1680 # 20408690 <led1+0xfc>
20407a54:	dd4f90ef          	jal	ra,20401028 <printk>
20407a58:	04600593          	li	a1,70
20407a5c:	f7090513          	addi	a0,s2,-144
20407a60:	d0dfa0ef          	jal	ra,2040276c <assert_post_action>
		"align must be a power of 2");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP);

	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
20407a64:	00040593          	mv	a1,s0

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP, ret);

	return ret;
}
20407a68:	00812403          	lw	s0,8(sp)
20407a6c:	00c12083          	lw	ra,12(sp)
20407a70:	00012903          	lw	s2,0(sp)
	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
20407a74:	00048613          	mv	a2,s1
}
20407a78:	00412483          	lw	s1,4(sp)
	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
20407a7c:	8cc18513          	addi	a0,gp,-1844 # 80001f64 <_system_heap>
}
20407a80:	01010113          	addi	sp,sp,16
	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
20407a84:	e6dff06f          	j	204078f0 <z_heap_aligned_alloc>

20407a88 <k_malloc>:

void *k_malloc(size_t size)
{
20407a88:	00050593          	mv	a1,a0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_malloc, _SYSTEM_HEAP);

	void *ret = k_aligned_alloc(sizeof(void *), size);
20407a8c:	00400513          	li	a0,4
20407a90:	f2dff06f          	j	204079bc <k_aligned_alloc>

20407a94 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
20407a94:	fe010113          	addi	sp,sp,-32
20407a98:	00812c23          	sw	s0,24(sp)
20407a9c:	00112e23          	sw	ra,28(sp)
20407aa0:	00050413          	mv	s0,a0
20407aa4:	00b12623          	sw	a1,12(sp)
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
20407aa8:	d21fc0ef          	jal	ra,204047c8 <k_is_in_isr>
20407aac:	00c12603          	lw	a2,12(sp)
20407ab0:	02051663          	bnez	a0,20407adc <z_thread_aligned_alloc+0x48>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
20407ab4:	800007b7          	lui	a5,0x80000
20407ab8:	2d47a783          	lw	a5,724(a5) # 800002d4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002d5>
20407abc:	0747a783          	lw	a5,116(a5)
	}

	if (heap != NULL) {
20407ac0:	02078263          	beqz	a5,20407ae4 <z_thread_aligned_alloc+0x50>
		ret = z_heap_aligned_alloc(heap, align, size);
20407ac4:	00040593          	mv	a1,s0
	} else {
		ret = NULL;
	}

	return ret;
}
20407ac8:	01812403          	lw	s0,24(sp)
20407acc:	01c12083          	lw	ra,28(sp)
		ret = z_heap_aligned_alloc(heap, align, size);
20407ad0:	00078513          	mv	a0,a5
}
20407ad4:	02010113          	addi	sp,sp,32
		ret = z_heap_aligned_alloc(heap, align, size);
20407ad8:	e19ff06f          	j	204078f0 <z_heap_aligned_alloc>
		heap = _SYSTEM_HEAP;
20407adc:	8cc18793          	addi	a5,gp,-1844 # 80001f64 <_system_heap>
20407ae0:	fe5ff06f          	j	20407ac4 <z_thread_aligned_alloc+0x30>
}
20407ae4:	01c12083          	lw	ra,28(sp)
20407ae8:	01812403          	lw	s0,24(sp)
20407aec:	02010113          	addi	sp,sp,32
20407af0:	00008067          	ret

20407af4 <main>:
	__asm__ volatile("nop");
20407af4:	00000013          	nop

void __weak main(void)
{
	/* NOP default main() if the application does not provide one. */
	arch_nop();
}
20407af8:	00008067          	ret

20407afc <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
20407afc:	20408637          	lui	a2,0x20408
20407b00:	204095b7          	lui	a1,0x20409
20407b04:	20409537          	lui	a0,0x20409
20407b08:	50460613          	addi	a2,a2,1284 # 20408504 <__clz_tab+0x2bc>
20407b0c:	06058593          	addi	a1,a1,96 # 20409060 <levels.0+0x548>
20407b10:	07050513          	addi	a0,a0,112 # 20409070 <levels.0+0x558>
20407b14:	d14f906f          	j	20401028 <printk>

20407b18 <k_heap_init>:
	sys_dlist_init(&w->waitq);
20407b18:	00c50713          	addi	a4,a0,12
	list->head = (sys_dnode_t *)list;
20407b1c:	00e52623          	sw	a4,12(a0)
	list->tail = (sys_dnode_t *)list;
20407b20:	00e52823          	sw	a4,16(a0)
#include <linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
20407b24:	d5df906f          	j	20401880 <sys_heap_init>

20407b28 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
20407b28:	fe010113          	addi	sp,sp,-32
20407b2c:	00812c23          	sw	s0,24(sp)
20407b30:	00912a23          	sw	s1,20(sp)
20407b34:	01212823          	sw	s2,16(sp)
20407b38:	01312623          	sw	s3,12(sp)
20407b3c:	01412423          	sw	s4,8(sp)
20407b40:	01512223          	sw	s5,4(sp)
20407b44:	00112e23          	sw	ra,28(sp)
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
20407b48:	8cc18413          	addi	s0,gp,-1844 # 80001f64 <_system_heap>
20407b4c:	8e418493          	addi	s1,gp,-1820 # 80001f7c <printk_fifo>
20407b50:	20409937          	lui	s2,0x20409
20407b54:	204099b7          	lui	s3,0x20409
20407b58:	20408a37          	lui	s4,0x20408
20407b5c:	20409ab7          	lui	s5,0x20409
20407b60:	0284f663          	bgeu	s1,s0,20407b8c <statics_init+0x64>
20407b64:	0bc98593          	addi	a1,s3,188 # 204090bc <levels.0+0x5a4>
20407b68:	01800693          	li	a3,24
20407b6c:	09890613          	addi	a2,s2,152 # 20409098 <levels.0+0x580>
20407b70:	3eca0513          	addi	a0,s4,1004 # 204083ec <__clz_tab+0x1a4>
20407b74:	cb4f90ef          	jal	ra,20401028 <printk>
20407b78:	cb8a8513          	addi	a0,s5,-840 # 20408cb8 <levels.0+0x1a0>
20407b7c:	cacf90ef          	jal	ra,20401028 <printk>
20407b80:	01800593          	li	a1,24
20407b84:	09890513          	addi	a0,s2,152
20407b88:	be5fa0ef          	jal	ra,2040276c <assert_post_action>
20407b8c:	02946663          	bltu	s0,s1,20407bb8 <statics_init+0x90>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
20407b90:	01c12083          	lw	ra,28(sp)
20407b94:	01812403          	lw	s0,24(sp)
20407b98:	01412483          	lw	s1,20(sp)
20407b9c:	01012903          	lw	s2,16(sp)
20407ba0:	00c12983          	lw	s3,12(sp)
20407ba4:	00812a03          	lw	s4,8(sp)
20407ba8:	00412a83          	lw	s5,4(sp)
20407bac:	00000513          	li	a0,0
20407bb0:	02010113          	addi	sp,sp,32
20407bb4:	00008067          	ret
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
20407bb8:	00842603          	lw	a2,8(s0)
20407bbc:	00442583          	lw	a1,4(s0)
20407bc0:	00040513          	mv	a0,s0
	STRUCT_SECTION_FOREACH(k_heap, h) {
20407bc4:	01840413          	addi	s0,s0,24
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
20407bc8:	f51ff0ef          	jal	ra,20407b18 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
20407bcc:	f95ff06f          	j	20407b60 <statics_init+0x38>

20407bd0 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
20407bd0:	fb010113          	addi	sp,sp,-80
20407bd4:	03312e23          	sw	s3,60(sp)
20407bd8:	00b12423          	sw	a1,8(sp)
20407bdc:	00050993          	mv	s3,a0
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
20407be0:	00070593          	mv	a1,a4
20407be4:	00068513          	mv	a0,a3
{
20407be8:	04812423          	sw	s0,72(sp)
20407bec:	04912223          	sw	s1,68(sp)
20407bf0:	05212023          	sw	s2,64(sp)
20407bf4:	03412c23          	sw	s4,56(sp)
20407bf8:	03512a23          	sw	s5,52(sp)
20407bfc:	03612823          	sw	s6,48(sp)
20407c00:	04112623          	sw	ra,76(sp)
20407c04:	03712623          	sw	s7,44(sp)
20407c08:	03812423          	sw	s8,40(sp)
20407c0c:	03912223          	sw	s9,36(sp)
20407c10:	03a12023          	sw	s10,32(sp)
20407c14:	01b12e23          	sw	s11,28(sp)
20407c18:	00c12623          	sw	a2,12(sp)
20407c1c:	00068a93          	mv	s5,a3
20407c20:	00070b13          	mv	s6,a4
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
20407c24:	c2dff0ef          	jal	ra,20407850 <sys_clock_timeout_end_calc>
20407c28:	00050913          	mv	s2,a0
20407c2c:	00058a13          	mv	s4,a1
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
20407c30:	01498493          	addi	s1,s3,20
	__asm__ volatile ("csrrc %0, mstatus, %1"
20407c34:	00800413          	li	s0,8
20407c38:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20407c3c:	00048513          	mv	a0,s1
	key = (mstatus & MSTATUS_IEN);
20407c40:	00847413          	andi	s0,s0,8
20407c44:	e89fc0ef          	jal	ra,20404acc <z_spin_lock_valid>
20407c48:	04051063          	bnez	a0,20407c88 <k_heap_aligned_alloc+0xb8>
20407c4c:	20409bb7          	lui	s7,0x20409
20407c50:	204095b7          	lui	a1,0x20409
20407c54:	20408537          	lui	a0,0x20408
20407c58:	08100693          	li	a3,129
20407c5c:	a90b8613          	addi	a2,s7,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407c60:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20407c64:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407c68:	bc0f90ef          	jal	ra,20401028 <printk>
20407c6c:	20409537          	lui	a0,0x20409
20407c70:	00048593          	mv	a1,s1
20407c74:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20407c78:	bb0f90ef          	jal	ra,20401028 <printk>
20407c7c:	08100593          	li	a1,129
20407c80:	a90b8513          	addi	a0,s7,-1392
20407c84:	ae9fa0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20407c88:	00048513          	mv	a0,s1
20407c8c:	e99fc0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
20407c90:	800007b7          	lui	a5,0x80000
20407c94:	2cc7a783          	lw	a5,716(a5) # 800002cc <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002cd>
20407c98:	04078263          	beqz	a5,20407cdc <k_heap_aligned_alloc+0x10c>
20407c9c:	016aeab3          	or	s5,s5,s6
20407ca0:	020a8e63          	beqz	s5,20407cdc <k_heap_aligned_alloc+0x10c>
20407ca4:	20409ab7          	lui	s5,0x20409
20407ca8:	204095b7          	lui	a1,0x20409
20407cac:	20408537          	lui	a0,0x20408
20407cb0:	0d458593          	addi	a1,a1,212 # 204090d4 <levels.0+0x5bc>
20407cb4:	04900693          	li	a3,73
20407cb8:	098a8613          	addi	a2,s5,152 # 20409098 <levels.0+0x580>
20407cbc:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407cc0:	b68f90ef          	jal	ra,20401028 <printk>
20407cc4:	20409537          	lui	a0,0x20409
20407cc8:	d9450513          	addi	a0,a0,-620 # 20408d94 <levels.0+0x27c>
20407ccc:	b5cf90ef          	jal	ra,20401028 <printk>
20407cd0:	04900593          	li	a1,73
20407cd4:	098a8513          	addi	a0,s5,152
20407cd8:	a95fa0ef          	jal	ra,2040276c <assert_post_action>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
20407cdc:	00c98b93          	addi	s7,s3,12
	__asm__ volatile ("csrrc %0, mstatus, %1"
20407ce0:	00800c13          	li	s8,8
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20407ce4:	20409b37          	lui	s6,0x20409
20407ce8:	20409cb7          	lui	s9,0x20409
20407cec:	20408d37          	lui	s10,0x20408
20407cf0:	20409db7          	lui	s11,0x20409
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
20407cf4:	00c12603          	lw	a2,12(sp)
20407cf8:	00812583          	lw	a1,8(sp)
20407cfc:	00098513          	mv	a0,s3
20407d00:	9a1f90ef          	jal	ra,204016a0 <sys_heap_aligned_alloc>
20407d04:	00050a93          	mv	s5,a0
		now = sys_clock_tick_get();
20407d08:	9c1ff0ef          	jal	ra,204076c8 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
20407d0c:	080a8863          	beqz	s5,20407d9c <k_heap_aligned_alloc+0x1cc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20407d10:	00048513          	mv	a0,s1
20407d14:	de1fc0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20407d18:	04051063          	bnez	a0,20407d58 <k_heap_aligned_alloc+0x188>
20407d1c:	20409937          	lui	s2,0x20409
20407d20:	204095b7          	lui	a1,0x20409
20407d24:	20408537          	lui	a0,0x20408
20407d28:	0ac00693          	li	a3,172
20407d2c:	a9090613          	addi	a2,s2,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407d30:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20407d34:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407d38:	af0f90ef          	jal	ra,20401028 <printk>
20407d3c:	20409537          	lui	a0,0x20409
20407d40:	00048593          	mv	a1,s1
20407d44:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20407d48:	ae0f90ef          	jal	ra,20401028 <printk>
20407d4c:	0ac00593          	li	a1,172
20407d50:	a9090513          	addi	a0,s2,-1392
20407d54:	a19fa0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20407d58:	30042473          	csrrs	s0,mstatus,s0

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
20407d5c:	04c12083          	lw	ra,76(sp)
20407d60:	04812403          	lw	s0,72(sp)
20407d64:	04412483          	lw	s1,68(sp)
20407d68:	04012903          	lw	s2,64(sp)
20407d6c:	03c12983          	lw	s3,60(sp)
20407d70:	03812a03          	lw	s4,56(sp)
20407d74:	03012b03          	lw	s6,48(sp)
20407d78:	02c12b83          	lw	s7,44(sp)
20407d7c:	02812c03          	lw	s8,40(sp)
20407d80:	02412c83          	lw	s9,36(sp)
20407d84:	02012d03          	lw	s10,32(sp)
20407d88:	01c12d83          	lw	s11,28(sp)
20407d8c:	000a8513          	mv	a0,s5
20407d90:	03412a83          	lw	s5,52(sp)
20407d94:	05010113          	addi	sp,sp,80
20407d98:	00008067          	ret
		    (ret != NULL) || ((end - now) <= 0)) {
20407d9c:	40a906b3          	sub	a3,s2,a0
20407da0:	00d93733          	sltu	a4,s2,a3
20407da4:	40ba05b3          	sub	a1,s4,a1
20407da8:	40e58733          	sub	a4,a1,a4
20407dac:	00e04663          	bgtz	a4,20407db8 <k_heap_aligned_alloc+0x1e8>
20407db0:	f60710e3          	bnez	a4,20407d10 <k_heap_aligned_alloc+0x140>
20407db4:	f4068ee3          	beqz	a3,20407d10 <k_heap_aligned_alloc+0x140>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
20407db8:	000b8613          	mv	a2,s7
20407dbc:	00040593          	mv	a1,s0
20407dc0:	00048513          	mv	a0,s1
20407dc4:	c78fe0ef          	jal	ra,2040623c <z_pend_curr>
	__asm__ volatile ("csrrc %0, mstatus, %1"
20407dc8:	300c3473          	csrrc	s0,mstatus,s8
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20407dcc:	00048513          	mv	a0,s1
	key = (mstatus & MSTATUS_IEN);
20407dd0:	00847413          	andi	s0,s0,8
20407dd4:	cf9fc0ef          	jal	ra,20404acc <z_spin_lock_valid>
20407dd8:	02051863          	bnez	a0,20407e08 <k_heap_aligned_alloc+0x238>
20407ddc:	08100693          	li	a3,129
20407de0:	a90b0613          	addi	a2,s6,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407de4:	ab8c8593          	addi	a1,s9,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20407de8:	3ecd0513          	addi	a0,s10,1004 # 204083ec <__clz_tab+0x1a4>
20407dec:	a3cf90ef          	jal	ra,20401028 <printk>
20407df0:	00048593          	mv	a1,s1
20407df4:	ad0d8513          	addi	a0,s11,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20407df8:	a30f90ef          	jal	ra,20401028 <printk>
20407dfc:	08100593          	li	a1,129
20407e00:	a90b0513          	addi	a0,s6,-1392
20407e04:	969fa0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20407e08:	00048513          	mv	a0,s1
20407e0c:	d19fc0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>
	return k;
20407e10:	ee5ff06f          	j	20407cf4 <k_heap_aligned_alloc+0x124>

20407e14 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
20407e14:	fe010113          	addi	sp,sp,-32
20407e18:	00812c23          	sw	s0,24(sp)
20407e1c:	00912a23          	sw	s1,20(sp)
20407e20:	01212823          	sw	s2,16(sp)
20407e24:	01312623          	sw	s3,12(sp)
20407e28:	00112e23          	sw	ra,28(sp)
20407e2c:	01412423          	sw	s4,8(sp)
20407e30:	00050493          	mv	s1,a0
20407e34:	00058913          	mv	s2,a1
	k_spinlock_key_t key = k_spin_lock(&h->lock);
20407e38:	01450993          	addi	s3,a0,20
	__asm__ volatile ("csrrc %0, mstatus, %1"
20407e3c:	00800413          	li	s0,8
20407e40:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
20407e44:	00098513          	mv	a0,s3
	key = (mstatus & MSTATUS_IEN);
20407e48:	00847413          	andi	s0,s0,8
20407e4c:	c81fc0ef          	jal	ra,20404acc <z_spin_lock_valid>
20407e50:	04051063          	bnez	a0,20407e90 <k_heap_free+0x7c>
20407e54:	20409a37          	lui	s4,0x20409
20407e58:	204095b7          	lui	a1,0x20409
20407e5c:	20408537          	lui	a0,0x20408
20407e60:	08100693          	li	a3,129
20407e64:	a90a0613          	addi	a2,s4,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407e68:	ab858593          	addi	a1,a1,-1352 # 20408ab8 <uart_sifive_driver_api+0x74>
20407e6c:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407e70:	9b8f90ef          	jal	ra,20401028 <printk>
20407e74:	20409537          	lui	a0,0x20409
20407e78:	00098593          	mv	a1,s3
20407e7c:	ad050513          	addi	a0,a0,-1328 # 20408ad0 <uart_sifive_driver_api+0x8c>
20407e80:	9a8f90ef          	jal	ra,20401028 <printk>
20407e84:	08100593          	li	a1,129
20407e88:	a90a0513          	addi	a0,s4,-1392
20407e8c:	8e1fa0ef          	jal	ra,2040276c <assert_post_action>
	z_spin_lock_set_owner(l);
20407e90:	00098513          	mv	a0,s3
20407e94:	c91fc0ef          	jal	ra,20404b24 <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
20407e98:	00048513          	mv	a0,s1
20407e9c:	00090593          	mv	a1,s2
20407ea0:	e34f90ef          	jal	ra,204014d4 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
20407ea4:	00c48513          	addi	a0,s1,12
20407ea8:	825fe0ef          	jal	ra,204066cc <z_unpend_all>
20407eac:	02050663          	beqz	a0,20407ed8 <k_heap_free+0xc4>
		z_reschedule(&h->lock, key);
20407eb0:	00040593          	mv	a1,s0
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
20407eb4:	01812403          	lw	s0,24(sp)
20407eb8:	01c12083          	lw	ra,28(sp)
20407ebc:	01412483          	lw	s1,20(sp)
20407ec0:	01012903          	lw	s2,16(sp)
20407ec4:	00812a03          	lw	s4,8(sp)
		z_reschedule(&h->lock, key);
20407ec8:	00098513          	mv	a0,s3
}
20407ecc:	00c12983          	lw	s3,12(sp)
20407ed0:	02010113          	addi	sp,sp,32
		z_reschedule(&h->lock, key);
20407ed4:	cccfd06f          	j	204053a0 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
20407ed8:	00098513          	mv	a0,s3
20407edc:	c19fc0ef          	jal	ra,20404af4 <z_spin_unlock_valid>
20407ee0:	04051063          	bnez	a0,20407f20 <k_heap_free+0x10c>
20407ee4:	204094b7          	lui	s1,0x20409
20407ee8:	204095b7          	lui	a1,0x20409
20407eec:	20408537          	lui	a0,0x20408
20407ef0:	0ac00693          	li	a3,172
20407ef4:	a9048613          	addi	a2,s1,-1392 # 20408a90 <uart_sifive_driver_api+0x4c>
20407ef8:	ae858593          	addi	a1,a1,-1304 # 20408ae8 <uart_sifive_driver_api+0xa4>
20407efc:	3ec50513          	addi	a0,a0,1004 # 204083ec <__clz_tab+0x1a4>
20407f00:	928f90ef          	jal	ra,20401028 <printk>
20407f04:	20409537          	lui	a0,0x20409
20407f08:	00098593          	mv	a1,s3
20407f0c:	b0050513          	addi	a0,a0,-1280 # 20408b00 <uart_sifive_driver_api+0xbc>
20407f10:	918f90ef          	jal	ra,20401028 <printk>
20407f14:	0ac00593          	li	a1,172
20407f18:	a9048513          	addi	a0,s1,-1392
20407f1c:	851fa0ef          	jal	ra,2040276c <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20407f20:	30042473          	csrrs	s0,mstatus,s0
}
20407f24:	01c12083          	lw	ra,28(sp)
20407f28:	01812403          	lw	s0,24(sp)
20407f2c:	01412483          	lw	s1,20(sp)
20407f30:	01012903          	lw	s2,16(sp)
20407f34:	00c12983          	lw	s3,12(sp)
20407f38:	00812a03          	lw	s4,8(sp)
20407f3c:	02010113          	addi	sp,sp,32
20407f40:	00008067          	ret
